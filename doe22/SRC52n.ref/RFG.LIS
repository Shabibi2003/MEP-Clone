c                                                                               Refg     2
c                                                                               Refg     3
c              ***************************************************              Refg     4
c              *                                                 *              Refg     5
c              *               REFRIGERATION MODULE              *              Refg     6
c              *                                                 *              Refg     7
c              ***************************************************              Refg     8
c                                                                               Refg     9
c                 DOE-2.2 Program for Building Energy Analysis                  Refg    10
c                                                                               Refg    11
c              Simulates refrigeration systems and equipment                    Refg    12
c                                                                               Refg    13
      SUBROUTINE Refrigeration(Mode)                                            Refg    14
c                                                                               Refg    15
c              Simulates each successive refrigeration plant                    Refg    16
c                                                                               Refg    17
c              Mode 31  Simulate from loads down thru condensers                Refg    18
c                   32  Simulate from the condensers up to the loads            Refg    19
c                                                                               Refg    20
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /ListsR/ ListRefgPlants, xListsR                                  /ListsR/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               Refg    25
      LOGICAL IterNode, IterReqdNode, IterReqdHsty                              Refg    26
c                                                                               Refg    27
c                                                                               Refg    28
c              Pointer to ranked list of refrigeration plants                   Refg    29
      Kli       = ListRefgPlants                                                Refg    30
      NumPlants = <li;NumItems>                                                 Refg    31
c                                                                               Refg    32
      SELECT CASE (Mode)                                                        Refg    33
c                                                                               Refg    34
c                                                                               Refg    35
c ================ LOADS TO PLANT ============================================= Refg    36
      CASE (31)                                                                 Refg    37
c                                                                               Refg    38
c              Simulate each refrigeration plant from the loads down            Refg    39
c              to the condensers, starting with the highest ranked plant        Refg    40
      DO  LI=NumPlants,1,-1                                                     Refg    41
        Jrs = <li;List>                  ! pointer to refg plant                Refg    42
c              Skip if nothing in the plant has changed                         Refg    43
        IterNode = IterReqdNode(0, <rs;SystemNodes>)                            Refg    44
        IF (.NOT. IterNode  .AND.                                               Refg    45
     &      .NOT. IterReqdHsty(<rs;SystemHstys>))  CYCLE                        Refg    46
c                                                                               Refg    47
c              Simulate the plant's liquid network to establish mass            Refg    48
c              flow, starting with the highest ranked                           Refg    49
        Kl2     = <rs;LiquidCkts>        ! list of liquid ckts                  Refg    50
        NumCkts = <l2;NumItems>          ! number of ckts                       Refg    51
        DO  L2=NumCkts,1,-1              ! highest to lowest rank ckt           Refg    52
          CALL RefgNetworkAlgs(Mode, <l2;List>)                                 Refg    53
          IF (IwinReturn .eq. 1)  Return                                        Refg    54
        ENDDO                                                                   Refg    55
c                                                                               Refg    56
c              Simulate each suction-group and its suction circuits,            Refg    57
c              starting with the highest ranked suction group                   Refg    58
        Kl2   = <rs;SuctionGroups>       ! list of suction groups               Refg    59
        NumSG = <l2;NumItems>            ! number of suction groups             Refg    60
        DO  L2=NumSG,1,-1                ! highest to lowest rank group         Refg    61
          Jsg = <l2;List>                ! pointer to suction group             Refg    62
c              Skip if nothing in the suction group has changed                 Refg    63
          IterNode = IterReqdNode(1, <sg;SystemNodes>)                          Refg    64
          IF (.NOT. IterNode  .AND.                                             Refg    65
     &        .NOT. IterReqdHsty(<sg;SystemHstys>))  CYCLE                      Refg    66
c                                                                               Refg    67
c              Simulate the suction circuits to establish desuperheat,          Refg    68
c              mass flow, enthalpy, and required suction pressure               Refg    69
          Kl3     = <sg;SuctionCkts>     ! list of suction ckts                 Refg    70
          NumCkts = <l3;NumItems>        ! number of ckts                       Refg    71
          DO  L3=NumCkts,1,-1            ! highest to lowest rank ckt           Refg    72
            CALL RefgNetworkAlgs(Mode, <l3;List>)                               Refg    73
            IF (IwinReturn .eq. 1)  Return                                      Refg    74
          ENDDO                                                                 Refg    75
c                                                                               Refg    76
c              Simulate the suction group to get mass flow and                  Refg    77
c              discharge enthalpy                                               Refg    78
          IterNode = IterReqdNode(1, <sg;SubSysNodes>)                          Refg    79
          IF (IterNode  .OR.  IterReqdHsty(<sg;SubSysHstys>))  THEN             Refg    80
            CALL SuctionGroup(Mode, Jsg)                                        Refg    81
            IF (IwinReturn .eq. 1)  Return                                      Refg    82
          ENDIF                                                                 Refg    83
        ENDDO  ! L2                                                             Refg    84
c                                                                               Refg    85
c              Simulate the discharge circuits to establish mass flow,          Refg    86
c              enthalpy, and heat-recovery                                      Refg    87
        Kl2     = <rs;DischargeCkts>     ! list of discharge ckts               Refg    88
        NumCkts = <l2;NumItems>          ! number of ckts                       Refg    89
        DO  L2=NumCkts,1,-1              ! highest to lowest rank ckt           Refg    90
          CALL RefgNetworkAlgs(Mode, <l2;List>)                                 Refg    91
          IF (IwinReturn .eq. 1)  Return                                        Refg    92
        ENDDO                                                                   Refg    93
c                                                                               Refg    94
c              Simulate the refrigeration plant                                 Refg    95
        IterNode = IterReqdNode(1, <rs;SubSysNodes>)                            Refg    96
        IF (IterNode  .OR.  IterReqdHsty(<rs;SubSysHstys>))  THEN               Refg    97
          CALL RefgPlant(Mode, Jrs)                                             Refg    98
          IF (IwinReturn .eq. 1)  Return                                        Refg    99
        ENDIF                                                                   Refg   100
      ENDDO  ! LI=NumPlants                                                     Refg   101
c                                                                               Refg   102
c                                                                               Refg   103
c ================ PLANT TO LOADS ============================================= Refg   104
      CASE (32)                                                                 Refg   105
                                                                                Refg   106
c              Simulate each refrigeration plant from the condensers up         Refg   107
c              to the loads, starting with the lowest ranked plant              Refg   108
      DO  LI=1,NumPlants                                                        Refg   109
        Jrs = <li;List>                  ! pointer to the refg plant            Refg   110
c              Skip if nothing in the plant has changed                         Refg   111
        IterNode = IterReqdNode(0, <rs;SystemNodes>)                            Refg   112
        IF (.NOT. IterNode  .AND.                                               Refg   113
     &      .NOT. IterReqdHsty(<rs;SystemHstys>))  CYCLE                        Refg   114
c              Resimulate the plant if anything affecting its condensers        Refg   115
c              has changed                                                      Refg   116
        IterNode = IterReqdNode(1, <rs;SubSysNodes>)                            Refg   117
        IF (IterNode  .OR.  IterReqdHsty(<rs;SubSysHstys>))  THEN               Refg   118
          CALL RefgPlant(Mode, Jrs)                                             Refg   119
          IF (IwinReturn .eq. 1)  Return                                        Refg   120
        ENDIF                                                                   Refg   121
c                                                                               Refg   122
c              Simulate the discharge circuits to establish condensing          Refg   123
c              temperature, starting with the lowest ranked                     Refg   124
        Kl2     = <rs;DischargeCkts>     ! list of discharge ckts               Refg   125
        NumCkts = <l2;NumItems>          ! number of ckts                       Refg   126
        DO  L2=1,NumCkts                 ! lowest to highest rank ckt           Refg   127
          CALL RefgNetworkAlgs(Mode, <l2;List>)                                 Refg   128
          IF (IwinReturn .eq. 1)  Return                                        Refg   129
        ENDDO                                                                   Refg   130
c                                                                               Refg   131
c              Simulate each suction-group and its suction circuits,            Refg   132
c              starting with the lowest ranked suction group                    Refg   133
        Kl2   = <rs;SuctionGroups>       ! list of suction groups               Refg   134
        NumSG = <l2;NumItems>            ! number of suction groups             Refg   135
        DO  L2=1,NumSG                   ! lowest to highest rank group         Refg   136
          Jsg = <l2;List>                ! pointer to suction group             Refg   137
c              Skip if nothing in the suction group has changed                 Refg   138
          IterNode = IterReqdNode(0, <sg;SystemNodes>)                          Refg   139
          IF (.NOT. IterNode  .AND.                                             Refg   140
     &        .NOT. IterReqdHsty(<sg;SystemHstys>))  CYCLE                      Refg   141
c                                                                               Refg   142
c              Simulate the suction group to get suction pressure               Refg   143
          IterNode = IterReqdNode(0, <sg;SubSysNodes>)                          Refg   144
          IF (IterNode  .OR.  IterReqdHsty(<sg;SubSysHstys>))  THEN             Refg   145
            CALL SuctionGroup(Mode, Jsg)                                        Refg   146
            IF (IwinReturn .eq. 1)  Return                                      Refg   147
          ENDIF                                                                 Refg   148
c                                                                               Refg   149
c              Simulate the suction circuits to establish inlet suction         Refg   150
c              pressure, starting with the lowest ranked                        Refg   151
          Kl3     = <sg;SuctionCkts>     ! list of suction ckts                 Refg   152
          NumCkts = <l3;NumItems>        ! number of ckts                       Refg   153
          DO  L3=1,NumCkts               ! lowest to highest rank ckt           Refg   154
            CALL RefgNetworkAlgs(Mode, <l3;List>)                               Refg   155
            IF (IwinReturn .eq. 1)  Return                                      Refg   156
          ENDDO                                                                 Refg   157
        ENDDO  ! L2                                                             Refg   158
c                                                                               Refg   159
c              Simulate the plant's liquid circuits to establish outlet         Refg   160
c              temperature and pressure, starting with the lowest ranked        Refg   161
        Kl2     = <rs;LiquidCkts>        ! list of liquid ckts                  Refg   162
        NumCkts = <l2;NumItems>          ! number of ckts                       Refg   163
        DO  L2=1,NumCkts                 ! lowest to highest rank ckt           Refg   164
          CALL RefgNetworkAlgs(Mode, <l2;List>)                                 Refg   165
          IF (IwinReturn .eq. 1)  Return                                        Refg   166
        ENDDO                                                                   Refg   167
      ENDDO  ! LI=1,NumPlants                                                   Refg   168
c                                                                               Refg   169
      END SELECT  ! Mode                                                        Refg   170
c                                                                               Refg   171
      RETURN                                                                    Refg   172
      END                                                                       Refg   173
      SUBROUTINE RefgPlant(Mode, Jrs)                                           RfgPlt   2
c                                                                               RfgPlt   3
c              Simulates a refrigeration plant with heat-rejection              RfgPlt   4
c              equipment                                                        RfgPlt   5
c                                                                               RfgPlt   6
c              Mode =  10  Hourly initialization                                RfgPlt   7
c                      31  Hourly simulation                                    RfgPlt   8
c                      32  Hourly simulation                                    RfgPlt   9
c                      50  Report creation                                      RfgPlt  10
c                     111  Design                                               RfgPlt  11
c                     119  Design reconciliation                                RfgPlt  12
c                   201-9  Attachments                                          RfgPlt  13
c                                                                               RfgPlt  14
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /HRREP / Irb, Ihrp, Lrb, Lhrp, Nrb, Nhrp, IVTLIM(3,50),           HRr      1
     &                 IGRPtr, IBRPtr, IRSch, IRSchT(5),                        HRr      2
     &                 NHRTyp(3), ITBUF(3), ITBUFB(3), ITBUFE(3),               HRr      3
     &                 IHREOF, ICDFLG                                           HRr      4
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               RfgPlt  24
c ?? debug                                                                      RfgPlt  25
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
c                                                                               RfgPlt  27
      INTEGER r1, r2, r3, Mmixed, rH                                            RfgPlt  28
c                                                                               RfgPlt  29
c                    Nodes  Description                                         RfgPlt  30
c                    =====  =============================================       RfgPlt  31
c                     Kri  <--Refg inlet (discharge gas from compressors)       RfgPlt  32
c                       |                                                       RfgPlt  33
c                       |                                                       RfgPlt  34
c                       |                                                       RfgPlt  35
c                      r1                                                       RfgPlt  36
c                       |                                                       RfgPlt  37
c                       |  <--Condensers in parallel                            RfgPlt  38
c                       |                                                       RfgPlt  39
c                      r2                                                       RfgPlt  40
c                       |                                                       RfgPlt  41
c                       |  <--Return from hot-gas bypass                        RfgPlt  42
c                       |             and liquid overfeed (future)              RfgPlt  43
c                      r3                                                       RfgPlt  44
c                       |                                                       RfgPlt  45
c                       |  <--Liquid pump, if specified (future)                RfgPlt  46
c                       |                                                       RfgPlt  47
c                     Kro  <--Refg outlet (liquid to circuits)                  RfgPlt  48
c                                                                               RfgPlt  49
c                Plant               Plant Equip                                RfgPlt  50
c               CtrlMode              EquipMode                                 RfgPlt  51
c             ============       ======================================         RfgPlt  52
c             0  Offmode         30  Off simulation                             RfgPlt  53
c             5  CoolMode        25  Cooling capacity                           RfgPlt  54
c                                31  Cooling simulation, loads to plant         RfgPlt  55
c                                32  Cooling simulation, plant to loads         RfgPlt  56
c                                                                               RfgPlt  57
      Jre = <rs:REFRIGERANT>             ! refrigerant                          RfgPlt  58
      Kri = <rs;InletNode>               ! inlet node                           RfgPlt  59
      r1  = <rs;Node1>                   ! to condensers                        RfgPlt  60
      r2  = <rs;Node2>                   ! from condensers                      RfgPlt  61
      r3  = <rs;Node3>                   ! liquid return                        RfgPlt  62
      Jpm = <rs:LIQUID-PUMP>             ! pump, if any                         RfgPlt  63
      Kro = <rs;OutletNode>              ! outlet node                          RfgPlt  64
c                                                                               RfgPlt  65
      SELECT CASE (Mode)                                                        RfgPlt  66
c                                                                               RfgPlt  67
c                                                                               RfgPlt  68
c ============ HOURLY INITIALIZATION ========================================== RfgPlt  69
      CASE (10)                                                                 RfgPlt  70
c                                                                               RfgPlt  71
c              default EQUIP-CTRL sequences                                     RfgPlt  72
      <rs.EquipCtrl>    = <rs:EQUIP-CTRL>                                       RfgPlt  73
      <rs.CtrlPriority> = 0.                                                    RfgPlt  74
      <rs.OverPriority> = 0                                                     RfgPlt  75
      <rs.CtrlOverride> = -88888                                                RfgPlt  76
c                                                                               RfgPlt  77
c              Initialize setpoint for use in allocating loads                  RfgPlt  78
c              to condensers                                                    RfgPlt  79
      SELECT CASE (<rs:SCT-CTRL>)                                               RfgPlt  80
        CASE (1)  ! Fixed                                                       RfgPlt  81
          <rs.Tsetpt> = <rs:SCT-SETPT>                                          RfgPlt  82
        CASE (2)  ! Scheduled                                                   RfgPlt  83
          <rs.Tsetpt> = SchVal(<rs:SCT-SETPT-SCH>)                              RfgPlt  84
        CASE (3)  ! OA reset sch                                                RfgPlt  85
          <rs.Tsetpt> = DrsVal(<rs:SCT-RESET-SCH>)                              RfgPlt  86
        CASE (4)  ! Drybulb reset                                               RfgPlt  87
          <rs.Tsetpt> = DBT + <rs:SCT-AMBIENT-T>                                RfgPlt  88
        CASE (5)  ! Wetbulb reset                                               RfgPlt  89
          <rs.Tsetpt> = WBT + <rs:SCT-AMBIENT-T>                                RfgPlt  90
     &                + (<rs:DESIGN-WETBUL>-WBT) * <rs:WETBULB-RATIO>           RfgPlt  91
        CASE DEFAULT                                                            RfgPlt  92
          <rs.Tsetpt> = <rs:DESIGN-SCT>                                         RfgPlt  93
      END SELECT  ! rs:SCT-CTRL                                                 RfgPlt  94
c              Setpoint limits                                                  RfgPlt  95
      IF (<rs:OVERRIDE-MAX> .NE. 0.)                                            RfgPlt  96
     &  <rs.Tsetpt> = MIN(<rs.Tsetpt>, <rs:OVERRIDE-MAX>)                       RfgPlt  97
      IF (<rs:OVERRIDE-MIN> .NE. 0.)                                            RfgPlt  98
     &  <rs.Tsetpt> = MAX(<rs.Tsetpt>, <rs:OVERRIDE-MIN>)                       RfgPlt  99
c                                                                               RfgPlt 100
c                                                                               RfgPlt 101
c ============ HOURLY SIMULATION ============================================== RfgPlt 102
      CASE (31,32)                                                              RfgPlt 103
c                                                                               RfgPlt 104
      CALL ZeroAA(<#rs~HrZeroStart..>, <#rs~HrZeroEnd....>)                     RfgPlt 105
c                                                                               RfgPlt 106
c              Inlet conditions                                                 RfgPlt 107
      CALL RefgNode(Kri, <ri.Minlet>,xMreqd, <ri.Hinlet>, xTreqd,               RfgPlt 108
     &                   xPmin,xPmax, xPminReqd,<ri.Preqd>)                     RfgPlt 109
      <ri.Tinlet> = RefgT_fPH(Jre, <ri.Pinlet>, <ri.Hinlet>)                    RfgPlt 110
      <ri.Qinlet> = <ri.Minlet> * (<ri.Hinlet>-<ro.Houtlet>)                    RfgPlt 111
c              outlet conditions                                                RfgPlt 112
      CALL RefgNode(Kro, <ro.Moutlet>,<ro.Mreqd>, xH, <ro.Treqd>,               RfgPlt 113
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     RfgPlt 114
c                                                                               RfgPlt 115
c              Heat rejection load                                              RfgPlt 116
      IF (Mode .EQ. 31)                                                         RfgPlt 117
     &  <rs.Qrej> = <ro.Moutlet> * (<ri.Hinlet>-<ro.Houtlet>)                   RfgPlt 118
c                                                                               RfgPlt 119
c              Adjust required outlet pressure for pump                         RfgPlt 120
c              (not implemented)                                                RfgPlt 121
      IF (<rs:LIQUID-PUMP> .EQ. 0)  THEN                                        RfgPlt 122
        <r3.Preqd> = <ro.Preqd>                                                 RfgPlt 123
      ELSE                                                                      RfgPlt 124
      ENDIF                                                                     RfgPlt 125
                                                                                RfgPlt 126
c              Node 1                                                           RfgPlt 127
      <r1.Mrefg>   = <ri.Minlet>                                                RfgPlt 128
      <r1.Hrefg>   = <ri.Hinlet>                                                RfgPlt 129
      <r1.Preqd>   = <ri.Preqd>                                                 RfgPlt 130
      <r1.RunFrac> = <ri.RunFrac>                                               RfgPlt 131
                                                                                RfgPlt 132
c              Node 2 - Heat rejection equipment                                RfgPlt 133
      <r2.Preqd> = <r3.Preqd>                                                   RfgPlt 134
                                                                                RfgPlt 135
c              Check if heat-reclaim override is active                         RfgPlt 136
      <rs.HtRecSetpt> = -88888.                                                 RfgPlt 137
      SELECT CASE (<rs:HTREC-CTRL>)                                             RfgPlt 138
        CASE (0)  ! No heat-reclaim override                                    RfgPlt 139
        CASE (1)  ! On/off trigger                       ?? NOT DEBUGGED        RfgPlt 140
          IF (<r1.Preqd> .GT. -888.)                                            RfgPlt 141
     &      <rs.HtRecSetpt> = <rs:HTREC-SETPT>                                  RfgPlt 142
        CASE (2)  ! Scheduled                            ?? NOT DEBUGGED        RfgPlt 143
          SchV = SchVal(<rs:HTREC-SCH>)                                         RfgPlt 144
          IF (SchV .NE. 1.  .AND.  DBT .GT. SchV)  SchV = 0.                    RfgPlt 145
          IF (SchV .NE. 0.)  <rs.HtRecSetpt> = <rs:HTREC-SETPT>                 RfgPlt 146
        CASE (3)  ! Load reset                           ?? NOT DEBUGGED        RfgPlt 147
          IF (<r1.Preqd> .GT. -888.)  THEN                                      RfgPlt 148
            <rs.HtRecSetpt> = RefgT_fP(Jre,<r1.Preqd>) + <rs;Throttle/2>        RfgPlt 149
            IF (<rs:MAX-HTREC-T> .GT. 0.)                                       RfgPlt 150
     &        <rs.HtRecSetpt> = MIN(<rs:MAX-HTREC-T>, <rs.HtRecSetpt>)          RfgPlt 151
          ENDIF                                                                 RfgPlt 152
      END SELECT  ! rs:HTREC-CTRL                                               RfgPlt 153
                                                                                RfgPlt 154
c              Node 2 setpoint                                                  RfgPlt 155
      <r2.Tsetpt> = MAX(<rs.HtRecSetpt>, <rs.Tsetpt>)                           RfgPlt 156
c              override if any compressor requires SDT-SST differential         RfgPlt 157
      IF (<r1.Preqd> .GT. -888.) THEN                                           RfgPlt 158
        Treqd       = RefgT_fP(Jre, <r1.Preqd>)                                 RfgPlt 159
        <r2.Tsetpt> = Max(<r2.Tsetpt>, Treqd)                                   RfgPlt 160
      ENDIF                                                                     RfgPlt 161
                                                                                RfgPlt 162
c              Skip if no condensers                                            RfgPlt 163
      IF (<r2;Xnode> .EQ. 0)  THEN                                              RfgPlt 164
        <r2.Trefg> = <r2.Tsetpt>                                                RfgPlt 165
        <r2.Prefg> = RefgP_fT(Jre, <r2.Tsetpt>)                                 RfgPlt 166
        <r2.Hrefg> = RefgH_Liquid_fTP(Jre, <r2.Trefg>, <r2.Prefg>)              RfgPlt 167
        GOTO 3118                                                               RfgPlt 168
      ELSE                                                                      RfgPlt 169
        Kli        = <r2;Xnode>                                                 RfgPlt 170
        NumCond    = <li;NumItems>                                              RfgPlt 171
      ENDIF                                                                     RfgPlt 172
c              Skip if no flow required                                         RfgPlt 173
      IF (<r1.Mrefg> .EQ. 0.)  THEN                                             RfgPlt 174
        DO  LI=1,NumCond                                                        RfgPlt 175
          Krx          = <li;List>                                              RfgPlt 176
          <rx.Mrefg>   = 0.                                                     RfgPlt 177
          <rx.RunFrac> = 0.                                                     RfgPlt 178
          CALL CondenserAlgs(Mode, Krx)                                         RfgPlt 179
        ENDDO                                                                   RfgPlt 180
c              Set Node 2 temperature                                           RfgPlt 181
        <r2.Trefg> = <r2.Tsetpt> - <rs;Throttle/2>                              RfgPlt 182
        <r2.Trefg> = MAX(Tmin, <r2.Trefg>)                                      RfgPlt 183
        <r2.Prefg> = RefgP_fT(Jre, <r2.Trefg>)                                  RfgPlt 184
        GOTO 3118                                                               RfgPlt 185
      ENDIF  ! ro,Mreqd                                                         RfgPlt 186
c                                                                               RfgPlt 187
c              Get condenser capacity at setpoint                               RfgPlt 188
      DO  LI=1,NumCond                                                          RfgPlt 189
        CALL CondenserAlgs(25, <li;List>)                                       RfgPlt 190
      ENDDO                                                                     RfgPlt 191
c              Condenser mix at setpoint                                        RfgPlt 192
      IF (<rs.EquipCtrl> .GT. 0)  THEN                                          RfgPlt 193
c              Allocate using user-specified control sequence                   RfgPlt 194
        CALL Refg_EquipCtrl(<rs.EquipCtrl>, <rs.EquipCtrlLast>,                 RfgPlt 195
     &                             Kli, <r1.Mrefg>, <r1.RunFrac>, xx,yy)        RfgPlt 196
      ELSE  ! default allocation                                                RfgPlt 197
        CALL Refg_EquipCtrlDefault(Kli, <r1.Mrefg>, <r1.RunFrac>, xx,yy)        RfgPlt 198
      ENDIF                                                                     RfgPlt 199
      <rs.EquipCtrlLast> = <rs.EquipCtrl>                                       RfgPlt 200
c              Simulate condensers                                              RfgPlt 201
      DO  LI=1,NumCond                                                          RfgPlt 202
        CALL CondenserAlgs(Mode, <li;List>)                                     RfgPlt 203
      ENDDO                                                                     RfgPlt 204
c              Get Node 2 conditions (outlet of condensers)                     RfgPlt 205
      CALL RefgNode(r2, <r2.Mrefg>,xMreqd, <r2.Hrefg>, xTreqd,                  RfgPlt 206
     &                  xPmin,<r2.Prefg>, xPminReqd,xPmaxReqd)                  RfgPlt 207
c              The RunFrac is the same as node 1                                RfgPlt 208
      <r2.RunFrac> = <r1.RunFrac>                                               RfgPlt 209
c                                                                               RfgPlt 210
c              Pressure at node 1 and inlet                                     RfgPlt 211
      CALL RefgNode(r1, xM,xMreqd, xH, xTreqd,                                  RfgPlt 212
     &                  xPmin,<r1.Prefg>, xPminReqd,xPmaxReqd)                  RfgPlt 213
      <ri.Pinlet> = <r1.Prefg>                                                  RfgPlt 214
                                                                                RfgPlt 215
                                                                                RfgPlt 216
c              Adjust for back-flooding control                                 RfgPlt 217
      dPcond = <r1.Prefg> - <r2.Prefg>                                          RfgPlt 218
      IF (<rs:BACKFLOOD-CTR> .GT. 0)  THEN                                      RfgPlt 219
        IF (<rs:BACKFLOOD-CTR> .EQ. 1)  THEN       ! fixed                      RfgPlt 220
          Tflood = <rs:BACKFLOOD-SET>                                           RfgPlt 221
        ELSE                                       ! max-reqd                   RfgPlt 222
          Tflood = RefgT_fP(Jre, <r2.Preqd>)                                    RfgPlt 223
          Tflood = MAX(Tflood, <rs:BACKFLOOD-SET>,                              RfgPlt 224
     &                         <rs.HtRecSetpt>-<rs;Throttle/2>)                 RfgPlt 225
        ENDIF                                                                   RfgPlt 226
        SCT = RefgT_fP(Jre, <r2.Prefg>)            ! liquid SCT                 RfgPlt 227
        IF (Tflood .GT. SCT)  THEN                                              RfgPlt 228
c              Hot gas is bypassed to maintain SCT                              RfgPlt 229
          <r2.Prefg>  = RefgP_fT(Jre, Tflood)                                   RfgPlt 230
          <r1.Prefg>  = <r2.Prefg> + dPcond                                     RfgPlt 231
          <ri.Pinlet> = <r1.Prefg>                                              RfgPlt 232
          IF (<rs:BACKFLOOD-SUB> .GT. 0.)  THEN                                 RfgPlt 233
c              Backflooding is configured for ambient subcooling.               RfgPlt 234
c              Hot gas injects into top of receiver tank, acting as             RfgPlt 235
c              a "spring" without significantly heating the liquid.             RfgPlt 236
c              Do not allow subcooling to exceed the setpoint.                  RfgPlt 237
            Tmin  = Tflood - <rs:BACKFLOOD-SUB>                                 RfgPlt 238
            Trefg = RefgT_fPH(Jre, <r2.Prefg>, <r2.Hrefg>)                      RfgPlt 239
            IF (Trefg .LT. Tmin)                                                RfgPlt 240
     &        <r2.Hrefg> = RefgH_fTP(Jre, Tmin, <r2.Prefg>, 1)                  RfgPlt 241
          ELSE                                                                  RfgPlt 242
c              No ambient subcooling - Hot gas injects directly into            RfgPlt 243
c              liquid, saturating the refrigerant at backflood setpoint         RfgPlt 244
            <r2.Hrefg> = RefgH_Liquid_fT(Jre, Tflood)                           RfgPlt 245
          ENDIF  ! rs:BACKFLOOD-SUB                                             RfgPlt 246
        ENDIF  ! Tflood                                                         RfgPlt 247
      ENDIF  ! rs:BACKFLOOD-CTRL                                                RfgPlt 248
c                                                                               RfgPlt 249
c              Reentry point for no condensers or no flow                       RfgPlt 250
 3118 CONTINUE                                                                  RfgPlt 251
c                                                                               RfgPlt 252
c              Return from hot-gas bypass  (implemented)                        RfgPlt 253
c              and liquid overfeed systems (not implemented)                    RfgPlt 254
      CALL RefgNode(r3, <r3.Mrefg>,xMreqd, <r3.Hrefg>, xTreqd,                  RfgPlt 255
     &                   xPmin,xPmax, xPminReqd,xPmaxReqd)                      RfgPlt 256
      IF (<r3.Mrefg> .GT. 0.)  THEN                                             RfgPlt 257
c              mixed condition                                                  RfgPlt 258
        Mmixed     = <r2.Mrefg> + <r3.Mrefg>                                    RfgPlt 259
        <r3.Hrefg> = (<r2.Mrefg>*<r2.Hrefg> + <r3.Mrefg>*<r3.Hrefg>)            RfgPlt 260
     &                                                          / Mmixed        RfgPlt 261
        <r3.Mrefg> = Mmixed                                                     RfgPlt 262
      ELSE                                                                      RfgPlt 263
        <r3.Hrefg> = <r2.Hrefg>                                                 RfgPlt 264
        <r3.Mrefg> = <r2.Mrefg>                                                 RfgPlt 265
      ENDIF                                                                     RfgPlt 266
      <r3.Prefg> = <r2.Prefg>                                                   RfgPlt 267
c                                                                               RfgPlt 268
c              Pressurization due to liquid pump                                RfgPlt 269
c              (not implemented)                                                RfgPlt 270
      IF (<rs:LIQUID-PUMP> .EQ. 0)  THEN                                        RfgPlt 271
        <ro.Poutlet> = <r3.Prefg>                                               RfgPlt 272
        <ro.Houtlet> = <r3.Hrefg>                                               RfgPlt 273
      ELSE                                                                      RfgPlt 274
      ENDIF                                                                     RfgPlt 275
c                                                                               RfgPlt 276
c              Shut down if temperature exceeds alarm T's                       RfgPlt 277
      SCT = RefgT_fP(Jre, <ro.Poutlet>)                                         RfgPlt 278
      IF (SCT .GT. <rs:ALARM-MAX-T>)  THEN                                      RfgPlt 279
        CALL MSGSIM(-1,II,II,II,II)                                             RfgPlt 280
        WRITE (IOUTPT, 9101) (<rs:NAME>,II=1,8), <rs:ALARM-MAX-T>               RfgPlt 281
        CALL MessageBox( NULL,                                                  RfgPlt 282
     &   'Maximum condensing temperature exceeded'//char(10)//char(13)//        RfgPlt 283
     &   ' - safety has shut down system'//char(0),                             RfgPlt 284
     &   'REFG-SYSTEM Errors'//char(0),                                         RfgPlt 285
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  RfgPlt 286
          IwinReturn = 1                                                        RfgPlt 287
      ELSEIF (SCT .LT. <rs:ALARM-MIN-T>)  THEN                                  RfgPlt 288
        CALL MSGSIM(-1,II,II,II,II)                                             RfgPlt 289
        WRITE (IOUTPT, 9102) (<rs:NAME>,II=1,8), <rs:ALARM-MIN-T>               RfgPlt 290
        CALL MessageBox( NULL,                                                  RfgPlt 291
     &   'Minimum condensing temperature exceeded'//char(10)//char(13)//        RfgPlt 292
     &   ' - safety has shut down system'//char(0),                             RfgPlt 293
     &   'REFG-SYSTEM Errors'//char(0),                                         RfgPlt 294
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  RfgPlt 295
          IwinReturn = 1                                                        RfgPlt 296
      ENDIF                                                                     RfgPlt 297
c                                                                               RfgPlt 298
c              Auxiliary power                                                  RfgPlt 299
      IF (<rs:AUX-KW> .GT. 0.)  THEN                                            RfgPlt 300
        SELECT CASE (<rs:AUX-MODE>)                                             RfgPlt 301
          CASE (1)  ! Always                                                    RfgPlt 302
            AuxKWh = <rs:AUX-KW>                                                RfgPlt 303
          CASE (2)  ! When on                                                   RfgPlt 304
            IF (<ri.Minlet> .GT. 0)  THEN                                       RfgPlt 305
              AuxKWh = <rs:AUX-KW> * <ri.RunFrac>                               RfgPlt 306
            ELSE                                                                RfgPlt 307
              AuxKWh = 0.                                                       RfgPlt 308
            ENDIF                                                               RfgPlt 309
          CASE (3)  ! When off                                                  RfgPlt 310
            IF (<ri.Minlet> .EQ. 0)  THEN                                       RfgPlt 311
              AuxKWh = <rs:AUX-KW> * (1.-<ri.RunFrac>)                          RfgPlt 312
            ELSE                                                                RfgPlt 313
              AuxKWh = 0.                                                       RfgPlt 314
            ENDIF                                                               RfgPlt 315
          CASE (4)  ! Scheduled                                                 RfgPlt 316
            AuxKWh = <rs:AUX-KW> * SchVal(<rs:AUX-SCH>)                         RfgPlt 317
        END SELECT                                                              RfgPlt 318
        Kmd = <rs:AUX-METER>                                                    RfgPlt 319
        Kmx = <md;Xnode>                                                        RfgPlt 320
        IF (AuxKWh .GT. 0.)  THEN                                               RfgPlt 321
          IF (ABS(1. - <md.Elec>/AuxKWh) .GT. <sp:ERROR-LOAD>)                  RfgPlt 322
     &      <mx.IterFlag> = Jrs                                                 RfgPlt 323
        ELSE                                                                    RfgPlt 324
          IF (<md.Elec> .GT. 0.)  <mx.IterFlag> = Jrs                           RfgPlt 325
        ENDIF                                                                   RfgPlt 326
        <md.Elec> = AuxKWh                                                      RfgPlt 327
      ENDIF                                                                     RfgPlt 328
c                                                                               RfgPlt 329
c              Set iteration flags on attached fluid circuits                   RfgPlt 330
      IF (Mode .EQ. 32)  THEN                                                   RfgPlt 331
        CALL CnvgCheck(1, <rs;RefgHsty>)  ! Plant to Loads                      RfgPlt 332
      ELSE                                                                      RfgPlt 333
        CALL CnvgCheck(0, <rs;RefgHsty>)  ! Loads to Plant                      RfgPlt 334
      ENDIF                                                                     RfgPlt 335
c                                                                               RfgPlt 336
c                                                                               RfgPlt 337
c ============ REPORT CREATION ================================================ RfgPlt 338
      CASE (50)                                                                 RfgPlt 339
c                                                                               RfgPlt 340
c              statistics blocks                                                RfgPlt 341
      Ks2Sup      = NewStat2(Kro, <+ri.Minlet>, 0, 1.)                          RfgPlt 342
      Ks5SupBin   = NewStat5(Kro, <+ri.Minlet>, 0, 1.)                          RfgPlt 343
      Ks2HtRej    = NewStat2(Jrs,   <+rs.Qrej>, 0, 1.)                          RfgPlt 344
      Ks2HtRejBin = NewStat5(Jrs,   <+rs.Qrej>, 0, 1.)                          RfgPlt 345
      Ks2Elec     = NewStat2(<rs;SysKWnodes>, <+mx.Load>, 0, -1.)               RfgPlt 346
      Ks2ElecBin  = NewStat5(<rs;SysKWnodes>, <+mx.Load>, 0, -1.)               RfgPlt 347
c                                                                               RfgPlt 348
c              Create the type "H" report                                       RfgPlt 349
      IF (<rs:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      RfgPlt 350
     &  <rs;PS-H> = NewReport_H(Jrs, 140,                                       RfgPlt 351
     &                          4, 5, 6,                                        RfgPlt 352
     &                          Ks2Sup, Ks2HtRej, Ks2Elec, 0,                   RfgPlt 353
     &                          Ks5SupBin, Ks2HtRejBin, Ks2ElecBin,             RfgPlt 354
     &                          0, 0, 0)                                        RfgPlt 355
c                                                                               RfgPlt 356
c                                                                               RfgPlt 357
c ============ REPORT ORDER =================================================== RfgPlt 358
      CASE (52)                                                                 RfgPlt 359
c                                                                               RfgPlt 360
      Call Report_H(Mode, <rs;PS-H>)                                            RfgPlt 361
c              Condensers                                                       RfgPlt 362
      IF (<r2;Xnode> .ne. 0)  THEN                                              RfgPlt 363
        Kli = <r2;Xnode>                                                        RfgPlt 364
        DO  LI=1,<li;NumItems>                                                  RfgPlt 365
          CALL CondenserAlgs(Mode, <li;List>)                                   RfgPlt 366
        ENDDO                                                                   RfgPlt 367
      ENDIF                                                                     RfgPlt 368
c                                                                               RfgPlt 369
c                                                                               RfgPlt 370
c ============ REPORTS - VERIFICATION DATA ==================================== RfgPlt 371
      CASE (54)                                                                 RfgPlt 372
c                                                                               RfgPlt 373
c              Output design information                                        RfgPlt 374
      IF (<rs;PS-H> .ne. 0)  THEN                                               RfgPlt 375
        rH = <rs;PS-H>                                                          RfgPlt 376
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       RfgPlt 377
        CALL GetAttachments(Jrs, 2)                                             RfgPlt 378
        WRITE (IREPFL)  21,<rH;Iuniq>,1,2,17,                                   RfgPlt 379
     &    (NameAttachments(II,1,1),II=1,8),                                     RfgPlt 380
     &    (NameAttachments(II,1,2),II=1,8),                                     RfgPlt 381
     &    <ri.Minlet>                                                           RfgPlt 382
        DO  Irow=2,NumRowsOfAttachments                                         RfgPlt 383
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 RfgPlt 384
     &      (NameAttachments(II,Irow,1),II=1,8),                                RfgPlt 385
     &      (NameAttachments(II,Irow,2),II=1,8)                                 RfgPlt 386
        ENDDO                                                                   RfgPlt 387
      ENDIF                                                                     RfgPlt 388
c                                                                               RfgPlt 389
c                                                                               RfgPlt 390
c ============ HOURLY REPORTS - HOURLY DATA =================================== RfgPlt 391
      CASE (62)                                                                 RfgPlt 392
c                                                                               RfgPlt 393
      IF (<rs;HourRepBuf> .EQ. 0)  RETURN                                       RfgPlt 394
c                                                                               RfgPlt 395
      IAptr = <rs;HourRepBuf> - 1                                               RfgPlt 396
c                                                                               RfgPlt 397
      AA(IAptr+1)  = <rs.Qrej>                                                  RfgPlt 398
      AA(IAptr+2)  = SumList(<rs;SysKWnodes>, <+mx.Load>, -1.)                  RfgPlt 399
      AA(IAptr+3)  = <ri.Minlet>                                                RfgPlt 400
      AA(IAptr+4)  = <ri.Tinlet>                                                RfgPlt 401
      AA(IAptr+5)  = <ri.Pinlet>                                                RfgPlt 402
      AA(IAptr+6)  = <ri.Hinlet>                                                RfgPlt 403
      AA(IAptr+7)  = <ri.Minlet>                                                RfgPlt 404
      AA(IAptr+8)  = RefgT_fPH(Jre, <ro.Poutlet>, <ro.Houtlet>)                 RfgPlt 405
      AA(IAptr+9)  = RefgT_fP(Jre, <ro.Poutlet>)                                RfgPlt 406
      AA(IAptr+10) = <ro.Poutlet>                                               RfgPlt 407
      AA(IAptr+11) = <ro.Houtlet>                                               RfgPlt 408
      AA(IAptr+12) = <r2.Tsetpt>                                                RfgPlt 409
c                                                                               RfgPlt 410
c                                                                               RfgPlt 411
c ============ DESIGN CALCULATIONS - INITIALIZATION =========================== RfgPlt 412
      CASE (110)                                                                RfgPlt 413
c                                                                               RfgPlt 414
c              Design conditions                                                RfgPlt 415
      <ro.Poutlet> = RefgP_fT(Jre, <rs:DESIGN-SCT>)                             RfgPlt 416
      dTsubcool    = (<rs:DESIGN-SCT>-<rs:DESIGN-WETBUL>)                       RfgPlt 417
     &                                                * <rs:SUBCOOL-EFF>        RfgPlt 418
      <ro.Toutlet> = <rs:DESIGN-SCT> - dTsubcool                                RfgPlt 419
      <ro.Houtlet> = RefgH_Liquid_fTP(Jre, <ro.Toutlet>, <ro.Poutlet>)          RfgPlt 420
      <ri.Pinlet>  = <ro.Poutlet>                                               RfgPlt 421
c                                                                               RfgPlt 422
c              Auxiliary power                                                  RfgPlt 423
      IF (<rs:AUX-METER> .GT. 0.)  THEN                                         RfgPlt 424
        Kmd       = <rs:AUX-METER>                                              RfgPlt 425
        <md.Elec> = <rs:AUX-KW>                                                 RfgPlt 426
      ENDIF                                                                     RfgPlt 427
c                                                                               RfgPlt 428
      <rs;Throttle/2> = <rs:SCT-THROTTLE> / 2.                                  RfgPlt 429
c                                                                               RfgPlt 430
c                                                                               RfgPlt 431
c ============ DESIGN CALCULATIONS - ITERATIVE ================================ RfgPlt 432
      CASE (111)                                                                RfgPlt 433
c                                                                               RfgPlt 434
c              Get the supply and return circuit conditions                     RfgPlt 435
      CALL RefgNode(Kri, <ri.Minlet>,xMreqd, <ri.Hinlet>, xTreqd,               RfgPlt 436
     &                   xPmin,xPmax, xPminReqd,xPmaxReqd)                      RfgPlt 437
c              Outlet conditions                                                RfgPlt 438
      CALL RefgNode(Kro, <ro.Moutlet>,xMreqd, xH, <ro.Treqd>,                   RfgPlt 439
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     RfgPlt 440
c                                                                               RfgPlt 441
c              Skip if no mass flow to work with ??                             RfgPlt 442
      IF (<ri.Minlet> .EQ. 0.)  RETURN                                          RfgPlt 443
c                                                                               RfgPlt 444
c              Adjust required outlet pressure for pump                         RfgPlt 445
c              (not implemented)                                                RfgPlt 446
      IF (<rs:LIQUID-PUMP> .EQ. 0)  THEN                                        RfgPlt 447
        <r3.Preqd> = <ro.Preqd>                                                 RfgPlt 448
      ELSE                                                                      RfgPlt 449
      ENDIF                                                                     RfgPlt 450
c                                                                               RfgPlt 451
c              Node 2 - Heat rejection equipment                                RfgPlt 452
      <r1.Mrefg>  = <ri.Minlet>                                                 RfgPlt 453
      <r1.Hrefg>  = <ri.Hinlet>                                                 RfgPlt 454
      <r2.Mrefg>  = <ri.Minlet>                                                 RfgPlt 455
      <r2.Tsetpt> = <rs:DESIGN-SCT>                                             RfgPlt 456
c              Design the condensers                                            RfgPlt 457
      IF (<r2;Xnode> .GT. 0)  THEN                                              RfgPlt 458
        Kli      = <r2;Xnode>                                                   RfgPlt 459
        NumCond  = <li;NumItems>                                                RfgPlt 460
        DO  LI=1,NumCond                                                        RfgPlt 461
          CALL CondenserAlgs(Mode, <li;List>)                                   RfgPlt 462
        ENDDO                                                                   RfgPlt 463
c              Get Node 2 conditions (outlet of condensers)                     RfgPlt 464
        CALL RefgNode(r2, xM,xMreqd, <r2.Hrefg>, xTreqd,                        RfgPlt 465
     &                    xPmin,<r2.Prefg>, xPminReqd,xPmaxReqd)                RfgPlt 466
c              get Node 1 pressure (inlet to condensers)                        RfgPlt 467
        CALL RefgNode(r1, xM,xMreqd, xH, xTreqd,                                RfgPlt 468
     &                    xPmin,<r1.Prefg>, xPminReqd,xPmaxReqd)                RfgPlt 469
        <ri.Pinlet> = <r1.Prefg>                                                RfgPlt 470
      ELSE                                                                      RfgPlt 471
c              no condensers                                                    RfgPlt 472
        <r2.Prefg> = RefgP_fT(Jre, <rs:DESIGN-SCT>)                             RfgPlt 473
        dTsubcool  = (<rs:DESIGN-SCT>-<rs:DESIGN-WETBUL>)                       RfgPlt 474
     &                                             * <rs:SUBCOOL-EFF>           RfgPlt 475
        dTsubcool  = MAX(0., dTsubcool)                                         RfgPlt 476
        <r2.Trefg> = <rs:DESIGN-SCT> - dTsubcool                                RfgPlt 477
        <r2.Hrefg> = RefgH_Liquid_fTP(Jre, <ro.Toutlet>, <r2.Prefg>)            RfgPlt 478
      ENDIF                                                                     RfgPlt 479
c                                                                               RfgPlt 480
c              Return from liquid overfeed systems                              RfgPlt 481
c              (not implemented)                                                RfgPlt 482
      <r3.Prefg> = <r2.Prefg>                                                   RfgPlt 483
      <r3.Hrefg> = <r2.Hrefg>                                                   RfgPlt 484
c                                                                               RfgPlt 485
c              Pressurization due to liquid pump                                RfgPlt 486
c              (not implemented)                                                RfgPlt 487
      IF (<rs:LIQUID-PUMP> .EQ. 0)  THEN                                        RfgPlt 488
        <ro.Poutlet> = <r3.Prefg>                                               RfgPlt 489
        <ro.Houtlet> = <r3.Hrefg>                                               RfgPlt 490
      ELSE                                                                      RfgPlt 491
      ENDIF                                                                     RfgPlt 492
c                                                                               RfgPlt 493
      <rs.Qrej> = <ro.Moutlet> * (<ri.Hinlet> - <ro.Houtlet>)                   RfgPlt 494
c                                                                               RfgPlt 495
c                                                                               RfgPlt 496
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== RfgPlt 497
      CASE (119)                                                                RfgPlt 498
c                                                                               RfgPlt 499
c              Check if condenser capacity is sufficient                        RfgPlt 500
      CALL RefgNode(r2, <r2.Mrefg>,xMreqd, xH, xTreqd,                          RfgPlt 501
     &                  xPmin,xPmax, xPminReqd,xPmaxReqd)                       RfgPlt 502
      IF (<r2;Xnode>  .GT. 0  .AND.                                             RfgPlt 503
     &    <ri.Minlet> .GT. <r2.Mrefg>*1.01)  THEN                               RfgPlt 504
        CALL MSGSIM(-2,II,II,II,II)                                             RfgPlt 505
        WRITE (IOUTPT,9004)  (<rs:NAME>,II=1,8),                                RfgPlt 506
     &                        <ri.Minlet>, <r2.Mrefg>                           RfgPlt 507
      ENDIF                                                                     RfgPlt 508
c              Check if design SCT is reasonable                                RfgPlt 509
      SCTreqd = RefgT_fP(Jre, <ro.Preqd>)                                       RfgPlt 510
      IF (SCTreqd .gt. <rs:DESIGN-SCT>+1.)  THEN                                RfgPlt 511
        CALL MSGSIM(-3,II,II,II,II)                                             RfgPlt 512
        WRITE (IOUTPT, 9005) (<rs:NAME>,II=1,8),                                RfgPlt 513
     &                        SCTreqd, <rs:DESIGN-SCT>                          RfgPlt 514
      ENDIF                                                                     RfgPlt 515
      <rs.Tsetpt> = <rs:DESIGN-SCT>                                             RfgPlt 516
c              Update iteration error limits                                    RfgPlt 517
      ErrorP = RefgP_fT(Jre, <rs:DESIGN-SCT>)                                   RfgPlt 518
     &       - RefgP_fT(Jre, <rs:DESIGN-SCT>-0.5)                               RfgPlt 519
      CALL HstyError(<rs;RefgHsty>, <#ro.Poutlet>, ErrorP)                      RfgPlt 520
      CALL HstyError(<rs;RefgHsty>, <#ri.Pinlet>, ErrorP)                       RfgPlt 521
c                                                                               RfgPlt 522
c                                                                               RfgPlt 523
c ============ ATTACHMENTS ==================================================== RfgPlt 524
c                                                                               RfgPlt 525
c              Initial attachments                                              RfgPlt 526
      CASE (201)                                                                RfgPlt 527
c                                                                               RfgPlt 528
c              Component pointers, schedules, and curves                        RfgPlt 529
        <rs:REFRIGERANT>   = Jcomponent(20, <rs:REFRIGERANT>)                   RfgPlt 530
        <rs:LIQUID-PUMP>   = Jcomponent( 1, <rs:LIQUID-PUMP>)                   RfgPlt 531
        <rs:EQUIP-CTRL>    = Jcomponent(11, <rs:EQUIP-CTRL>)                    RfgPlt 532
        <rs:ELEC-METER>    = Jcomponent(13, <rs:ELEC-METER>)                    RfgPlt 533
        <rs:AUX-METER>     = Jcomponent(13, <rs:AUX-METER>)                     RfgPlt 534
        <rs:COST-DATA>     = Jcomponent(18, <rs:COST-DATA>)                     RfgPlt 535
        <rs:SCT-SETPT-SCH> = Jsched(<rs:SCT-SETPT-SCH>)                         RfgPlt 536
        <rs:SCT-RESET-SCH> = Jsched(<rs:SCT-RESET-SCH>)                         RfgPlt 537
        <rs:HTREC-SCH>     = Jsched(<rs:HTREC-SCH>)                             RfgPlt 538
        <rs:AUX-SCH>       = Jsched(<rs:AUX-SCH>)                               RfgPlt 539
c                                                                               RfgPlt 540
c              Second level of attachments                                      RfgPlt 541
      CASE (202)                                                                RfgPlt 542
        IF (Jpm .GT. 0)  THEN                                                   RfgPlt 543
          Jpm = <rs:LIQUID-PUMP>                                                RfgPlt 544
          <pm;XComponent> = Jrs                                                 RfgPlt 545
        ENDIF                                                                   RfgPlt 546
c                                                                               RfgPlt 547
c              Create nodes                                                     RfgPlt 548
      CASE (203)                                                                RfgPlt 549
c              Inlet (return) and outlet (supply) to circuits.                  RfgPlt 550
        Keu             = NewEndUse(Jrs)                                        RfgPlt 551
        <rs;InletNode>  = NewNode(1, Jrs,Jrs,Jrs,0, 63,1,Keu, 1.)               RfgPlt 552
        <rs;OutletNode> = NewNode(1, Jrs,Jrs,Jrs,0, 61,2,  0, 1.)               RfgPlt 553
c              Intermediate nodes                                               RfgPlt 554
        <rs;Node1> = NewNode(1, 0,Jrs,Jrs,0, 65,-1,0, 1.)                       RfgPlt 555
        <rs;Node2> = NewNode(1, 0,Jrs,Jrs,0, 65,-2,0, 1.)                       RfgPlt 556
        <rs;Node3> = NewNode(1, 0,Jrs,Jrs,0, 64, 1,0, 1.)                       RfgPlt 557
c                                              ^node ID for linking             RfgPlt 558
c              auxiliary electrical                                             RfgPlt 559
        Jme = <rs:AUX-METER>                                                    RfgPlt 560
        <rs:AUX-METER> = NewNode(1, Jrs,Jrs,Jrs,Jme, 11,2,7, 1.)                RfgPlt 561
c                                                                               RfgPlt 562
c              Links, lists                                                     RfgPlt 563
      CASE (205)                                                                RfgPlt 564
c              Plant must have circuits                                         RfgPlt 565
        IF (<ri;Xnode> .EQ. 0)  THEN                                            RfgPlt 566
          CALL MSGSIM(-1,II,II,II,II)                                           RfgPlt 567
          WRITE (IOUTPT,9001)  (<rs:NAME>,II=1,8)                               RfgPlt 568
          CALL MessageBox( NULL,                                                RfgPlt 569
     &      'Refg-System design error - no discharge circuits'//char(0),        RfgPlt 570
     &      'REFG-SYSTEM Errors'//char(0),                                      RfgPlt 571
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                RfgPlt 572
          IwinReturn = 1                                                        RfgPlt 573
        ENDIF                                                                   RfgPlt 574
        IF (<ro;Xnode> .EQ. 0)  THEN                                            RfgPlt 575
          CALL MSGSIM(-1,II,II,II,II)                                           RfgPlt 576
          WRITE (IOUTPT,9002)  (<rs:NAME>,II=1,8)                               RfgPlt 577
          CALL MessageBox( NULL,                                                RfgPlt 578
     &      'REFG-System design error - no liquid circuits'//char(0),           RfgPlt 579
     &      'REFG-SYSTEM Errors'//char(0),                                      RfgPlt 580
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                RfgPlt 581
          IwinReturn = 1                                                        RfgPlt 582
        ENDIF                                                                   RfgPlt 583
c              Warn if no condensers                                            RfgPlt 584
        IF (<r2;Xnode> .EQ. 0)  THEN                                            RfgPlt 585
          CALL MSGSIM(-2,II,II,II,II)                                           RfgPlt 586
          WRITE (IOUTPT,9003)  (<rs:NAME>,II=1,8)                               RfgPlt 587
        ENDIF                                                                   RfgPlt 588
c                                                                               RfgPlt 589
c              All nodes associated with this system                            RfgPlt 590
        CALL ListNodes(<rs;SystemNodes>, Jrs,0,0,0, 0,0)                        RfgPlt 591
c              List of all kW nodes associated with this system                 RfgPlt 592
        CALL ListNodes(<rs;SysKWnodes>, Jrs,0,0,0, 11,2)                        RfgPlt 593
c              Nodes in the subsystem; includes plant equipment nodes           RfgPlt 594
        CALL ListNodes(<rs;SubSysNodes>, Jrs,Jrs,0,0, 0,0)                      RfgPlt 595
c                                                                               RfgPlt 596
c              Histories                                                        RfgPlt 597
      CASE (208)                                                                RfgPlt 598
c              History of node/outlet temperature and pressures                 RfgPlt 599
c              List of external circuit nodes                                   RfgPlt 600
        KliX = 0                                                                RfgPlt 601
        CALL ListAdd(KliX, <ri;Xnode>)                                          RfgPlt 602
        CALL ListAdd(KliX, <ro;Xnode>)                                          RfgPlt 603
c              list of variables to be damped                                   RfgPlt 604
c??     Kli = 0                                                                 RfgPlt 605
c??     Call ListAdd(Kli, Kro)                                                  RfgPlt 606
c??     Call ListAdd(Kli, <#ri.Pinlet>)                                         RfgPlt 607
        <rs;RefgHsty> = NewHistory(Jrs,Jrs,Jrs,  KliX, 0,                       RfgPlt 608
     &                    0, 10, 1.25,                                          RfgPlt 609
     &                    <#ro.Poutlet>, <sp:ERROR-P>, 1,                       RfgPlt 610
     &                    <#ro.Houtlet>, <sp:ERROR-H>, 1,                       RfgPlt 611
     &                    <#ro.Toutlet>, <sp:ERROR-T>, 1,                       RfgPlt 612
     &                    <#ri.Pinlet> , <sp:ERROR-P>, 1,                       RfgPlt 613
     &                    0,0.,0, 0,0.,0)                                       RfgPlt 614
c                                                                               RfgPlt 615
c              History lists                                                    RfgPlt 616
      CASE (209)                                                                RfgPlt 617
c              All histories associated with this system                        RfgPlt 618
        CALL ListHstys(<rs;SystemHstys>, Jrs, 0, 0)                             RfgPlt 619
c              plant/primary equipment subsystem                                RfgPlt 620
        CALL ListHstys(<rs;SubSysHstys>, 0, Jrs, 0)                             RfgPlt 621
c                                                                               RfgPlt 622
c                                                                               RfgPlt 623
c              Dump pointers                                                    RfgPlt 624
      CASE (210)                                                                RfgPlt 625
        IF (<rs;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         RfgPlt 626
        WRITE (IOUTPT, 9202)  (<rs:NAME>,II=1,8),                               RfgPlt 627
     &                        Jrs, Kri, Kro, r1, r2, r3, Jpm                    RfgPlt 628
c                                                                               RfgPlt 629
c                                                                               RfgPlt 630
      END SELECT  ! Mode                                                        RfgPlt 631
c                                                                               RfgPlt 632
      RETURN                                                                    RfgPlt 633
c                                                                               RfgPlt 634
c              Message formats                                                  RfgPlt 635
 9001 FORMAT(                                                                   RfgPlt 636
     &14x,'REFG-SYSTEM: ',8A4,' has no discharge circuits'             )        RfgPlt 637
 9002 FORMAT(                                                                   RfgPlt 638
     &14x,'REFG-SYSTEM: ',8A4,' has no liquid circuits'                )        RfgPlt 639
 9003 FORMAT(                                                                   RfgPlt 640
     &14x,'REFG-SYSTEM: ',8A4,' has no condensers.'                    /        RfgPlt 641
     &14x,'The condensing temperature setpoint will be maintained all' /        RfgPlt 642
     &14x,'hours, and no condenser energy will be calculated.'         )        RfgPlt 643
 9004 FORMAT(                                                                   RfgPlt 644
     &14x,'REFG-SYSTEM: ',8A4,' has a design refrigerant'              /        RfgPlt 645
     &14x,'flow of',F8.1,' lbs/hr, but the design condenser capacity'  /        RfgPlt 646
     &14x,'is only',F8.1,' lbs/hr.'                                    )        RfgPlt 647
 9005 FORMAT(                                                                   RfgPlt 648
     &14x,'REFG-SYSTEM: ',8A4,' has a required'                        /        RfgPlt 649
     &14x,'condensing temperature of',F6.1,' but the design condensing'/        RfgPlt 650
     &14x,'temperature is',F6.1                                        )        RfgPlt 651
 9101 FORMAT(                                                                   RfgPlt 652
     &14x,'REFG-SYSTEM: ',8A4,' has exceeded the'                      /        RfgPlt 653
     &14x,'maximum alarm temperature of',F6.1,' and has shut down.'    )        RfgPlt 654
 9102 FORMAT(                                                                   RfgPlt 655
     &14x,'REFG-SYSTEM: ',8A4,' has exceeded the'                      /        RfgPlt 656
     &14x,'minimum alarm temperature of',F6.1,' and has shut down.'    /        RfgPlt 657
     &14x,'Use BACKFLOOD-CTRL to prevent excessively low condensing '           RfgPlt 658
     &    'temperatures.'                                              )        RfgPlt 659
 9201 FORMAT(/' REFG-SYSTEMs                           Jrs       Kri',          RfgPlt 660
     &'       Kro    Node 1    Node 2    Node 3       Jpm'             /        RfgPlt 661
     &1x,32('-'),7('  --------'))                                               RfgPlt 662
 9202 FORMAT(1x,8A4,7I10)                                                       RfgPlt 663
c                                                                               RfgPlt 664
      END                                                                       RfgPlt 665
      SUBROUTINE RefgReports(Mode)                                              RfgRep   2
c                                                                               RfgRep   3
c              Controls the printing of refrigeration reports                   RfgRep   4
c                                                                               RfgRep   5
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /ListsR/ ListRefgPlants, xListsR                                  /ListsR/ 2
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
c                                                                               RfgRep  10
                                                                                RfgRep  11
      SELECT CASE (Mode)                                                        RfgRep  12
c                                                                               RfgRep  13
c                                                                               RfgRep  14
c ============ REPORT ORDER =================================================== RfgRep  15
      CASE (52)                                                                 RfgRep  16
c                                                                               RfgRep  17
c              For each refrigeration system, create reports in the             RfgRep  18
c              order simulated from system to load                              RfgRep  19
c                                                                               RfgRep  20
c              Refg plants and condensers                                       RfgRep  21
      Kli = ListRefgPlants               ! list of refg plants                  RfgRep  22
      DO  LI=1,<li;NumItems>                                                    RfgRep  23
        Jrs = <li;List>                  ! pointer to the refg plant            RfgRep  24
        CALL RefgPlant(Mode, Jrs)                                               RfgRep  25
c                                                                               RfgRep  26
c              Liquid circuits and subcoolers                                   RfgRep  27
        Kl2 = <rs;LiquidCkts>            ! list of liquid ckts                  RfgRep  28
        DO  L2=1,<l2;NumItems>           ! lowest to highest rank ckt           RfgRep  29
          CALL RefgNetworkAlgs(Mode, <l2;List>)                                 RfgRep  30
        ENDDO                                                                   RfgRep  31
c                                                                               RfgRep  32
c              Discharge circuits                                               RfgRep  33
        Kl2     = <rs;DischargeCkts>     ! list of discharge ckts               RfgRep  34
        DO  L2=1,<l2;NumItems>           ! lowest to highest rank ckt           RfgRep  35
          CALL RefgNetworkAlgs(Mode, <l2;List>)                                 RfgRep  36
        ENDDO                                                                   RfgRep  37
c                                                                               RfgRep  38
c              Suction-groups                                                   RfgRep  39
        Kl2   = <rs;SuctionGroups>       ! list of suction groups               RfgRep  40
        DO  L2=1,<l2;NumItems>           ! lowest to highest rank group         RfgRep  41
          Jsg = <l2;List>                ! pointer to suction group             RfgRep  42
          CALL SuctionGroup(Mode, Jsg)                                          RfgRep  43
c                                                                               RfgRep  44
c              Suction circuits and desuperheaters                              RfgRep  45
          Kl3     = <sg;SuctionCkts>     ! list of suction ckts                 RfgRep  46
          DO  L3=1,<l3;NumItems>         ! lowest to highest rank ckt           RfgRep  47
            CALL RefgNetworkAlgs(Mode, <l3;List>)                               RfgRep  48
          ENDDO                                                                 RfgRep  49
c                                                                               RfgRep  50
c              Process loads                                                    RfgRep  51
          IF (Ipq .ne. 0)  THEN                                                 RfgRep  52
            Jpq = Ipq                                                           RfgRep  53
            DO WHILE (Jpq .GT. 0)                                               RfgRep  54
              IF (<pq:/SuctionGroup> .eq. Jsg)                                  RfgRep  55
     &          CALL ProcessAlgs(Mode, Jpq)                                     RfgRep  56
              Jpq = <pq;Next>                                                   RfgRep  57
            ENDDO                                                               RfgRep  58
          ENDIF                                                                 RfgRep  59
c                                                                               RfgRep  60
c              Refrigerated fixtures                                            RfgRep  61
          IF (Irf .ne. 0)  THEN                                                 RfgRep  62
            Jrf = Irf                                                           RfgRep  63
            DO WHILE (Jrf .GT. 0)                                               RfgRep  64
              IF (<rf:/SuctionGroup> .eq. Jsg)                                  RfgRep  65
     &          CALL RefgFixtureAlgs(Mode, Jrf)                                 RfgRep  66
              Jrf = <rf;Next>                                                   RfgRep  67
            ENDDO                                                               RfgRep  68
          ENDIF                                                                 RfgRep  69
c                                                                               RfgRep  70
        ENDDO  ! L2                                                             RfgRep  71
      ENDDO  ! LI=1,NumPlants                                                   RfgRep  72
c                                                                               RfgRep  73
      END SELECT  ! Mode                                                        RfgRep  74
c                                                                               RfgRep  75
      Return                                                                    RfgRep  76
      End                                                                       RfgRep  77
      BLOCK DATA Refrigeration_Data                                             RfgDat   2
c                                                                               RfgDat   3
c              Refrigeration module fixed values                                RfgDat   4
c                                                                               RfgDat   5
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               RfgDat   8
c              set values for various symbols                                   RfgDat   9
c              /refgky/                                                         RfgDat  10
      DATA  Liquid, Suction, Discharge                  /1,2,3/                 RfgDat  11
      DATA  Trunk, Branch                               /1,2/                   RfgDat  12
      DATA  Desuperheat, HoldBack                       /1,2/                   RfgDat  13
c                                                                               RfgDat  14
      END                                                                       RfgDat  15
      SUBROUTINE RefgX(Jna, Jrc1, Jrc2, Jrc3)                                   RefgX    2
c                                                                               RefgX    3
c              Checks attachments to make sure not cross-connected              RefgX    4
c              to two different refrigeration plants                            RefgX    5
c                                                                               RefgX    6
c              Jna    Pointer to component                                      RefgX    7
c              Jrc1   Pointer to 1st refrigeration circuit                      RefgX    8
c              Jrc2   Pointer to 2nd refrigeration circuit                      RefgX    9
c              Jrc3   Pointer to 3rd refrigeration circuit                      RefgX   10
c                                                                               RefgX   11
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               RefgX   16
      IF (Jrc1 .GT. 0)  THEN                                                    RefgX   17
        Jrs = RefgX_Jrs(Jrc1)                                                   RefgX   18
        Jn2 = Jrc1                                                              RefgX   19
      ELSEIF (Jrc2 .GT. 0)  THEN                                                RefgX   20
        Jrs = RefgX_Jrs(Jrc2)                                                   RefgX   21
        Jn2 = Jrc2                                                              RefgX   22
      ENDIF                                                                     RefgX   23
c                                                                               RefgX   24
      IF (Jrc2 .GT. 0)  THEN                                                    RefgX   25
        IF (RefgX_Jrs(Jrc2) .NE. Jrs)  THEN                                     RefgX   26
          CALL MSGSIM(-1,II,II,II,II)                                           RefgX   27
          Jn3 = Jrc2                                                            RefgX   28
          WRITE (IOUTPT, 9001)  (<na:NAME>,II=1,8),                             RefgX   29
     &                          (<na2:NAME>,II=1,8), (<na3:NAME>,II=1,8)        RefgX   30
          CALL MessageBox( NULL,                                                RefgX   31
     &      'A component is cross-connected'//char(10)//char(13)//              RefgX   32
     &      'between two refrigeration systems'//char(0),                       RefgX   33
     &      'Refrigeration Errors'//char(0),                                    RefgX   34
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                RefgX   35
          IwinReturn = 1                                                        RefgX   36
        ENDIF                                                                   RefgX   37
      ENDIF                                                                     RefgX   38
c                                                                               RefgX   39
      IF (Jrc3 .GT. 0)  THEN                                                    RefgX   40
        IF (RefgX_Jrs(Jrc3) .NE. Jrs)  THEN                                     RefgX   41
          CALL MSGSIM(-1,II,II,II,II)                                           RefgX   42
          Jn3 = Jrc3                                                            RefgX   43
          WRITE (IOUTPT, 9001)  (<na:NAME>,II=1,8),                             RefgX   44
     &                          (<na2:NAME>,II=1,8), (<na3:NAME>,II=1,8)        RefgX   45
          CALL MessageBox( NULL,                                                RefgX   46
     &      'A component is cross-connected'//char(10)//char(13)//              RefgX   47
     &      'between two refrigeration systems'//char(0),                       RefgX   48
     &      'Refrigeration Errors'//char(0),                                    RefgX   49
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                RefgX   50
          IwinReturn = 1                                                        RefgX   51
        ENDIF                                                                   RefgX   52
      ENDIF                                                                     RefgX   53
c                                                                               RefgX   54
      RETURN                                                                    RefgX   55
c                                                                               RefgX   56
 9001 FORMAT(14x,'Component: ',8A4,' is cross-connected'               /        RefgX   57
     &       14x,'between two different refrigeration systems.'        /        RefgX   58
     &       14x,'Offending attachments are: ',8A4                     /        RefgX   59
     &       14x,'and: ',8A4                                           )        RefgX   60
      END                                                                       RefgX   61
      FUNCTION RefgX_Jrs(Jcomp)                                                 RefgX   62
c                                                                               RefgX   63
c              Finds the refrigeration system to which a component              RefgX   64
c              belongs.                                                         RefgX   65
c                                                                               RefgX   66
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
c                                                                               RefgX   70
c              See if a refg-circuit                                            RefgX   71
      Jrc = Irc                                                                 RefgX   72
      DO WHILE (Jrc .GT. 0)                                                     RefgX   73
        IF (Jcomp .EQ. Jrc)  THEN                                               RefgX   74
          RefgX_Jrs = <rc:/RefgSystem/>                                         RefgX   75
          RETURN                                                                RefgX   76
        ENDIF                                                                   RefgX   77
        Jrc = <rc;Next>                                                         RefgX   78
      ENDDO                                                                     RefgX   79
c                                                                               RefgX   80
c              See if a system                                                  RefgX   81
      Jrs = Irs                                                                 RefgX   82
      DO WHILE (Jrs .GT. 0)                                                     RefgX   83
        IF (Jcomp .EQ. Jrs)  THEN                                               RefgX   84
          RefgX_Jrs = Jcomp                                                     RefgX   85
          RETURN                                                                RefgX   86
        ENDIF                                                                   RefgX   87
        Jrs = <rs;Next>                                                         RefgX   88
      ENDDO                                                                     RefgX   89
c                                                                               RefgX   90
c              See if a suction group                                           RefgX   91
      Jsg = Isg                                                                 RefgX   92
      DO WHILE (Jsg .GT. 0)                                                     RefgX   93
        IF (Jcomp .EQ. Jsg)  THEN                                               RefgX   94
          RefgX_Jrs = <sg:/RefgSystem/>                                         RefgX   95
          RETURN                                                                RefgX   96
        ENDIF                                                                   RefgX   97
        Jsg = <sg;Next>                                                         RefgX   98
      ENDDO                                                                     RefgX   99
c                                                                               RefgX  100
      RefgX_Jrx = -88888                                                        RefgX  101
c                                                                               RefgX  102
      RETURN                                                                    RefgX  103
      END                                                                       RefgX  104
      SUBROUTINE Refrigeration_Design                                           RfgDes   2
c                                                                               RfgDes   3
c              Design calculations for refrigeration systems                    RfgDes   4
c                                                                               RfgDes   5
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /ListsR/ ListRefgPlants, xListsR                                  /ListsR/ 2
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               RfgDes  12
c              Calculate the design variables for all refrigeration             RfgDes  13
c              system components.  Multiple passes must be made thru            RfgDes  14
c              these calculations, as requirements determined toward            RfgDes  15
c              the end of the calculations modify initial assumptions.          RfgDes  16
c                                                                               RfgDes  17
c              Pointer to ranked list of refrigeration plants                   RfgDes  18
      Kli       = ListRefgPlants                                                RfgDes  19
      NumPlants = <li;NumItems>                                                 RfgDes  20
c                                                                               RfgDes  21
c              Pass the liquid and discharge circuit conditions up              RfgDes  22
c              through the branches to the loads                                RfgDes  23
      DO  LI=1,NumPlants                                                        RfgDes  24
        Jrs     = <li;List>              ! pointer to the refg plant            RfgDes  25
        Kl2     = <rs;LiquidCkts>        ! list of liquid ckts                  RfgDes  26
        NumCkts = <l2;NumItems>          ! number of ckts                       RfgDes  27
        DO  L2=1,NumCkts                 ! lowest to highest rank ckt           RfgDes  28
          CALL RefgNetworkAlgs(112, <l2;List>)                                  RfgDes  29
          IF (IwinReturn .ne. 0)  Return                                        RfgDes  30
        ENDDO                                                                   RfgDes  31
        Kl2     = <rs;DischargeCkts>     ! list of discharge ckts               RfgDes  32
        NumCkts = <l2;NumItems>          ! number of ckts                       RfgDes  33
        DO  L2=1,NumCkts                 ! lowest to highest rank ckt           RfgDes  34
          CALL RefgNetworkAlgs(112, <l2;List>)                                  RfgDes  35
          IF (IwinReturn .ne. 0)  Return                                        RfgDes  36
        ENDDO                                                                   RfgDes  37
      ENDDO                                                                     RfgDes  38
c                                                                               RfgDes  39
c              Design the fixtures to get the airside loads                     RfgDes  40
      Jrf = Irf                                                                 RfgDes  41
      DO WHILE (Jrf .GT. 0)                                                     RfgDes  42
        CALL RefgFixtureAlgs(111, Jrf)                                          RfgDes  43
        IF (IwinReturn .ne. 0)  Return                                          RfgDes  44
        Jrf = <rf;Next>                                                         RfgDes  45
      ENDDO                                                                     RfgDes  46
c                                                                               RfgDes  47
c              Design the fixtures to get the liquid and suction loads          RfgDes  48
      Jrf = Irf                                                                 RfgDes  49
      DO WHILE (Jrf .GT. 0)                                                     RfgDes  50
        CALL RefgFixtureAlgs(112, Jrf)                                          RfgDes  51
        IF (IwinReturn .eq. 1)  Return                                          RfgDes  52
        Jrf = <rf;Next>                                                         RfgDes  53
      ENDDO                                                                     RfgDes  54
c              HVAC coils attached to refrigeration                             RfgDes  55
      CALL RefgCoils_Old(111)                                                   RfgDes  56
c ??  CALL CoilAlgs(??)                                                         RfgDes  57
      IF (IwinReturn .eq. 1)  Return                                            RfgDes  58
c                                                                               RfgDes  59
c              Design each refrigeration plant from the loads down              RfgDes  60
c              to the condensers, starting with the highest ranked plant        RfgDes  61
      DO  LI=NumPlants,1,-1                                                     RfgDes  62
        Jrs     = <li;List>              ! pointer to refg plant                RfgDes  63
c              Design the liquid circuits to establish mass flow and            RfgDes  64
c              required pressure                                                RfgDes  65
        Kl2     = <rs;LiquidCkts>        ! list of liquid ckts                  RfgDes  66
        NumCkts = <l2;NumItems>          ! number of ckts                       RfgDes  67
        DO  L2=NumCkts,1,-1              ! highest to lowest rank ckt           RfgDes  68
          CALL RefgNetworkAlgs(111, <l2;List>)                                  RfgDes  69
          IF (IwinReturn .eq. 1)  Return                                        RfgDes  70
        ENDDO                                                                   RfgDes  71
c                                                                               RfgDes  72
c              Design each suction-group and its suction circuits,              RfgDes  73
c              starting with the highest ranked suction group                   RfgDes  74
        Kl2   = <rs;SuctionGroups>       ! list of suction groups               RfgDes  75
        NumSG = <l2;NumItems>            ! number of suction groups             RfgDes  76
        DO  L2=NumSG,1,-1                ! highest to lowest rank group         RfgDes  77
          Jsg = <l2;List>                ! pointer to suction group             RfgDes  78
c              Design the suction circuits to establish desuperheat,            RfgDes  79
c              mass flow, enthalpy, and required suction pressure               RfgDes  80
          Kl3     = <sg;SuctionCkts>     ! list of suction ckts                 RfgDes  81
          NumCkts = <l3;NumItems>        ! number of ckts                       RfgDes  82
          DO  L3=NumCkts,1,-1            ! highest to lowest rank ckt           RfgDes  83
            CALL RefgNetworkAlgs(111, <l3;List>)                                RfgDes  84
            IF (IwinReturn .eq. 1)  Return                                      RfgDes  85
          ENDDO                                                                 RfgDes  86
c              Design the suction groups to establish mass flow,                RfgDes  87
c              compressor characteristics, and discharge enthalpy               RfgDes  88
          CALL SuctionGroup(111, Jsg)                                           RfgDes  89
          IF (IwinReturn .eq. 1)  Return                                        RfgDes  90
        ENDDO  ! L2                                                             RfgDes  91
c                                                                               RfgDes  92
c              Design discharge circuits to establish mass flow,                RfgDes  93
c              enthalpy, and heat-recovery                                      RfgDes  94
        Kl2     = <rs;DischargeCkts>     ! list of discharge ckts               RfgDes  95
        NumCkts = <l2;NumItems>          ! number of ckts                       RfgDes  96
        DO  L2=NumCkts,1,-1              ! highest to lowest rank ckt           RfgDes  97
          CALL RefgNetworkAlgs(111, <l2;List>)                                  RfgDes  98
          IF (IwinReturn .eq. 1)  Return                                        RfgDes  99
        ENDDO                                                                   RfgDes 100
c                                                                               RfgDes 101
c              Design the refrigeration plant to establish condenser            RfgDes 102
c              characteristics                                                  RfgDes 103
        CALL RefgPlant(111, Jrs)                                                RfgDes 104
        IF (IwinReturn .eq. 1)  Return                                          RfgDes 105
      ENDDO  ! LI=NumPlants                                                     RfgDes 106
c                                                                               RfgDes 107
c              Propagate design conditions from the Refg-System back up         RfgDes 108
c              thru the discharge circuits, suction groups, and                 RfgDes 109
c              suction circuits                                                 RfgDes 110
      DO  LI=1,NumPlants                                                        RfgDes 111
        Jrs = <li;List>                  ! pointer to the refg plant            RfgDes 112
c              Design the discharge circuits to establish condensing            RfgDes 113
c              temperature, starting with the lowest ranked                     RfgDes 114
        Kl2     = <rs;DischargeCkts>     ! list of discharge ckts               RfgDes 115
        NumCkts = <l2;NumItems>          ! number of ckts                       RfgDes 116
        DO  L2=1,NumCkts                 ! lowest to highest rank ckt           RfgDes 117
          CALL RefgNetworkAlgs(112, <l2;List>)                                  RfgDes 118
          IF (IwinReturn .eq. 1)  Return                                        RfgDes 119
        ENDDO                                                                   RfgDes 120
c              Design the suction circuits to establish inlet suction           RfgDes 121
c              pressure, starting with the lowest ranked                        RfgDes 122
        Kl2   = <rs;SuctionGroups>       ! list of suction groups               RfgDes 123
        NumSG = <l2;NumItems>            ! number of suction groups             RfgDes 124
        DO  L2=1,NumSG                   ! lowest to highest rank group         RfgDes 125
          Jsg     = <l2;List>            ! pointer to suction group             RfgDes 126
          Kl3     = <sg;SuctionCkts>     ! list of suction ckts                 RfgDes 127
          NumCkts = <l3;NumItems>        ! number of ckts                       RfgDes 128
          DO  L3=1,NumCkts               ! lowest to highest rank ckt           RfgDes 129
            CALL RefgNetworkAlgs(112, <l3;List>)                                RfgDes 130
            IF (IwinReturn .eq. 1)  Return                                      RfgDes 131
          ENDDO                                                                 RfgDes 132
        ENDDO  ! L2                                                             RfgDes 133
      ENDDO  ! LI=1,NumPlants                                                   RfgDes 134
c                                                                               RfgDes 135
      RETURN                                                                    RfgDes 136
      END                                                                       RfgDes 137
      Subroutine Refrigeration_Initial                                          RInit    2
c                                                                               RInit    3
c              Initializes all common block variables                           RInit    4
c              in the Refrigeration module                                      RInit    5
c                                                                               RInit    6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /DatSrf/ Tsurface, Hsurface, dTdH                                 /DatSrf/ 2
      COMMON  /HRREP / Irb, Ihrp, Lrb, Lhrp, Nrb, Nhrp, IVTLIM(3,50),           HRr      1
     &                 IGRPtr, IBRPtr, IRSch, IRSchT(5),                        HRr      2
     &                 NHRTyp(3), ITBUF(3), ITBUFB(3), ITBUFE(3),               HRr      3
     &                 IHREOF, ICDFLG                                           HRr      4
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
      COMMON  /ListsR/ ListRefgPlants, xListsR                                  /ListsR/ 2
c                                                                               RInit   13
c              /ListsR/                                                         RInit   14
      CALL ZeroBlock(ListRefgPlants, xListsR)                                   RInit   15
                                                                                RInit   67
c              Initial wet coil surface properties                              RInit   68
      Tsurface = 50.                                                            RInit   69
      Hsurface = 20.306                                                         RInit   70
      dTdH     = 1.80                                                           RInit   71
                                                                                RInit   72
      RETURN                                                                    RInit   73
      END                                                                       RInit   74
      SUBROUTINE Refrigeration_Sort                                             SortR    2
c                                                                               SortR    3
c              Determine the various relationships that the                     SortR    4
c              refrigeration components have to each other                      SortR    5
c                                                                               SortR    6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /ListsR/ ListRefgPlants, xListsR                                  /ListsR/ 2
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               SortR   13
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               SortR   15
      INTEGER Rank, Save, r2                                                    SortR   16
      LOGICAL AllRanksFound                                                     SortR   17
c                                                                               SortR   18
c                                                                               SortR   19
c              Refrigerant circuit ranking                                      SortR   20
c              Rank = 1  Trunk circuit                                          SortR   21
c                     2  Secondary branch - attached to trunk                   SortR   22
c                     3  Tertiary branch  - attached to secondary               SortR   23
c                     4  etc.                                                   SortR   24
c                                                                               SortR   25
      IF (Nrs .EQ. 0)  RETURN                                                   SortR   26
c                                                                               SortR   27
c              Determine the rank of all circuits, subcoolers, and              SortR   28
c              desuperheaters.                                                  SortR   29
      AllRanksFound = .FALSE.                                                   SortR   30
      DO WHILE (.NOT. AllRanksFound)                                            SortR   31
        AllRanksFound = .TRUE.                                                  SortR   32
c                                                                               SortR   33
c              Subcoolers                                                       SortR   34
        Jsc = Isc                                                               SortR   35
        DO WHILE (Jsc .GT. 0)                                                   SortR   36
          IF (<sc;Rank> .EQ. 0)  THEN                                           SortR   37
c              see if rank of attached component is set                         SortR   38
            SELECT CASE (<sc:ATTACH-TO>)                                        SortR   39
              CASE (1)  ! Refg-system                                           SortR   40
                <sc;Rank>     = 1                                               SortR   41
                AllRanksFound = .FALSE.                                         SortR   42
              CASE (6)  ! Refg-circuit                                          SortR   43
                Jrc = <sc:SUBCOOL-CKT>                                          SortR   44
                IF (<rc;Rank> .GT. 0)  THEN                                     SortR   45
                  <sc;Rank>     = <rc;Rank> + 1                                 SortR   46
                  AllRanksFound = .FALSE.                                       SortR   47
                ENDIF                                                           SortR   48
            END SELECT                                                          SortR   49
          ENDIF  ! sc;Rank                                                      SortR   50
          Jsc = <sc;Next>                                                       SortR   51
        ENDDO  ! Jsc                                                            SortR   52
c                                                                               SortR   53
c              Desuperheaters                                                   SortR   54
        Jds = Ids                                                               SortR   55
        DO WHILE (Jds .GT. 0)                                                   SortR   56
          IF (<ds;Rank> .EQ. 0)  THEN                                           SortR   57
c              see if rank of attached component is set                         SortR   58
            SELECT CASE (<ds:ATTACH-TO>)                                        SortR   59
              CASE (2)  ! Suction-group                                         SortR   60
                <ds;Rank>     = 1                                               SortR   61
                AllRanksFound = .FALSE.                                         SortR   62
              CASE (6)  ! Refg-circuit                                          SortR   63
                Jrc = <ds:DESUPER-CKT>                                          SortR   64
                IF (<rc;Rank> .GT. 0)  THEN                                     SortR   65
                  <ds;Rank>     = <rc;Rank> + 1                                 SortR   66
                  AllRanksFound = .FALSE.                                       SortR   67
                ENDIF                                                           SortR   68
            END SELECT                                                          SortR   69
          ENDIF  ! ds;Rank                                                      SortR   70
          Jds = <ds;Next>                                                       SortR   71
        ENDDO  ! Jsc                                                            SortR   72
c                                                                               SortR   73
c              Refg-circuits                                                    SortR   74
        Jrc = Irc                                                               SortR   75
        DO WHILE (Jrc .GT. 0)                                                   SortR   76
          IF (<rc;Rank> .EQ. 0)  THEN                                           SortR   77
c              see if rank of attached circuit matches the LastRank             SortR   78
            SELECT CASE (<rc:ATTACH-TO>)                                        SortR   79
              CASE (1)  ! Refg-system                                           SortR   80
                <rc;Rank>     = 1                                               SortR   81
                AllRanksFound = .FALSE.                                         SortR   82
              CASE (2)  ! Suction-group                                         SortR   83
                <rc;Rank>     = 1                                               SortR   84
                AllRanksFound = .FALSE.                                         SortR   85
              CASE (3)  ! Subcooler                                             SortR   86
                Jsc = <rc:SUBCOOLER>                                            SortR   87
                IF (<sc;Rank> .GT. 0)  THEN                                     SortR   88
                  <rc;Rank>     = <sc;Rank> + 1                                 SortR   89
                  AllRanksFound = .FALSE.                                       SortR   90
                ENDIF                                                           SortR   91
              CASE (4)  ! Desuperheater                                         SortR   92
                Jds = <rc:DESUPERHEATER>                                        SortR   93
                IF (<ds;Rank> .GT. 0)  THEN                                     SortR   94
                  <rc;Rank>     = <ds;Rank> + 1                                 SortR   95
                  AllRanksFound = .FALSE.                                       SortR   96
                ENDIF                                                           SortR   97
              CASE (5)  ! Heat reclaim                                          SortR   98
              CASE (6)  ! Refg-circuit                                          SortR   99
                Save = Jrc                                                      SortR  100
                Jrc  = <rc:TRUNK-CKT>                                           SortR  101
                Rank = <rc;Rank>                                                SortR  102
                Jrc  = Save                                                     SortR  103
                IF (Rank .GT. 0)  THEN                                          SortR  104
                  <rc;Rank>     = Rank + 1                                      SortR  105
                  AllRanksFound = .FALSE.                                       SortR  106
                ENDIF                                                           SortR  107
            END SELECT  ! rc:ATTACH-TO                                          SortR  108
          ENDIF  ! rc;Rank                                                      SortR  109
          Jrc = <rc;Next>                                                       SortR  110
        ENDDO  ! Jrc                                                            SortR  111
      ENDDO    ! AllRanksFound                                                  SortR  112
c                                                                               SortR  113
c              Determine the rank of all suction groups.                        SortR  114
      AllRanksFound = .FALSE.                                                   SortR  115
      DO WHILE (.NOT. AllRanksFound)                                            SortR  116
        AllRanksFound = .TRUE.                                                  SortR  117
        Jsg = Isg                                                               SortR  118
        DO WHILE (Jsg .GT. 0)                                                   SortR  119
          IF (<sg;Rank> .EQ. 0)  THEN                                           SortR  120
c              suction group is considered a primary if it attaches             SortR  121
c              directly to a discharge circuit                                  SortR  122
            Jrc = <sg:DISCHARGE-CKT>                                            SortR  123
            IF (<rc:TYPE> .EQ. Discharge)  THEN                                 SortR  124
              <sg;Rank>     = 1                                                 SortR  125
              AllRanksFound = .FALSE.                                           SortR  126
            ELSE                                                                SortR  127
c                 see if rank of parent suction-group is set                    SortR  128
              Save = Jsg                                                        SortR  129
              Jrc  = <sg:DISCHARGE-CKT>                                         SortR  130
              Jsg  = <rc:/SuctionGroup>                                         SortR  131
              Rank = <sg;Rank>                                                  SortR  132
              Jsg  = Save                                                       SortR  133
              IF (Rank .GT. 0)  THEN                                            SortR  134
                <sg;Rank>     = Rank + 1                                        SortR  135
                AllRanksFound = .FALSE.                                         SortR  136
              ENDIF                                                             SortR  137
            ENDIF  ! rc:TYPE                                                    SortR  138
          ENDIF  ! sg;Rank                                                      SortR  139
          Jsg = <sg;Next>                                                       SortR  140
        ENDDO  ! Jsg                                                            SortR  141
      ENDDO    ! AllRanksFound                                                  SortR  142
c                                                                               SortR  143
c              For each suction group, create a list of attached suction        SortR  144
c              circuits and desuperheaters in order of rank.  Note that         SortR  145
c              more than one component may have the same rank.                  SortR  146
      Jsg = Isg                                                                 SortR  147
      DO WHILE (Jsg .GT. 0)                                                     SortR  148
        Rank          = 0                                                       SortR  149
        AllRanksFound = .FALSE.                                                 SortR  150
        DO WHILE (.NOT. AllRanksFound)                                          SortR  151
          Rank          = Rank + 1                                              SortR  152
          AllRanksFound = .TRUE.                                                SortR  153
c                                                                               SortR  154
c              Desuperheaters                                                   SortR  155
          Jds = Ids                                                             SortR  156
          DO WHILE (Jds .GT. 0)                                                 SortR  157
            IF (<ds:/SuctionGroup> .EQ. Jsg  .AND.                              SortR  158
     &                   <ds;Rank> .EQ. Rank)  THEN                             SortR  159
              AllRanksFound = .FALSE.                                           SortR  160
              CALL ListAdd(<sg;SuctionCkts>, Jds)                               SortR  161
            ENDIF                                                               SortR  162
            Jds = <ds;Next>                                                     SortR  163
          ENDDO  ! Jds                                                          SortR  164
c                                                                               SortR  165
c             Suction circuits                                                  SortR  166
          Jrc = Irc                                                             SortR  167
          DO WHILE (Jrc .GT. 0)                                                 SortR  168
            IF (<rc:/SuctionGroup> .EQ. Jsg  .AND.                              SortR  169
     &                   <rc;Rank> .EQ. Rank)  THEN                             SortR  170
              AllRanksFound = .FALSE.                                           SortR  171
              CALL ListAdd(<sg;SuctionCkts>, Jrc)                               SortR  172
            ENDIF                                                               SortR  173
            Jrc = <rc;Next>                                                     SortR  174
          ENDDO  ! Jrc                                                          SortR  175
        ENDDO    ! AllRanksFound                                                SortR  176
        Jsg = <sg;Next>                                                         SortR  177
      ENDDO  ! Jsg                                                              SortR  178
c                                                                               SortR  179
c              For each refrigeration system create lists of circuits,          SortR  180
c              suction-groups, condensers, etc.                                 SortR  181
      Jrs = Irs                                                                 SortR  182
      DO WHILE (Jrs .GT. 0)                                                     SortR  183
c              liquid circuits and subcoolers, in order of rank                 SortR  184
        Rank          = 0                                                       SortR  185
        AllRanksFound = .FALSE.                                                 SortR  186
        DO WHILE (.NOT. AllRanksFound)                                          SortR  187
          Rank          = Rank + 1                                              SortR  188
          AllRanksFound = .TRUE.                                                SortR  189
c                                                                               SortR  190
c              Subcoolers                                                       SortR  191
          Jsc = Isc                                                             SortR  192
          DO WHILE (Jsc .GT. 0)                                                 SortR  193
            IF (<sc:/RefgSystem/> .EQ. Jrs  .AND.                               SortR  194
     &                  <sc;Rank> .EQ. Rank)  THEN                              SortR  195
              CALL ListAdd(<rs;LiquidCkts>, Jsc)                                SortR  196
              AllRanksFound = .FALSE.                                           SortR  197
            ENDIF                                                               SortR  198
            Jsc = <sc;Next>                                                     SortR  199
          ENDDO  ! Jrc                                                          SortR  200
c                                                                               SortR  201
c              Liquid circuits                                                  SortR  202
          Jrc = Irc                                                             SortR  203
          DO WHILE (Jrc .GT. 0)                                                 SortR  204
            IF (<rc:/RefgSystem/> .EQ. Jrs     .AND.                            SortR  205
     &                  <rc:TYPE> .EQ. Liquid  .AND.                            SortR  206
     &                  <rc;Rank> .EQ. Rank)       THEN                         SortR  207
              CALL ListAdd(<rs;LiquidCkts>, Jrc)                                SortR  208
              AllRanksFound = .FALSE.                                           SortR  209
            ENDIF                                                               SortR  210
            Jrc = <rc;Next>                                                     SortR  211
          ENDDO  ! Jrc                                                          SortR  212
        ENDDO    ! AllRanksFound                                                SortR  213
c                                                                               SortR  214
c              discharge circuits, in order of rank                             SortR  215
        Rank          = 0                                                       SortR  216
        AllRanksFound = .FALSE.                                                 SortR  217
        DO WHILE (.NOT. AllRanksFound)                                          SortR  218
          Rank          = Rank + 1                                              SortR  219
          AllRanksFound = .TRUE.                                                SortR  220
          Jrc = Irc                                                             SortR  221
          DO WHILE (Jrc .GT. 0)                                                 SortR  222
            IF (<rc:/RefgSystem/> .EQ. Jrs        .AND.                         SortR  223
     &                  <rc:TYPE> .EQ. Discharge  .AND.                         SortR  224
     &                  <rc;Rank> .EQ. Rank)         THEN                       SortR  225
              CALL ListAdd(<rs;DischargeCkts>, Jrc)                             SortR  226
              AllRanksFound = .FALSE.                                           SortR  227
            ENDIF                                                               SortR  228
            Jrc = <rc;Next>                                                     SortR  229
          ENDDO  ! Jrc                                                          SortR  230
        ENDDO    ! AllRanksFound                                                SortR  231
c              suction groups, in order of rank                                 SortR  232
        Rank          = 0                                                       SortR  233
        AllRanksFound = .FALSE.                                                 SortR  234
        DO WHILE (.NOT. AllRanksFound)                                          SortR  235
          Rank          = Rank + 1                                              SortR  236
          AllRanksFound = .TRUE.                                                SortR  237
          Jsg = Isg                                                             SortR  238
          DO WHILE (Jsg .GT. 0)                                                 SortR  239
            IF (<sg:/RefgSystem/> .EQ. Jrs  .AND.                               SortR  240
     &                  <sg;Rank> .EQ. Rank)  THEN                              SortR  241
              CALL ListAdd(<rs;SuctionGroups>, Jsg)                             SortR  242
              AllRanksFound = .FALSE.                                           SortR  243
            ENDIF                                                               SortR  244
            Jsg = <sg;Next>                                                     SortR  245
          ENDDO  ! Jsg                                                          SortR  246
        ENDDO    ! AllRanksFound                                                SortR  247
        Jrs = <rs;Next>                                                         SortR  248
      ENDDO                                                                     SortR  249
c                                                                               SortR  250
c              Rank the refrigeration systems.  A system has a rank             SortR  251
c              higher than 1 only if it has a condenser that cascades           SortR  252
c              into another system                                              SortR  253
      AllRanksFound = .TRUE.                                                    SortR  254
      Jrs = Irs                                                                 SortR  255
      DO WHILE (Jrs .GT. 0)                                                     SortR  256
        <rs;Rank> = 1                                                           SortR  257
        r2        = <rs;Node2>                                                  SortR  258
        Kli       = <r2;Xnode>                                                  SortR  259
        IF (Kli .GT. 0)  THEN                                                   SortR  260
          NumItems = <li;NumItems>                                              SortR  261
          DO  LI=1,NumItems                                                     SortR  262
            Knx = <li;List>                                                     SortR  263
            Jcd = <nx;Component>                                                SortR  264
            IF (<cd:TYPE> .EQ. 3)  THEN                                         SortR  265
              <rs;Rank>     = 0                                                 SortR  266
              AllRanksFound = .FALSE.                                           SortR  267
              EXIT                                                              SortR  268
            ENDIF                                                               SortR  269
          ENDDO                                                                 SortR  270
        ENDIF                                                                   SortR  271
        Jrs = <rs;Next>                                                         SortR  272
      ENDDO                                                                     SortR  273
c              Now rank the cascading systems                                   SortR  274
      DO WHILE (.NOT. AllRanksFound)                                            SortR  275
        AllRanksFound = .TRUE.                                                  SortR  276
        Jrs = Irs                                                               SortR  277
        DO WHILE (Jrs .GT. 0)                                                   SortR  278
          IF (<rs;Rank> .EQ. 0)  THEN                                           SortR  279
            Save = Jrs                                                          SortR  280
c              find the highest ranked downstream system                        SortR  281
            MaxRank  = 0                                                        SortR  282
            r2       = <rs;Node2>                                               SortR  283
            Kli      = <r2;Xnode>                                               SortR  284
            NumItems = <li;NumItems>                                            SortR  285
            DO  LI=1,NumItems                                                   SortR  286
              Knx = <li;List>                                                   SortR  287
              Jcd = <nx;Component>                                              SortR  288
              IF (<cd:TYPE> .EQ. 3)  THEN                                       SortR  289
                Jrc = <cd:LIQUID-CKT>                                           SortR  290
                Jrs = <rc:/RefgSystem/>                                         SortR  291
                IF (<rs;Rank> .GT. 0)  THEN                                     SortR  292
                  MaxRank = MAX(MaxRank, <rs;Rank>)                             SortR  293
                ELSE                                                            SortR  294
                  EXIT                                                          SortR  295
                ENDIF                                                           SortR  296
              ENDIF                                                             SortR  297
            ENDDO                                                               SortR  298
            Jrs = Save                                                          SortR  299
            IF (MaxRank .GT. 0)  THEN                                           SortR  300
              <rs;Rank>     = MaxRank + 1                                       SortR  301
              AllRanksFound = .FALSE.                                           SortR  302
            ENDIF                                                               SortR  303
          ENDIF  ! rp;Rank                                                      SortR  304
          Jrs = <rs;Next>                                                       SortR  305
        ENDDO  ! Jrs                                                            SortR  306
      ENDDO  ! AllRanksFound                                                    SortR  307
c                                                                               SortR  308
c              Create of list of refrigeration systems, in order of rank.       SortR  309
c              Note that more than one system may have the same rank            SortR  310
      Rank          = 0                                                         SortR  311
      AllRanksFound = .FALSE.                                                   SortR  312
      DO WHILE (.NOT. AllRanksFound)                                            SortR  313
        Rank          = Rank + 1                                                SortR  314
        AllRanksFound = .TRUE.                                                  SortR  315
        Jrs = Irs                                                               SortR  316
        DO WHILE (Jrs .GT. 0)                                                   SortR  317
          IF (<rs;Rank> .EQ. Rank)  THEN                                        SortR  318
            AllRanksFound = .FALSE.                                             SortR  319
            CALL ListAdd(ListRefgPlants, Jrs)                                   SortR  320
          ENDIF                                                                 SortR  321
          Jrs = <rs;Next>                                                       SortR  322
        ENDDO  ! Jrs                                                            SortR  323
      ENDDO    ! RankFound                                                      SortR  324
c                                                                               SortR  325
c              Check components for circularities                               SortR  326
c              subcoolers                                                       SortR  327
      Jsc = Isc                                                                 SortR  328
      DO WHILE (Jsc .GT. 0)                                                     SortR  329
        IF (<sc;Rank> .EQ. 0)  THEN                                             SortR  330
          CALL MSGSIM(-1,II,II,II,II)                                           SortR  331
          WRITE (IOUTPT,9001)  (<sc:NAME>,II=1,8)                               SortR  332
          CALL MessageBox( NULL,                                                SortR  333
     &      'A component has a circularity'//char(10)//char(13)//               SortR  334
     &      'in its attachments'//char(0),                                      SortR  335
     &      'Refrigeration Errors'//char(0),                                    SortR  336
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SortR  337
          IwinReturn = 1                                                        SortR  338
        ENDIF                                                                   SortR  339
        Jsc = <sc;Next>                                                         SortR  340
      ENDDO                                                                     SortR  341
c              desuperheaters                                                   SortR  342
      Jds = Ids                                                                 SortR  343
      DO WHILE (Jds .GT. 0)                                                     SortR  344
        IF (<ds;Rank> .EQ. 0)  THEN                                             SortR  345
          CALL MSGSIM(-1,II,II,II,II)                                           SortR  346
          WRITE (IOUTPT,9001)  (<ds:NAME>,II=1,8)                               SortR  347
          CALL MessageBox( NULL,                                                SortR  348
     &      'A component has a circularity'//char(10)//char(13)//               SortR  349
     &      'in its attachments'//char(0),                                      SortR  350
     &      'Refrigeration Errors'//char(0),                                    SortR  351
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SortR  352
          IwinReturn = 1                                                        SortR  353
        ENDIF                                                                   SortR  354
        Jds = <ds;Next>                                                         SortR  355
      ENDDO                                                                     SortR  356
c              refg circuits                                                    SortR  357
      Jrc = Irc                                                                 SortR  358
      DO WHILE (Jrc .GT. 0)                                                     SortR  359
        IF (<rc;Rank> .EQ. 0)  THEN                                             SortR  360
          CALL MSGSIM(-1,II,II,II,II)                                           SortR  361
          WRITE (IOUTPT,9001)  (<rc:NAME>,II=1,8)                               SortR  362
          CALL MessageBox( NULL,                                                SortR  363
     &      'A component has a circularity'//char(10)//char(13)//               SortR  364
     &      'in its attachments'//char(0),                                      SortR  365
     &      'Refrigeration Errors'//char(0),                                    SortR  366
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SortR  367
          IwinReturn = 1                                                        SortR  368
        ENDIF                                                                   SortR  369
        Jrc = <rc;Next>                                                         SortR  370
      ENDDO                                                                     SortR  371
c              suction groups                                                   SortR  372
      Jsg = Isg                                                                 SortR  373
      DO WHILE (Jsg .GT. 0)                                                     SortR  374
        IF (<sg;Rank> .EQ. 0)  THEN                                             SortR  375
          CALL MSGSIM(-1,II,II,II,II)                                           SortR  376
          WRITE (IOUTPT,9001)  (<sg:NAME>,II=1,8)                               SortR  377
          CALL MessageBox( NULL,                                                SortR  378
     &      'A component has a circularity'//char(10)//char(13)//               SortR  379
     &      'in its attachments'//char(0),                                      SortR  380
     &      'Refrigeration Errors'//char(0),                                    SortR  381
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SortR  382
          IwinReturn = 1                                                        SortR  383
        ENDIF                                                                   SortR  384
        Jsg = <sg;Next>                                                         SortR  385
      ENDDO                                                                     SortR  386
c              refg-systems                                                     SortR  387
      Jrs = Irs                                                                 SortR  388
      DO WHILE (Jrs .GT. 0)                                                     SortR  389
        IF (<rs;Rank> .EQ. 0)  THEN                                             SortR  390
          CALL MSGSIM(-1,II,II,II,II)                                           SortR  391
          WRITE (IOUTPT,9001)  (<rs:NAME>,II=1,8)                               SortR  392
          CALL MessageBox( NULL,                                                SortR  393
     &      'A component has a circularity'//char(10)//char(13)//               SortR  394
     &      'in its attachments'//char(0),                                      SortR  395
     &      'Refrigeration Errors'//char(0),                                    SortR  396
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SortR  397
          IwinReturn = 1                                                        SortR  398
        ENDIF                                                                   SortR  399
        Jrs = <rs;Next>                                                         SortR  400
      ENDDO                                                                     SortR  401
c                                                                               SortR  402
      RETURN                                                                    SortR  403
c                                                                               SortR  404
 9001 FORMAT(14x,'A circular attachment was found for: ',8A4)                   SortR  405
      END                                                                       SortR  406
C ##############################################################################RCkAlg   2
C ##############################################################################RCkAlg   3
C ##############################################################################RCkAlg   4
C ##############################################################################RCkAlg   5
C ##########                                                          ##########RCkAlg   6
C ##########                  REFRIGERATION CIRCUITS                  ##########RCkAlg   7
C ##########                                                          ##########RCkAlg   8
C ##############################################################################RCkAlg   9
C ##############################################################################RCkAlg  10
C ##############################################################################RCkAlg  11
C ##############################################################################RCkAlg  12
c                                                                               RCkAlg  13
      SUBROUTINE RefgNetworkAlgs(Mode, Jna)                                     RCkAlg  14
c                                                                               RCkAlg  15
c              Selects the correct refrigerant circuit simulation               RCkAlg  16
c              algorithm. Since subcoolers and desuperheaters may               RCkAlg  17
c              be out in the circuit network, they are called from              RCkAlg  18
c              here                                                             RCkAlg  19
c                                                                               RCkAlg  20
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               RCkAlg  23
c                                                                               RCkAlg  24
      SELECT CASE (<na:ALGORITHM>)                                              RCkAlg  25
c                                                                               RCkAlg  26
c              Refg-circuits                                                    RCkAlg  27
        CASE (11)  ! Liquid circuit                                             RCkAlg  28
          CALL RefgCircuit_Liquid(Mode, Jna)                                    RCkAlg  29
        CASE (21)  ! Suction circuit                                            RCkAlg  30
          CALL RefgCircuit_Suction(Mode, Jna)                                   RCkAlg  31
        CASE (31)  ! Discharge circuit                                          RCkAlg  32
          CALL RefgCircuit_Discharge(Mode, Jna)                                 RCkAlg  33
c                                                                               RCkAlg  34
c              Subcoolers                                                       RCkAlg  35
        CASE (101)  ! Mechanical subcooler                                      RCkAlg  36
          CALL Subcooler_Mechanical(Mode, Jna)                                  RCkAlg  37
        CASE (102)  ! Flash                                                     RCkAlg  38
          CALL Subcooler_Flash(Mode, Jna)                                       RCkAlg  39
        CASE (103)  ! Evaporatively-cooled                                      RCkAlg  40
          CALL Subcooler_Economizer(Mode, Jna)                                  RCkAlg  41
c                                                                               RCkAlg  42
c              Desuperheaters                                                   RCkAlg  43
        CASE (201)  ! Liquid injection                                          RCkAlg  44
          CALL Desuperheater_Injection(Mode, Jna)                               RCkAlg  45
        CASE (202)  ! Refrigerant thru hx                                       RCkAlg  46
          CALL Desuperheater_RefgCooled(Mode, Jna)                              RCkAlg  47
        CASE (203)  ! Evaporatively cooled                                      RCkAlg  48
c         CALL Desuperheater_EvapCooled(Mode, Jna)                              RCkAlg  49
        CASE (204)  ! Air cooled                                                RCkAlg  50
c         CALL Desuperheater_AirCooled(Mode, Jna)                               RCkAlg  51
        CASE (205)  ! Water cooled                                              RCkAlg  52
c         CALL Desuperheater_WaterCooled(Mode, Jna)                             RCkAlg  53
c                                                                               RCkAlg  54
      END SELECT                                                                RCkAlg  55
c                                                                               RCkAlg  56
      RETURN                                                                    RCkAlg  57
      END                                                                       RCkAlg  58
      SUBROUTINE RefgNode(Knode, M,Mreqd, H, TminReqd,                          RfgNod   2
     &                           Pmin,Pmax, PminReqd,PmaxReqd)                  RfgNod   3
c                                                                               RfgNod   4
c              Sums a list of refrigerant Xnodes into a refrigerant node.       RfgNod   5
c                                                                               RfgNod   6
c              Knode     Pointer to the node                                    RfgNod   7
c              M         Total flow from Xnodes                                 RfgNod   8
c              Mreqd     Required flow from Xnodes                              RfgNod   9
c              H         Average enthalpy from Xnodes                           RfgNod  10
c              TminReqd  Minimum required temperature (subcooling)              RfgNod  11
c              Pmin      Lowest pressure from Xnodes                            RfgNod  12
c              Pmax      Highest pressure from Xnodes                           RfgNod  13
c              PminReqd  Lowest required pressure                               RfgNod  14
c              PmaxReqd  Highest required pressure                              RfgNod  15
c                                                                               RfgNod  16
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      DIMENSION  EndUse(18)                                                     /EndUse/ 2
      DATA       NumEndUses /18/                                                /EndUse/ 3
c                                                                               RfgNod  20
      LOGICAL    EndUses                                                        RfgNod  21
      REAL       M, Mneg, Mreqd, Mnode                                          RfgNod  22
c                                                                               RfgNod  23
      Krx = Knode                      ! node to be summed                      RfgNod  24
      Kli = <rx;Xnode>                 ! list of Xnodes                         RfgNod  25
c                                                                               RfgNod  26
c              Initialize outputs and end-use breakdown.                        RfgNod  27
      Q        = 0.                                                             RfgNod  28
      M        = 0.                                                             RfgNod  29
      Mneg     = 0.                                                             RfgNod  30
      Mreqd    = 0.                                                             RfgNod  31
      H        = 0.                                                             RfgNod  32
      RunFrac  = 0.                                                             RfgNod  33
      TminReqd =  88888.                                                        RfgNod  34
      Pmin     =  88888.                                                        RfgNod  35
      Pmax     = -88888.                                                        RfgNod  36
      PminReqd =  88888.                                                        RfgNod  37
      PmaxReqd = -88888.                                                        RfgNod  38
      IF (<rx;EndUse> .GT. 0)  THEN                                             RfgNod  39
        EndUses = .TRUE.                                                        RfgNod  40
        DO IE=1,NumEndUses                                                      RfgNod  41
          EndUse(IE) = 0.                                                       RfgNod  42
        ENDDO                                                                   RfgNod  43
      ELSE                                                                      RfgNod  44
        EndUses = .FALSE.                                                       RfgNod  45
      ENDIF                                                                     RfgNod  46
c                                                                               RfgNod  47
c              Loop thru all Xnodes in the list and get properties              RfgNod  48
      IF (Kli .EQ. 0)  RETURN                                                   RfgNod  49
      NumItems = <li;NumItems>                                                  RfgNod  50
      DO  LI=1,NumItems                                                         RfgNod  51
        Krx   = <li;List>                       ! Xnode                         RfgNod  52
        Mnode = <rx.Mrefg> * <rx;Multiplier>    ! Xnode flow                    RfgNod  53
        Qnode = <rx.Qrefg> * <rx;Multiplier>    ! Xnode load                    RfgNod  54
        IF (Mnode .GT. 0.)  THEN                                                RfgNod  55
          M    = M + Mnode                                                      RfgNod  56
          H    = H + Mnode * <rx.Hrefg>                                         RfgNod  57
          Q    = Q + Qnode                                                      RfgNod  58
          Pmin = MIN(Pmin, <rx.Prefg>)                                          RfgNod  59
          Pmax = MAX(Pmax, <rx.Prefg>)                                          RfgNod  60
c              Allocate load to end-use categories                              RfgNod  61
          IF (EndUses  .AND.  Qnode .NE. 0.)  THEN                              RfgNod  62
            IF (<rx;EndUse> .LE. NumEndUses)  THEN                              RfgNod  63
              EndUse(<rx;EndUse>) = EndUse(<rx;EndUse>) + Qnode                 RfgNod  64
            ELSE  ! node has multiple end-uses                                  RfgNod  65
              Keu = <rx;EndUse>                                                 RfgNod  66
              DO IE=1,NumEndUses                                                RfgNod  67
                EndUse(IE) = EndUse(IE)                                         RfgNod  68
     &                     + Qnode*<eu.1/TotalEU> * <eu.EndUses>                RfgNod  69
              ENDDO                                                             RfgNod  70
            ENDIF                                                               RfgNod  71
          ENDIF                                                                 RfgNod  72
c              fraction of the hour the node is active                          RfgNod  73
          IF (<rx.RunFrac> .gt. 0.) THEN                                        RfgNod  74
            Multiplier = <rx;Multiplier>                                        RfgNod  75
            DO  iMult=1,Multiplier                                              RfgNod  76
              RunFrac = Min(1., RunFrac + (1.-RunFrac)*<rx.RunFrac>)            RfgNod  77
            ENDDO                                                               RfgNod  78
          ELSE                                                                  RfgNod  79
c              Flow exists but RunFrac not set by node parent - assume 1.0      RfgNod  80
            RunFrac = 1.                                                        RfgNod  81
          ENDIF                                                                 RfgNod  82
        ELSE                                                                    RfgNod  83
c              zero or negative flow (hot-gas bypass, hot-gas defrost)          RfgNod  84
          Mneg = Mneg + Mnode                                                   RfgNod  85
        ENDIF                                                                   RfgNod  86
c              requested properties                                             RfgNod  87
        IF (<rx.Mreqd> .GT. 0.)  THEN                                           RfgNod  88
          Mreqd    = Mreqd + <rx.Mreqd> * <rx;Multiplier>                       RfgNod  89
          IF (<rx.Treqd> .GT. -888.)                                            RfgNod  90
     &      TminReqd = MIN(TminReqd, <rx.Treqd>)                                RfgNod  91
          IF (<rx.Preqd> .GT. -888.)  THEN                                      RfgNod  92
            PminReqd = MIN(PminReqd, <rx.Preqd>)                                RfgNod  93
            PmaxReqd = MAX(PmaxReqd, <rx.Preqd>)                                RfgNod  94
          ENDIF                                                                 RfgNod  95
        ENDIF                                                                   RfgNod  96
      ENDDO                                                                     RfgNod  97
                                                                                RfgNod  98
c              Average enthalpy - based on in-flows only                        RfgNod  99
      IF (M .GT. 0.)  H = H / M                                                 RfgNod 100
      M = M + Mneg                                                              RfgNod 101
                                                                                RfgNod 102
c              Required properties; for pressure drop calcs, the                RfgNod 103
c              required flow must be at least the actual                        RfgNod 104
      Mreqd = MAX(Mreqd, M)                                                     RfgNod 105
      IF (PminReqd .EQ. 88888.)  PminReqd = -88888.                             RfgNod 106
      IF (TminReqd .EQ. 88888.)  TminReqd = -88888.                             RfgNod 107
                                                                                RfgNod 108
c              Calc end-use breakdown                                           RfgNod 109
      Krx = Knode                                                               RfgNod 110
      <rx.Qrefg>   = Q                                                          RfgNod 111
      <rx.RunFrac> = RunFrac                                                    RfgNod 112
      CALL EndUseCategories(Krx, EndUse(1))                                     RfgNod 113
                                                                                RfgNod 114
c                                                                               RfgNod 115
      RETURN                                                                    RfgNod 116
      END                                                                       RfgNod 117
      SUBROUTINE RefgCircuit_Discharge(Mode, Jrc)                               RCktDi   2
c                                                                               RCktDi   3
c              Simulates a refrigerant circuit carrying hot gas                 RCktDi   4
c                                                                               RCktDi   5
c              Mode = 0-9  Attachment calculations                              RCktDi   6
c                      10  Design from downstream to upstream                   RCktDi   7
c                      11  Design from upstream to downstream                   RCktDi   8
c                      32  Simulate from upstream to downstream                 RCktDi   9
c                            Outlet M, T, H as f(inlet)                         RCktDi  10
c                      33  Simulate from downstream to upstream                 RCktDi  11
c                            Inlet P as f(outlet)                               RCktDi  12
c                                                                               RCktDi  13
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /HRREP / Irb, Ihrp, Lrb, Lhrp, Nrb, Nhrp, IVTLIM(3,50),           HRr      1
     &                 IGRPtr, IBRPtr, IRSch, IRSchT(5),                        HRr      2
     &                 NHRTyp(3), ITBUF(3), ITBUFB(3), ITBUFE(3),               HRr      3
     &                 IHREOF, ICDFLG                                           HRr      4
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
c                                                                               RCktDi  23
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               RCktDi  25
      INTEGER  Xro, rH                                                          RCktDi  26
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             RCktDi  27
      REAL     Mbypass                                                          RCktDi  28
c                                                                               RCktDi  29
c                                                                               RCktDi  30
c              Heat-reclaim holdback valves are always located at the           RCktDi  31
c              outlet end of the circuit.                                       RCktDi  32
c                                                                               RCktDi  33
      Kri = <rc;InletNode>               ! Inlet node                           RCktDi  34
      Kro = <rc;OutletNode>              ! Outlet node                          RCktDi  35
      Xro = <ro;Xnode>                   ! Xfaced outlet                        RCktDi  36
      Jre = <rc;Refrigerant>             ! Refrigerant                          RCktDi  37
c                                                                               RCktDi  38
      SELECT CASE (Mode)                                                        RCktDi  39
c                                                                               RCktDi  40
c                                                                               RCktDi  41
c ============ HOURLY SIMULATION - LOADS TO PLANT ============================= RCktDi  42
      CASE (31)                                                                 RCktDi  43
c                                                                               RCktDi  44
c              This call calculates the outlet flow, temperature, and           RCktDi  45
c              enthalpy as a function of the inlet conditions                   RCktDi  46
c                                                                               RCktDi  47
c              Check if iteration required                                      RCktDi  48
      IterNode = IterReqdNode(1, <rc;Nodes>)                                    RCktDi  49
      IF (.NOT. IterNode  .AND.                                                 RCktDi  50
     &    .NOT. IterReqdHsty(<rc;Hstys>))  RETURN                               RCktDi  51
c                                                                               RCktDi  52
c              Get the loads on this circuit                                    RCktDi  53
      CALL RefgNode(Kri, <ri.Minlet>,<ri.Mreqd>, <ri.Hinlet>, xTreqd,           RCktDi  54
     &                   xPmin,xPmax, xPminReqd,<ri.Preqd>)                     RCktDi  55
c              excessive hot-gas defrost may make flow negative                 RCktDi  56
      <ri.Minlet> = Max(0., <ri.Minlet>)                                        RCktDi  57
      <ri.Mreqd>  = Max(0., <ri.Mreqd>)                                         RCktDi  58
c              inlet load                                                       RCktDi  59
      <ri.Qinlet> = <ri.Minlet> * (<ri.Hinlet>-AA(<rc;RefgHrefPtr>))            RCktDi  60
c                                                                               RCktDi  61
c              Initialize outlet variables                                      RCktDi  62
      <ro.Moutlet> = <ri.Minlet>                                                RCktDi  63
      <ro.Mreqd>   = <ri.Mreqd>                                                 RCktDi  64
      <ro.Houtlet> = <ri.Hinlet>                                                RCktDi  65
      <ro.Preqd>   = <ri.Preqd>                                                 RCktDi  66
                                                                                RCktDi  67
c              Fraction of hour cycling equipment runs. If no flow, set         RCktDi  68
c              local variable to 1.0 to avoid divide-by-zero                    RCktDi  69
      <ro.RunFrac> = <ri.RunFrac>                                               RCktDi  70
      IF (<ro.RunFrac> .gt. 0.) THEN                                            RCktDi  71
        RunFrac = <ro.RunFrac>                                                  RCktDi  72
      ELSE                                                                      RCktDi  73
        RunFrac = 1.                                                            RCktDi  74
      ENDIF                                                                     RCktDi  75
c                                                                               RCktDi  76
c              Heat reclaim - assumed at inlet                                  RCktDi  77
      IF (<rc;HtRecFlag> .GT. 0)  THEN                                          RCktDi  78
        Krx = <rc;HtRecNode>                                                    RCktDi  79
c              Maximum available refrigerant flow, limited to 80% of            RCktDi  80
c              actual to ensure condenser control and sufficient liquid         RCktDi  81
c              pressure                                                         RCktDi  82
        <rx.MaxMrefg> = <ri.Minlet> * 0.8                                       RCktDi  83
c              Get amount actually used                                         RCktDi  84
        CALL RefgNode(Krx, <rx.Mrefg>,<rx.Mreqd>, <rx.Hrefg>, xTreqd,           RCktDi  85
     &                     xPmin,xPmax, xPminReqd,<rx.Preqd>)                   RCktDi  86
        IF (<rx.Mreqd> .GT. 0.)  THEN                                           RCktDi  87
c              limit mass flow to available                                     RCktDi  88
          <rx.Mrefg> = MIN(<ri.Minlet>, <rx.Mrefg>)                             RCktDi  89
          <rx.Qrefg> = <rx.Mrefg> * (<rx.Hrefg> - <ri.Hinlet>)                  RCktDi  90
c              Adjust outlet conditions for heat recovery                       RCktDi  91
          IF (<ro.Moutlet> .GT. 0.)  THEN                                       RCktDi  92
            Mbypass      = <ro.Moutlet> - <rx.Mrefg>                            RCktDi  93
            <ro.Houtlet> = (<ro.Houtlet>*Mbypass                                RCktDi  94
     &                           + <rx.Hrefg>*<rx.Mrefg>) / <ro.Moutlet>        RCktDi  95
          ENDIF                                                                 RCktDi  96
c              if no holdback valve, pass on required pressure for              RCktDi  97
c              condenser load-reset control strategy                            RCktDi  98
          IF (<rc:HOLDBACK-CTRL> .EQ. 0.  .and.  <rs:HTREC-CTRL> .eq. 3)        RCktDi  99
     &      <ro.Preqd> = MAX(<ro.Preqd>, <rx.Preqd>)                            RCktDi 100
        ENDIF                                                                   RCktDi 101
c              adjust required pressure for pressure drop thru valve            RCktDi 102
        IF (<ro.Preqd> .GT. -888.)  THEN                                        RCktDi 103
          Vinlet = RefgV_fPH(Jre, <ro.Preqd>, <ri.Hinlet>)                      RCktDi 104
          dP     = (<ro.Mreqd>/RunFrac*<rc;1/DesignFlow>)**1.87                 RCktDi 105
     &           * (Vinlet*<rc;DesignInletD>)**1.6                              RCktDi 106
          IF (<rc:BYPASS-DP> .EQ. 0.)  THEN                                     RCktDi 107
c              holdback valve when fully open                                   RCktDi 108
            dP = <rc:VALVE-DP> * dP                                             RCktDi 109
          ELSE   ! bypass valve                                                 RCktDi 110
            dP = <rc:BYPASS-DP> * dP                                            RCktDi 111
          ENDIF                                                                 RCktDi 112
          <ro.Preqd> = <ro.Preqd> - dP                                          RCktDi 113
        ENDIF                                                                   RCktDi 114
      ENDIF  ! rc;HtRecFlag                                                     RCktDi 115
c                                                                               RCktDi 116
c              Enthalpy change due to thermal gains.  Currently, this           RCktDi 117
c              is simulated as a fixed temperature rise all hours               RCktDi 118
c              Get specific heat of fluid entering circuit                      RCktDi 119
      IF (<rc:THERMAL-DT> .NE. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN            RCktDi 120
        Cp            = RefgCp_Vapor_fP(Jre, <ri.Pinlet>)                       RCktDi 121
        dH            = Cp * <rc:THERMAL-DT>                                    RCktDi 122
        <ro.Houtlet>  = <ro.Houtlet> + dH                                       RCktDi 123
        <rc.Qconduct> = <ro.Moutlet> * dH                                       RCktDi 124
      ELSE                                                                      RCktDi 125
        <rc.Qconduct> = 0.                                                      RCktDi 126
      ENDIF                                                                     RCktDi 127
c                                                                               RCktDi 128
c              Required outlet pressure                                         RCktDi 129
      IF (<ro.Mreqd> .GT. 0.)  THEN                                             RCktDi 130
        IF (<ro.Preqd> .LT. -888.)  THEN                                        RCktDi 131
          <ro.Preqd> = -88888.                                                  RCktDi 132
        ELSE                                                                    RCktDi 133
          Voutlet = RefgV_fPH(Jre, <ro.Poutlet>, <ro.Houtlet>)                  RCktDi 134
          dP      = (<ro.Mreqd>/RunFrac*<rc;1/DesignFlow> )**1.87               RCktDi 135
     &            * (Voutlet*<rc;DesignOutletD>)**1.6                           RCktDi 136
          dP      = <rc;dPfriction> * dP                                        RCktDi 137
          <ro.Preqd> = <ro.Preqd> + dP                                          RCktDi 138
        ENDIF                                                                   RCktDi 139
      ENDIF                                                                     RCktDi 140
c                                                                               RCktDi 141
      CALL CnvgCheck(1, <rc;PlantHsty>)                                         RCktDi 142
c                                                                               RCktDi 143
      <ro.Qoutlet> = <ro.Moutlet> * (<ro.Houtlet>-AA(<rc;RefgHrefPtr>))         RCktDi 144
c                                                                               RCktDi 145
c                                                                               RCktDi 146
c ============ HOURLY SIMULATION - PLANT TO LOADS ============================= RCktDi 147
      CASE (32)                                                                 RCktDi 148
c                                                                               RCktDi 149
c              This call calculates the inlet pressure as a function of         RCktDi 150
c              the outlet conditions                                            RCktDi 151
c                                                                               RCktDi 152
c              Check if iteration required                                      RCktDi 153
      IterNode = IterReqdNode(1, <rc;Nodes>)                                    RCktDi 154
      IF (.NOT. IterNode  .AND.                                                 RCktDi 155
     &    .NOT. IterReqdHsty(<rc;Hstys>))  RETURN                               RCktDi 156
c                                                                               RCktDi 157
      IF (<ro.RunFrac> .gt. 0.) THEN                                            RCktDi 158
        RunFrac = <ro.RunFrac>                                                  RCktDi 159
      ELSE                                                                      RCktDi 160
        RunFrac = 1.                                                            RCktDi 161
      ENDIF                                                                     RCktDi 162
                                                                                RCktDi 163
c              Get the downstream conditions                                    RCktDi 164
      <ro.Poutlet> = <Xro.Poutlet>                                              RCktDi 165
c                                                                               RCktDi 166
c              Pressure drop through circuit and inlet pressure                 RCktDi 167
      Voutlet     = RefgV_fPH(Jre, <ro.Poutlet>, <ro.Houtlet>)                  RCktDi 168
      dP          = (<ro.Moutlet>/RunFrac*<rc;1/DesignFlow>)**1.87              RCktDi 169
     &            * (Voutlet*<rc;DesignOutletD>)**1.6                           RCktDi 170
      dP          = <rc;dPfriction> * dP                                        RCktDi 171
      <ri.Pinlet> = Max(<re;Pmin>, <ro.Poutlet>+dP)                             RCktDi 172
c                                                                               RCktDi 173
c              Heat reclaim                                                     RCktDi 174
      IF (<rc;HtRecFlag> .EQ. 0)  THEN                                          RCktDi 175
        <ri.Pinlet>  = <ro.Poutlet>                                             RCktDi 176
      ELSE  ! heat reclaim                                                      RCktDi 177
        Krx = <rc;HtRecNode>                                                    RCktDi 178
c              Pressure drop thru valve                                         RCktDi 179
        Vinlet = RefgV_fPH(Jre, <ri.Pinlet>, <ri.Hinlet>)                       RCktDi 180
        dP     = (<ri.Minlet>/RunFrac*<rc;1/DesignFlow>)**1.87                  RCktDi 181
     &         * (Vinlet*<rc;DesignInletD>)**1.6                                RCktDi 182
        IF (<rx.Mreqd> .GT. 0.  .OR.  <rc:BYPASS-DP> .EQ. 0.)  THEN             RCktDi 183
c              holdback valve when fully open                                   RCktDi 184
          dP = <rc:VALVE-DP> * dP                                               RCktDi 185
        ELSE   ! bypass valve                                                   RCktDi 186
          dP = <rc:BYPASS-DP> * dP                                              RCktDi 187
        ENDIF                                                                   RCktDi 188
        <ri.Pinlet> = <ri.Pinlet> + dP                                          RCktDi 189
c              Adjust holdback pressure according to control strategy           RCktDi 190
        Psetpt = <ri.Pinlet>                                                    RCktDi 191
        SELECT CASE (<rc:HOLDBACK-CTRL>)                                        RCktDi 192
          CASE (0)  ! No holdback - only 3-way diverting valve                  RCktDi 193
          CASE (1)  ! Always                                                    RCktDi 194
            Psetpt =  <rc;HoldbackSetpt>                                        RCktDi 195
          CASE (2)  ! On demand                                                 RCktDi 196
            IF (<rx.Mreqd> .GT. 0.)  Psetpt = <rc;HoldbackSetpt>                RCktDi 197
          CASE (3)  ! Scheduled                                                 RCktDi 198
            SchV = SchVal(<rc:HOLDBACK-SCH>)                                    RCktDi 199
c              check for OA temp limit                                          RCktDi 200
            IF (SchV .NE. 0.  .AND.  SchV .NE. 1.                               RCktDi 201
     &                        .AND.  DBT .LT. SchV)  SchV = 1.                  RCktDi 202
            IF (SchV .EQ. 1.)  Psetpt = <rc;HoldbackSetpt>                      RCktDi 203
          CASE (4)  ! OA reset                                                  RCktDi 204
            Tsetpt = DrsVal(<rc:HOLDBACK-RESE>)                                 RCktDi 205
            Psetpt = RefgP_fT(Jre, Tsetpt)                                      RCktDi 206
          CASE (5)  ! Load reset                                                RCktDi 207
            Psetpt = <rx.Preqd>                                                 RCktDi 208
        END SELECT                                                              RCktDi 209
        <ri.Pinlet> = MAX(<ri.Pinlet>, Psetpt)                                  RCktDi 210
        <ri.Tinlet> = RefgT_fPH(Jre, <ri.Pinlet>, <ri.Hinlet>)                  RCktDi 211
      ENDIF  ! rc;HtRecFlag                                                     RCktDi 212
c                                                                               RCktDi 213
c              Check for convergence; set Xnode flags if not                    RCktDi 214
      CALL CnvgCheck(1, <rc;LoadHsty>)                                          RCktDi 215
c                                                                               RCktDi 216
c                                                                               RCktDi 217
c ============ REPORT CREATION ================================================ RCktDi 218
      CASE (50)                                                                 RCktDi 219
c                                                                               RCktDi 220
c              statistics blocks                                                RCktDi 221
      Ks2Sup    = NewStat2(Kro,  <+ro.Moutlet>,  0, 1.)                         RCktDi 222
      Ks5SupBin = NewStat5(Kro,  <+ro.Moutlet>,  0, 1.)                         RCktDi 223
      Ks2Gain   = NewStat2(Jrc, <+rc.Qconduct>,  1, 1.)                         RCktDi 224
      Ks2Loss   = NewStat2(Jrc, <+rc.Qconduct>, -1, 1.)                         RCktDi 225
      Ks2Rcvr   = NewStat2(<rc;HtRecNode>, <+rx.Qrefg>, 0, 1.)                  RCktDi 226
c                                                                               RCktDi 227
c              Create the type "H" report                                       RCktDi 228
      IF (<rc:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      RCktDi 229
     &  <rc;PS-H> = NewReport_H(Jrc, 130,                                       RCktDi 230
     &                          4, 5, 6,                                        RCktDi 231
     &                          Ks2Sup, Ks2Gain, Ks2Loss, Ks2Rcvr,              RCktDi 232
     &                          Ks5SupBin, 0, 0,                                RCktDi 233
     &                          0, 0, 0)                                        RCktDi 234
c                                                                               RCktDi 235
c                                                                               RCktDi 236
c ============ REPORT ORDER =================================================== RCktDi 237
      CASE (52)                                                                 RCktDi 238
c                                                                               RCktDi 239
      Call Report_H(Mode, <rc;PS-H>)                                            RCktDi 240
c                                                                               RCktDi 241
c                                                                               RCktDi 242
c ============ REPORTS - VERIFICATION DATA ==================================== RCktDi 243
      CASE (54)                                                                 RCktDi 244
c                                                                               RCktDi 245
c              Output design information                                        RCktDi 246
      IF (<rc;PS-H> .ne. 0)  THEN                                               RCktDi 247
        rH = <rc;PS-H>                                                          RCktDi 248
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       RCktDi 249
        CALL GetAttachments(Jrc, 2)                                             RCktDi 250
        WRITE (IREPFL)  23,<rH;Iuniq>,1,2,19,                                   RCktDi 251
     &    (NameAttachments(II,1,1),II=1,8),                                     RCktDi 252
     &    (NameAttachments(II,1,2),II=1,8),                                     RCktDi 253
     &    <ri.Minlet>,<rc:THERMAL-DT>,<rc:FRICTION-DT>                          RCktDi 254
        DO  Irow=2,NumRowsOfAttachments                                         RCktDi 255
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 RCktDi 256
     &      (NameAttachments(II,Irow,1),II=1,8),                                RCktDi 257
     &      (NameAttachments(II,Irow,2),II=1,8)                                 RCktDi 258
        ENDDO                                                                   RCktDi 259
      ENDIF                                                                     RCktDi 260
c                                                                               RCktDi 261
c                                                                               RCktDi 262
c ============ HOURLY REPORTS - HOURLY DATA =================================== RCktDi 263
      CASE (62)                                                                 RCktDi 264
c                                                                               RCktDi 265
      IF (<rc;HourRepBuf> .EQ. 0)  RETURN                                       RCktDi 266
c                                                                               RCktDi 267
      IAptr = <rc;HourRepBuf> - 1                                               RCktDi 268
c                                                                               RCktDi 269
      AA(IAptr+ 1) = (<ro.Houtlet>-<ri.Hinlet>) * <ri.Minlet>                   RCktDi 270
      AA(IAptr+ 2) = <ro.Houtlet> - <ri.Hinlet>                                 RCktDi 271
      AA(IAptr+ 3) = <ro.Poutlet> - <ri.Pinlet>                                 RCktDi 272
      AA(IAptr+ 4) = <ri.Qinlet>                                                RCktDi 273
      AA(IAptr+ 5) = <ri.Minlet>                                                RCktDi 274
      AA(IAptr+ 6) = <ri.Mreqd>                                                 RCktDi 275
      AA(IAptr+ 7) = <ri.Tinlet>                                                RCktDi 276
      AA(IAptr+ 8) = <ri.Treqd>                                                 RCktDi 277
      AA(IAptr+ 9) = <ri.Pinlet>                                                RCktDi 278
      AA(IAptr+10) = <ri.Preqd>                                                 RCktDi 279
      AA(IAptr+11) = <ri.Hinlet>                                                RCktDi 280
      AA(IAptr+12) = <ro.Qoutlet>                                               RCktDi 281
      AA(IAptr+13) = <ro.Moutlet>                                               RCktDi 282
      AA(IAptr+14) = <ro.Mreqd>                                                 RCktDi 283
      AA(IAptr+15) = <ro.Toutlet>                                               RCktDi 284
      AA(IAptr+16) = <ro.Treqd>                                                 RCktDi 285
      AA(IAptr+17) = <ro.Poutlet>                                               RCktDi 286
      AA(IAptr+18) = <ro.Preqd>                                                 RCktDi 287
      AA(IAptr+19) = <ro.Houtlet>                                               RCktDi 288
c                                                                               RCktDi 289
      IF (<rc;HtRecFlag> .gt. 0)  THEN                                          RCktDi 290
        Krx          = <rc;HtRecNode>                                           RCktDi 291
        AA(IAptr+20) = <rx.Qrefg>                                               RCktDi 292
        AA(IAptr+21) = <rx.Mrefg>                                               RCktDi 293
        AA(IAptr+22) = <rx.Mreqd>                                               RCktDi 294
        AA(IAptr+23) = <rx.Trefg>                                               RCktDi 295
        AA(IAptr+24) = <rx.Treqd>                                               RCktDi 296
        AA(IAptr+25) = <rx.Prefg>                                               RCktDi 297
        AA(IAptr+26) = <rx.Preqd>                                               RCktDi 298
        AA(IAptr+27) = <rx.Hrefg>                                               RCktDi 299
        AA(IAptr+28) = RefgT_fP(Jre, <rx.Prefg>)                                RCktDi 300
      ENDIF                                                                     RCktDi 301
c                                                                               RCktDi 302
c                                                                               RCktDi 303
c ============ DESIGN CALCULATIONS - LOADS TO PLANT =========================== RCktDi 304
      CASE (111)                                                                RCktDi 305
c                                                                               RCktDi 306
c              This call calculates the design outlet flow, temperature,        RCktDi 307
c              and enthalpy as a function of the inlet conditions               RCktDi 308
c                                                                               RCktDi 309
c              Design quantities from upstream loads                            RCktDi 310
      CALL RefgNode(Kri, <rc;DesignFlow>,xMreqd, <ri.Hinlet>, xTreqd,           RCktDi 311
     &                   xPmin,xPmax, xPminReqd,xPmaxReqd)                      RCktDi 312
c              design inlet temperature                                         RCktDi 313
      <ri.Tinlet> = RefgT_fPH(Jre, <ri.Pinlet>, <ri.Hinlet>)                    RCktDi 314
c                                                                               RCktDi 315
c              design flow                                                      RCktDi 316
      IF (<rc:FLOW> .GT. 0.)  THEN                                              RCktDi 317
        <ri.Minlet> = <rc:FLOW>                                                 RCktDi 318
      ELSE                                                                      RCktDi 319
        <ri.Minlet> = <rc;DesignFlow>                                           RCktDi 320
      ENDIF                                                                     RCktDi 321
      <ro.Moutlet> = <ri.Minlet>                                                RCktDi 322
      <ro.Mreqd>   = <ri.Minlet>                                                RCktDi 323
      <ri.Qinlet>  = <ri.Minlet> * (<ri.Hinlet>-AA(<rc;RefgHrefPtr>))           RCktDi 324
      <ro.Houtlet> = <ri.Hinlet>                                                RCktDi 325
c                                                                               RCktDi 326
c              Thermal gains                                                    RCktDi 327
      IF (<rc:THERMAL-DT> .NE. 0.)  THEN                                        RCktDi 328
c              specific heat, enthalpy and load                                 RCktDi 329
        Cp           = RefgCp_Vapor_fP(Jre, <ro.Poutlet>)                       RCktDi 330
        dH           = Cp * <rc:THERMAL-DT>                                     RCktDi 331
        <ro.Houtlet> = <ro.Houtlet> + dH                                        RCktDi 332
      ENDIF                                                                     RCktDi 333
c              outlet load                                                      RCktDi 334
      <ro.Qoutlet> = <ro.Moutlet> * (<ro.Houtlet>-AA(<rc;RefgHrefPtr>))         RCktDi 335
c                                                                               RCktDi 336
c              Pressure drop                                                    RCktDi 337
      Pvalve       = <ri.Pinlet> - <rc;dPfriction>                              RCktDi 338
      <ro.Poutlet> = Pvalve - <rc:VALVE-DP>                                     RCktDi 339
c                                                                               RCktDi 340
c                                                                               RCktDi 341
c ============ DESIGN CALCULATIONS - PLANT TO LOADS =========================== RCktDi 342
      CASE (112)                                                                RCktDi 343
c                                                                               RCktDi 344
c              This call calculates the design inlet pressure as a              RCktDi 345
c              function of the outlet conditions                                RCktDi 346
c                                                                               RCktDi 347
c              Get the outlet pressure                                          RCktDi 348
      <ro.Poutlet> = <Xro.Poutlet>                                              RCktDi 349
c                                                                               RCktDi 350
c              Adjust for heat-reclaim holdback valve                           RCktDi 351
      IF (<rc;HtRecFlag> .GT. 0)  THEN                                          RCktDi 352
c              convert temperature setpoint to a pressure                       RCktDi 353
        IF (<rc:HOLDBACK-SETP> .ne. 0.)  THEN                                   RCktDi 354
          <rc;HoldbackSetpt> = RefgP_fT(Jre, <rc:HOLDBACK-SETP>)                RCktDi 355
          <ri.Pinlet> = MAX(<rc;HoldbackSetpt>,                                 RCktDi 356
     &                      <ro.Poutlet> + <rc:VALVE-DP>)                       RCktDi 357
        ELSE                                                                    RCktDi 358
          <ri.Pinlet> = <ro.Poutlet> + <rc:VALVE-DP>                            RCktDi 359
        ENDIF                                                                   RCktDi 360
      ELSE                                                                      RCktDi 361
        <ri.Pinlet> = <ro.Poutlet>                                              RCktDi 362
      ENDIF                                                                     RCktDi 363
c                                                                               RCktDi 364
c              piping pressure drop                                             RCktDi 365
      IF (<rc:FRICTION-DT> .GT. 0.)  THEN                                       RCktDi 366
c              convert from a temperature to a pressure                         RCktDi 367
        Pvalve      = <ri.Pinlet>                                               RCktDi 368
        SCToutlet   = RefgT_fP(Jre, <ri.Pinlet>)                                RCktDi 369
        SCTinlet    = SCToutlet + <rc:FRICTION-DT>                              RCktDi 370
        <ri.Pinlet> = RefgP_fT(Jre, SCTinlet)                                   RCktDi 371
c              pressure differential                                            RCktDi 372
        <rc;dPfriction> = <ri.Pinlet> - Pvalve                                  RCktDi 373
      ENDIF                                                                     RCktDi 374
c                                                                               RCktDi 375
c                                                                               RCktDi 376
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== RCktDi 377
      CASE (119)                                                                RCktDi 378
c                                                                               RCktDi 379
c              Check if flow is reasonable                                      RCktDi 380
      IF (<ri.Minlet> .EQ. 0.)  THEN                                            RCktDi 381
c              circuit has no flow                                              RCktDi 382
        IF (<ri;Xnode> .GT. 0)  THEN                                            RCktDi 383
          CALL MSGSIM(-2,II,II,II,II)                                           RCktDi 384
          WRITE (IOUTPT,9002)  (<rc:NAME>,II=1,8)                               RCktDi 385
        ENDIF                                                                   RCktDi 386
      ELSEIF (<rc:FLOW> .GT. 0.)  THEN                                          RCktDi 387
        IF (<rc:FLOW> .LT. <rc;DesignFlow>*0.95)  THEN                          RCktDi 388
c              user specified flow undersizes circuit                           RCktDi 389
          CALL MSGSIM(-3,II,II,II,II)                                           RCktDi 390
          WRITE (IOUTPT, 9003) (<rc:NAME>,II=1,8),                              RCktDi 391
     &                          <rc:FLOW>, <rc;DesignFlow>                      RCktDi 392
        ENDIF                                                                   RCktDi 393
      ENDIF                                                                     RCktDi 394
      <rc;DesignFlow> = <ri.Minlet>                                             RCktDi 395
      IF (<ri.Minlet> .GT. 0.)  <rc;1/DesignFlow> = 1.0/<ri.Minlet>             RCktDi 396
c                                                                               RCktDi 397
c              design volume and density                                        RCktDi 398
c              - at inlet                                                       RCktDi 399
      <rc;DesignInletV>  = RefgV_fPH(Jre, <ri.Pinlet>, <ri.Hinlet>)             RCktDi 400
      <rc;DesignInletD>  = 1.0 / <rc;DesignInletV>                              RCktDi 401
c              - upstream of heat reclaim valve                                 RCktDi 402
      Pvalve             = <ri.Pinlet> - <rc;dPfriction>                        RCktDi 403
      <rc;DesignValveV>  = RefgV_fPH(Jre, Pvalve, <ro.Houtlet>)                 RCktDi 404
      <rc;DesignValveD>  = 1.0 / <rc;DesignValveV>                              RCktDi 405
c              - at outlet                                                      RCktDi 406
      <rc;DesignOutletV> = RefgV_fPH(Jre, <ro.Poutlet>, <ro.Houtlet>)           RCktDi 407
      <rc;DesignOutletD> = 1.0 / <rc;DesignOutletV>                             RCktDi 408
c                                                                               RCktDi 409
c                                                                               RCktDi 410
c ============ ATTACHMENTS ==================================================== RCktDi 411
c                                                                               RCktDi 412
c              Initial attachments                                              RCktDi 413
      CASE (201)                                                                RCktDi 414
c              Component pointers, schedules, and curves                        RCktDi 415
        <rc:COST-DATA>     = Jcomponent(18, <rc:COST-DATA>)                     RCktDi 416
        <rc:/SuctionGroup> = Jcomponent(25, <rc:/SuctionGroup>)                 RCktDi 417
        <rc:/RefgSystem/>  = Jcomponent(29, <rc:/RefgSystem/>)                  RCktDi 418
        SELECT CASE (<rc:ATTACH-TO>)                                            RCktDi 419
          CASE (1)  ! Refg-system                                               RCktDi 420
            <rc:REFG-SYSTEM> = Jcomponent(29, <rc:REFG-SYSTEM>)                 RCktDi 421
          CASE (5)  ! Heat reclaim (future)                                     RCktDi 422
          CASE (6)  ! Refg-circuit                                              RCktDi 423
            <rc:TRUNK-CKT>   = Jcomponent(22, <rc:TRUNK-CKT>)                   RCktDi 424
        END SELECT  ! rc:ATTACH-TO                                              RCktDi 425
c              Heat reclaim attachments                                         RCktDi 426
        <rc:HOLDBACK-SCH>  = Jsched(<rc:HOLDBACK-SCH>)                          RCktDi 427
        <rc:HOLDBACK-RESE> = Jsched(<rc:HOLDBACK-RESE>)                         RCktDi 428
c                                                                               RCktDi 429
c              Create nodes                                                     RCktDi 430
      CASE (203)                                                                RCktDi 431
        Jrs = <rc:/RefgSystem/>                                                 RCktDi 432
        Keu = NewEndUse(Jrc)                                                    RCktDi 433
c              Circuit inlet and outlet                                         RCktDi 434
        SELECT CASE (<rc:ATTACH-TO>)                                            RCktDi 435
          CASE (1)  ! Refg-system                                               RCktDi 436
            Joutlet = <rc:REFG-SYSTEM>                                          RCktDi 437
          CASE (5)  ! Heat reclaim (future)                                     RCktDi 438
          CASE (6)  ! Refg-circuit                                              RCktDi 439
            Joutlet = <rc:TRUNK-CKT>                                            RCktDi 440
        END SELECT  ! rc:ATTACH-TO                                              RCktDi 441
        <rc;InletNode>  = NewNode(1, Jrs,0,Jrc,      0, 63,1,Keu, 1.)           RCktDi 442
        <rc;OutletNode> = NewNode(1, Jrs,0,Jrc,Joutlet, 63,2,Keu, 1.)           RCktDi 443
c                                                                               RCktDi 444
c              Thermal gains                                                    RCktDi 445
c quck                                                                          RCktDi 446
c       ZP1 = 0                                                                 RCktDi 447
c       <rc;LossNode> = NewNode(1, Jrs,0,Jrc,ZP1, 31,2,0, 1.)                   RCktDi 448
c              Heat reclaim attachments                                         RCktDi 449
        <rc;HtRecNode> = NewNode(1, Jrs,0,Jrc,0, 68,1,0, 1.)                    RCktDi 450
c                                                                               RCktDi 451
c              Links, lists                                                     RCktDi 452
      CASE (205)                                                                RCktDi 453
c              Get refrigerant pointer from refg plant                          RCktDi 454
        Jrs              = <rc:/RefgSystem/>                                    RCktDi 455
        <rc;Refrigerant> = <rs:REFRIGERANT>                                     RCktDi 456
c              Get pointer to reference enthalpy from liquid trunk              RCktDi 457
        <rc;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     RCktDi 458
c                                                                               RCktDi 459
c              List of nodes                                                    RCktDi 460
        CALL ListNodes(<rc;Nodes>, 0,0,Jrc,0, 0,0)                              RCktDi 461
c              heat recovery flag                                               RCktDi 462
        Krx = <rc;HtRecNode>                                                    RCktDi 463
        IF (<rx;Xnode> .GT. 0)  <rc;HtRecFlag> = 1                              RCktDi 464
c                                                                               RCktDi 465
c              Histories                                                        RCktDi 466
      CASE (208)                                                                RCktDi 467
c              Set up history on inlet conditions - set flags in inlet          RCktDi 468
c              Xnodes when not converged (does not require zone attached        RCktDi 469
c              to loss to re-iterate)                                           RCktDi 470
        Kli = 0                                                                 RCktDi 471
        CALL ListAdd(Kli, <ri;Xnode>)                                           RCktDi 472
c ??        Krx = <rc;HtRecNode>          ?? can add later once iterating       RCktDi 473
c ??        CALL ListAdd(Kli, <rx;Xnode>) ?? thru ahu's                         RCktDi 474
        Jrs           = <rc:/RefgSystem/>                                       RCktDi 475
        <rc;LoadHsty> = NewHistory(Jrs,0,Jrc, Kli, Kri,                         RCktDi 476
     &                    0, 0, 1.,                                             RCktDi 477
     &                    <#ri.Pinlet>, <sp:ERROR-P>, 1,                        RCktDi 478
     &                    0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)               RCktDi 479
c              Outlet history                                                   RCktDi 480
        <rc;PlantHsty> = NewHistory(Jrs,0,Jrc, <ro;Xnode>, Kro,                 RCktDi 481
     &                     0, 0, 1.,                                            RCktDi 482
     &                     <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                   RCktDi 483
     &                     <#ro.Houtlet>, <sp:ERROR-H>   , 1,                   RCktDi 484
     &                     <#ro.Preqd>  , <sp:ERROR-P>   , 1,                   RCktDi 485
     &                     0,0.,0, 0,0.,0, 0,0.,0)                              RCktDi 486
c                                                                               RCktDi 487
c              History lists                                                    RCktDi 488
      CASE (209)                                                                RCktDi 489
c              Component histories                                              RCktDi 490
        CALL ListHstys(<rc;Hstys>, 0, 0, Jrc)                                   RCktDi 491
c                                                                               RCktDi 492
c              Dump pointers                                                    RCktDi 493
      CASE (210)                                                                RCktDi 494
        IF (<rc;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         RCktDi 495
        WRITE (IOUTPT, 9202)  (<rc:NAME>,II=1,8),                               RCktDi 496
     &    Jrc, Kri, Kro, <rc;LossNode>, <rc;HtRecNode>                          RCktDi 497
c                                                                               RCktDi 498
c                                                                               RCktDi 499
      END SELECT  ! Mode                                                        RCktDi 500
c                                                                               RCktDi 501
      RETURN                                                                    RCktDi 502
c                                                                               RCktDi 503
c              Message formats                                                  RCktDi 504
 9002 FORMAT(14x,'Refg-Circuit: ',8A4,' has zero'                      /        RCktDi 505
     &       14x,'design refrigerant flow from its loads.'             )        RCktDi 506
 9003 FORMAT(14x,'Refg-Circuit: ',8A4,' has a specified'               /        RCktDi 507
     &       14x,'flow = ',F10.1,', but the design flow = ',F10.1      )        RCktDi 508
 9201 FORMAT(/' REFG-CIRCUITs                          Jrc       Kri',          RCktDi 509
     &'       Kro      Loss     HtRec'                                 /        RCktDi 510
     &1x,32('-'),5('  --------'))                                               RCktDi 511
 9202 FORMAT(1x,8A4,5I10)                                                       RCktDi 512
      END                                                                       RCktDi 513
      SUBROUTINE RefgCircuit_Liquid(Mode, Jrc)                                  RCktL    2
c                                                                               RCktL    3
c              Simulates a refrigerant circuit carrying liquid                  RCktL    4
c                                                                               RCktL    5
c              Mode =  0-9  Attachment calculations                             RCktL    6
c                       10  Design outlet T, P, H as f(inlet)                   RCktL    7
c                       11  Design inlet M, Preqd as f(outlet)                  RCktL    8
c                       32  Simulate from downstream to upstream                RCktL    9
c                             Inlet M and Preqd as f(outlet)                    RCktL   10
c                       33  Simulate from upstream to downstream                RCktL   11
c                             Outlet T, P, H as f(inlet)                        RCktL   12
c                                                                               RCktL   13
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               RCktL   22
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               RCktL   24
      INTEGER  Xri, rH                                                          RCktL   25
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             RCktL   26
c                                                                               RCktL   27
c                                                                               RCktL   28
c              Inlet, upstream of inlet, and outlet node pointers               RCktL   29
      Kri = <rc;InletNode>               ! inlet node                           RCktL   30
      Xri = <ri;Xnode>                   ! inlet Xnode                          RCktL   31
      Kro = <rc;OutletNode>              ! outlet node                          RCktL   32
      Jre = <rc;Refrigerant>             ! refrigerant                          RCktL   33
c                                                                               RCktL   34
      SELECT CASE (Mode)                                                        RCktL   35
c                                                                               RCktL   36
c                                                                               RCktL   37
c ============ HOURLY SIMULATION - LOADS TO PLANT ============================= RCktL   38
      CASE (31)                                                                 RCktL   39
c                                                                               RCktL   40
c              This call calculates the inlet mass flow rate and                RCktL   41
c              required pressure as a function of the outlet conditions.        RCktL   42
c                                                                               RCktL   43
c              Check if iteration required                                      RCktL   44
      IterNode = IterReqdNode(1, <rc;Nodes>)                                    RCktL   45
      IF (.NOT. IterNode  .AND.                                                 RCktL   46
     &    .NOT. IterReqdHsty(<rc;Hstys>))  RETURN                               RCktL   47
c                                                                               RCktL   48
c              Get the demands on this circuit                                  RCktL   49
      CALL RefgNode(Kro, <ro.Moutlet>,<ro.Mreqd>, xH, <ro.Treqd>,               RCktL   50
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     RCktL   51
      <ri.Minlet>  = <ro.Moutlet>                                               RCktL   52
                                                                                RCktL   53
c              Fraction of hour cycling equipment runs. If no flow, set         RCktL   54
c              local variable to 1.0 to avoid divide-by-zero                    RCktL   55
      <ri.RunFrac> = <ro.RunFrac>                                               RCktL   56
      IF (<ro.RunFrac> .gt. 0.) THEN                                            RCktL   57
        RunFrac = <ro.RunFrac>                                                  RCktL   58
      ELSE                                                                      RCktL   59
        RunFrac = 1.                                                            RCktL   60
      ENDIF                                                                     RCktL   61
c                                                                               RCktL   62
c              Requested properties                                             RCktL   63
      <ri.Mreqd> = <ro.Mreqd>                                                   RCktL   64
      IF (<ri.Mreqd> .GT. 0.)  THEN                                             RCktL   65
c              pressure                                                         RCktL   66
        IF (<ro.Preqd> .LT. -888.)  THEN                                        RCktL   67
          <ri.Preqd> = -88888.                                                  RCktL   68
        ELSE                                                                    RCktL   69
          dP = <rc;dPfriction>                                                  RCktL   70
     &       * (<ri.Mreqd>/RunFrac*<rc;1/DesignFlow>)**1.87                     RCktL   71
          <ri.Preqd> = MIN(<re;Pmax>, <ro.Preqd> + dP)                          RCktL   72
        ENDIF                                                                   RCktL   73
c              temperature - currently modeled as fixed                         RCktL   74
        IF (<ro.Treqd> .LT. -888.)  THEN                                        RCktL   75
          <ri.Treqd> = -88888.                                                  RCktL   76
        ELSE                                                                    RCktL   77
          <ri.Treqd> = MIN(<re;Tmax>, <ro.Treqd> - <rc:THERMAL-DT>)             RCktL   78
        ENDIF                                                                   RCktL   79
      ENDIF                                                                     RCktL   80
c                                                                               RCktL   81
      CALL CnvgCheck(1, <rc;PlantHsty>)                                         RCktL   82
c                                                                               RCktL   83
c                                                                               RCktL   84
c ============ HOURLY SIMULATION - PLANT TO LOADS ============================= RCktL   85
      CASE (32)                                                                 RCktL   86
c                                                                               RCktL   87
c              This call calculates the outlet temperature, pressure,           RCktL   88
c              and enthalpy as a function of the inlet conditions.              RCktL   89
c                                                                               RCktL   90
c              Check if iteration required                                      RCktL   91
      IterNode = IterReqdNode(1, <rc;Nodes>)                                    RCktL   92
      IF (.NOT. IterNode  .AND.                                                 RCktL   93
     &    .NOT. IterReqdHsty(<rc;Hstys>))  RETURN                               RCktL   94
c                                                                               RCktL   95
c              Get the upstream conditions                                      RCktL   96
      <ri.Pinlet> = <Xri.Pinlet>                                                RCktL   97
      <ri.Hinlet> = <Xri.Hinlet>                                                RCktL   98
      <ri.Qinlet>  = <ri.Minlet> * (<ri.Hinlet>-AA(<rc;RefgHrefPtr>))           RCktL   99
      <ro.Houtlet> = <ri.Hinlet>                                                RCktL  100
                                                                                RCktL  101
      IF (<ro.RunFrac> .gt. 0.) THEN                                            RCktL  102
        RunFrac = <ro.RunFrac>                                                  RCktL  103
      ELSE                                                                      RCktL  104
        RunFrac = 1.                                                            RCktL  105
      ENDIF                                                                     RCktL  106
c                                                                               RCktL  107
c              Piping friction                                                  RCktL  108
      dP = <rc;dPfriction>                                                      RCktL  109
     &   * (<ri.Minlet>/RunFrac*<rc;1/DesignFlow>)**1.87                        RCktL  110
      <ro.Poutlet> = <ri.Pinlet> - dP                                           RCktL  111
c                                                                               RCktL  112
c              Thermal gains - Currently, simulated as fixed                    RCktL  113
      IF (<rc:THERMAL-DT> .NE. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN            RCktL  114
        Cp           = RefgCp_Liquid_fP(Jre, <ro.Poutlet>)                      RCktL  115
        dH           = Cp * <rc:THERMAL-DT>                                     RCktL  116
        <ro.Houtlet> = <ro.Houtlet> + dH                                        RCktL  117
      ELSE                                                                      RCktL  118
        dH           = 0.                                                       RCktL  119
      ENDIF                                                                     RCktL  120
      <rc.Qconduct>  = <ro.Moutlet> * dH                                        RCktL  121
      <ro.Qoutlet>   = <ri.Qinlet> + <rc.Qconduct>                              RCktL  122
c                                                                               RCktL  123
c              Check for convergence; set outlet Xnode flags if not             RCktL  124
      CALL CnvgCheck(1, <rc;LoadHsty>)                                          RCktL  125
c                                                                               RCktL  126
c                                                                               RCktL  127
c ============ REPORT CREATION ================================================ RCktL  128
      CASE (50)                                                                 RCktL  129
c                                                                               RCktL  130
c              statistics blocks                                                RCktL  131
      Ks2Sup    = NewStat2(Kro,  <+ro.Moutlet>,  0, 1.)                         RCktL  132
      Ks5SupBin = NewStat5(Kro,  <+ro.Moutlet>,  0, 1.)                         RCktL  133
      Ks2Gain   = NewStat2(Jrc, <+rc.Qconduct>,  1, 1.)                         RCktL  134
      Ks2Loss   = NewStat2(Jrc, <+rc.Qconduct>, -1, 1.)                         RCktL  135
      Ks2Rcvr   = NewStat2(<rc;HtRecNode>, <+rx.Qrefg>, 0, 1.)                  RCktL  136
c                                                                               RCktL  137
c              Create the type "H" report                                       RCktL  138
      IF (<rc:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      RCktL  139
     &  <rc;PS-H> = NewReport_H(Jrc, 130,                                       RCktL  140
     &                          4, 5, 6,                                        RCktL  141
     &                          Ks2Sup, Ks2Gain, Ks2Loss, Ks2Rcvr,              RCktL  142
     &                          Ks5SupBin, 0, 0,                                RCktL  143
     &                          0, 0, 0)                                        RCktL  144
c                                                                               RCktL  145
c                                                                               RCktL  146
c ============ REPORT ORDER =================================================== RCktL  147
      CASE (52)                                                                 RCktL  148
c                                                                               RCktL  149
      Call Report_H(Mode, <rc;PS-H>)                                            RCktL  150
c                                                                               RCktL  151
c                                                                               RCktL  152
c ============ REPORTS - VERIFICATION DATA ==================================== RCktL  153
      CASE (54)                                                                 RCktL  154
c                                                                               RCktL  155
c              Output design information                                        RCktL  156
      IF (<rc;PS-H> .ne. 0)  THEN                                               RCktL  157
        rH = <rc;PS-H>                                                          RCktL  158
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       RCktL  159
        CALL GetAttachments(Jrc, 2)                                             RCktL  160
        WRITE (IREPFL)  23,<rH;Iuniq>,1,2,19,                                   RCktL  161
     &    (NameAttachments(II,1,1),II=1,8),                                     RCktL  162
     &    (NameAttachments(II,1,2),II=1,8),                                     RCktL  163
     &    <ri.Minlet>,<rc:THERMAL-DT>,<rc:FRICTION-DT>                          RCktL  164
        DO  Irow=2,NumRowsOfAttachments                                         RCktL  165
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 RCktL  166
     &      (NameAttachments(II,Irow,1),II=1,8),                                RCktL  167
     &      (NameAttachments(II,Irow,2),II=1,8)                                 RCktL  168
        ENDDO                                                                   RCktL  169
      ENDIF                                                                     RCktL  170
c                                                                               RCktL  171
c                                                                               RCktL  172
c ============ HOURLY REPORTS - HOURLY DATA =================================== RCktL  173
      CASE (62)                                                                 RCktL  174
c                                                                               RCktL  175
      IF (<rc;HourRepBuf> .EQ. 0)  RETURN                                       RCktL  176
c                                                                               RCktL  177
      IAptr = <rc;HourRepBuf> - 1                                               RCktL  178
c                                                                               RCktL  179
      AA(IAptr+ 1) = (<ro.Houtlet>-<ri.Hinlet>) * <ri.Minlet>                   RCktL  180
      AA(IAptr+ 2) = <ro.Houtlet> - <ri.Hinlet>                                 RCktL  181
      AA(IAptr+ 3) = <ro.Poutlet> - <ri.Pinlet>                                 RCktL  182
      AA(IAptr+ 4) = <ri.Qinlet>                                                RCktL  183
      AA(IAptr+ 5) = <ri.Minlet>                                                RCktL  184
      AA(IAptr+ 6) = <ri.Mreqd>                                                 RCktL  185
      AA(IAptr+ 7) = <ri.Tinlet>                                                RCktL  186
      AA(IAptr+ 8) = <ri.Treqd>                                                 RCktL  187
      AA(IAptr+ 9) = <ri.Pinlet>                                                RCktL  188
      AA(IAptr+10) = <ri.Preqd>                                                 RCktL  189
      AA(IAptr+11) = <ri.Hinlet>                                                RCktL  190
      AA(IAptr+12) = <ro.Qoutlet>                                               RCktL  191
      AA(IAptr+13) = <ro.Moutlet>                                               RCktL  192
      AA(IAptr+14) = <ro.Mreqd>                                                 RCktL  193
      AA(IAptr+15) = <ro.Toutlet>                                               RCktL  194
      AA(IAptr+16) = <ro.Treqd>                                                 RCktL  195
      AA(IAptr+17) = <ro.Poutlet>                                               RCktL  196
      AA(IAptr+18) = <ro.Preqd>                                                 RCktL  197
      AA(IAptr+19) = <ro.Houtlet>                                               RCktL  198
c                                                                               RCktL  199
c                                                                               RCktL  200
c ============ DESIGN CALCULATIONS - LOADS TO PLANT =========================== RCktL  201
      CASE (111)                                                                RCktL  202
c                                                                               RCktL  203
c              This call calculates the inlet mass flow rate and                RCktL  204
c              required pressure as a function of the outlet conditions.        RCktL  205
c                                                                               RCktL  206
c              Design mass flow of demanders                                    RCktL  207
      CALL RefgNode(Kro, <rc;DesignFlow>,xMreqd,xH, <ro.Treqd>,                 RCktL  208
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     RCktL  209
c                                                                               RCktL  210
c              design flow                                                      RCktL  211
      IF (<rc:FLOW> .GT. 0.)  THEN                                              RCktL  212
        <ro.Moutlet> = <rc:FLOW>                                                RCktL  213
      ELSE                                                                      RCktL  214
        <ro.Moutlet> = <rc;DesignFlow>                                          RCktL  215
      ENDIF                                                                     RCktL  216
      <ro.Mreqd> = <ro.Moutlet>                                                 RCktL  217
c                                                                               RCktL  218
c              Inlet conditions                                                 RCktL  219
      <ri.Minlet> = <ro.Moutlet>                                                RCktL  220
      <ri.Mreqd>  = <ro.Moutlet>                                                RCktL  221
      <ri.Treqd>  = <ro.Treqd> - <rc:THERMAL-DT>                                RCktL  222
      <ri.Preqd>  = <ro.Preqd> + <rc;dPfriction>                                RCktL  223
c                                                                               RCktL  224
c                                                                               RCktL  225
c ============ DESIGN CALCULATIONS - PLANT TO LOADS =========================== RCktL  226
      CASE (112)                                                                RCktL  227
c                                                                               RCktL  228
c              This call calculates the outlet temperature, pressure,           RCktL  229
c              and enthalpy as a function of the inlet conditions.              RCktL  230
c                                                                               RCktL  231
c              Get the upstream conditions, initialize outlet                   RCktL  232
      <ri.Pinlet> = <Xri.Pinlet>                                                RCktL  233
      <ri.Hinlet> = <Xri.Hinlet>                                                RCktL  234
c                                                                               RCktL  235
c              Piping friction - convert from T to P                            RCktL  236
      <ro.Poutlet> = <ri.Pinlet>                                                RCktL  237
      IF (<rc:FRICTION-DT> .GT. 0.)  THEN                                       RCktL  238
        SCTinlet        = RefgT_fP(Jre, <ri.Pinlet>)                            RCktL  239
        SCToutlet       = SCTinlet - <rc:FRICTION-DT>                           RCktL  240
        <ro.Poutlet>    = RefgP_fT(Jre, SCToutlet)                              RCktL  241
        <rc;dPfriction> = <ri.Pinlet> - <ro.Poutlet>                            RCktL  242
      ENDIF                                                                     RCktL  243
c                                                                               RCktL  244
c              Thermal gains - Currently, simulated as fixed                    RCktL  245
      <ro.Houtlet> = <ri.Hinlet>                                                RCktL  246
      IF (<rc:THERMAL-DT> .NE. 0.)  THEN                                        RCktL  247
        Cp           = RefgCp_Liquid_fP(Jre, <ro.Poutlet>)                      RCktL  248
        dH           = Cp * <rc:THERMAL-DT>                                     RCktL  249
        <ro.Houtlet> = <ro.Houtlet> + dH                                        RCktL  250
      ENDIF                                                                     RCktL  251
      <ro.Toutlet> = RefgT_fPH(Jre, <ro.Poutlet>, <ro.Houtlet>)                 RCktL  252
c                                                                               RCktL  253
c              check for convergence                                            RCktL  254
      CALL CnvgCheck(1, <rc;LoadHsty>)                                          RCktL  255
c                                                                               RCktL  256
c                                                                               RCktL  257
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== RCktL  258
      CASE (119)                                                                RCktL  259
c                                                                               RCktL  260
c              Should have loads attached                                       RCktL  261
      IF (<ro;Xnode> .EQ. 0)  THEN                                              RCktL  262
        CALL MSGSIM(-2,II,II,II,II)                                             RCktL  263
        WRITE (IOUTPT,9002)  (<rc:NAME>,II=1,8)                                 RCktL  264
      ENDIF                                                                     RCktL  265
c                                                                               RCktL  266
c              Check if flow is reasonable                                      RCktL  267
      IF (<ro.Moutlet> .EQ. 0.)  THEN                                           RCktL  268
        IF (<ro;Xnode> .GT. 0)  THEN                                            RCktL  269
c              No design flows                                                  RCktL  270
          CALL MSGSIM(-2,II,II,II,II)                                           RCktL  271
          WRITE (IOUTPT,9003)  (<rc:NAME>,II=1,8)                               RCktL  272
        ENDIF                                                                   RCktL  273
      ELSEIF (<rc:FLOW> .GT. 0.)  THEN                                          RCktL  274
        IF (<rc:FLOW> .LT. <rc;DesignFlow>*0.95)  THEN                          RCktL  275
c              User-specified flow is under designed                            RCktL  276
          CALL MSGSIM(-3,II,II,II,II)                                           RCktL  277
          WRITE (IOUTPT, 9004) (<rc:NAME>,II=1,8),                              RCktL  278
     &                          <rc:FLOW>, <rc;DesignFlow>                      RCktL  279
        ENDIF                                                                   RCktL  280
      ENDIF                                                                     RCktL  281
c                                                                               RCktL  282
      <rc;DesignFlow> = <ro.Moutlet>                                            RCktL  283
      IF (<ro.Moutlet> .GT. 0.)  <rc;1/DesignFlow> = 1.0/<ro.Moutlet>           RCktL  284
c                                                                               RCktL  285
c              Design density and volume                                        RCktL  286
c              - at outlet                                                      RCktL  287
      <rc;DesignOutletD> = RefgD_fP(Jre, <ro.Poutlet>)                          RCktL  288
      <rc;DesignOutletV> = 1.0 / <rc;DesignOutletD>                             RCktL  289
c              - at inlet                                                       RCktL  290
      <rc;DesignInletD>  = RefgD_fP(Jre, <Xri.Pinlet>)                          RCktL  291
      <rc;DesignInletV>  = 1.0 / <rc;DesignInletD>                              RCktL  292
c                                                                               RCktL  293
c                                                                               RCktL  294
c ============ ATTACHMENTS ==================================================== RCktL  295
c                                                                               RCktL  296
c              Initial attachments                                              RCktL  297
      CASE (201)                                                                RCktL  298
c              Component pointers, schedules, and curves                        RCktL  299
        <rc:COST-DATA>     = Jcomponent(18, <rc:COST-DATA>)                     RCktL  300
        <rc:/SuctionGroup> = Jcomponent(25, <rc:/SuctionGroup>)                 RCktL  301
        <rc:/RefgSystem/>  = Jcomponent(29, <rc:/RefgSystem/>)                  RCktL  302
        SELECT CASE (<rc:ATTACH-TO>)                                            RCktL  303
          CASE (1)  ! Refg-system                                               RCktL  304
            <rc:REFG-SYSTEM> = Jcomponent(29, <rc:REFG-SYSTEM>)                 RCktL  305
          CASE (3)  ! Subcooler                                                 RCktL  306
            <rc:SUBCOOLER>   = Jcomponent(23, <rc:SUBCOOLER>)                   RCktL  307
          CASE (6)  ! Refg-circuit                                              RCktL  308
            <rc:TRUNK-CKT>   = Jcomponent(22, <rc:TRUNK-CKT>)                   RCktL  309
        END SELECT  ! rc:ATTACH-TO                                              RCktL  310
c                                                                               RCktL  311
c              Create nodes                                                     RCktL  312
      CASE (203)                                                                RCktL  313
        Jrs = <rc:/RefgSystem/>                                                 RCktL  314
        Keu = NewEndUse(Jrc)                                                    RCktL  315
c                                                                               RCktL  316
c              Circuit inlet and outlet                                         RCktL  317
        SELECT CASE (<rc:ATTACH-TO>)                                            RCktL  318
          CASE (1)  ! Refg-system                                               RCktL  319
            Jinlet = <rc:REFG-SYSTEM>                                           RCktL  320
          CASE (3)  ! Subcooler                                                 RCktL  321
            Jinlet = <rc:SUBCOOLER>                                             RCktL  322
          CASE (6)  ! Refg-circuit                                              RCktL  323
            Jinlet = <rc:TRUNK-CKT>                                             RCktL  324
        END SELECT  ! rc:ATTACH-TO                                              RCktL  325
        <rc;InletNode>  = NewNode(1, Jrs,0,Jrc,Jinlet, 61,1,Keu, 1.)            RCktL  326
        <rc;OutletNode> = NewNode(1, Jrs,0,Jrc,     0, 61,2,Keu, 1.)            RCktL  327
c                                                                               RCktL  328
c              Thermal gains                                                    RCktL  329
c ??                                                                            RCktL  330
c        ZP1 = 0                                                                RCktL  331
c        <rc;LossNode> = NewNode(1, Jrs,0,Jrc,ZP1, 31,2,0, 1.)                  RCktL  332
c              Heat reclaim attachments                                         RCktL  333
        <rc;HtRecNode> = NewNode(1, Jrs,0,Jrc,0, 68,1,0, 1.)                    RCktL  334
c                                                                               RCktL  335
c              Links, lists                                                     RCktL  336
      CASE (205)                                                                RCktL  337
c              Get refrigerant pointer from refg plant                          RCktL  338
        Jrs              = <rc:/RefgSystem/>                                    RCktL  339
        <rc;Refrigerant> = <rs:REFRIGERANT>                                     RCktL  340
c              Get pointer to reference enthalpy from liquid trunk              RCktL  341
        <rc;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     RCktL  342
c                                                                               RCktL  343
c              List of nodes                                                    RCktL  344
        CALL ListNodes(<rc;Nodes>, 0,0,Jrc,0, 0,0)                              RCktL  345
c                                                                               RCktL  346
c              Histories                                                        RCktL  347
      CASE (208)                                                                RCktL  348
c              Set up history on outlet conditions - set flags in outlet        RCktL  349
c              Xnodes when not converged (does not require zone attached        RCktL  350
c              to loss to re-iterate)                                           RCktL  351
        Jrs           = <rc:/RefgSystem/>                                       RCktL  352
        <rc;LoadHsty> = NewHistory(Jrs,0,Jrc, <ro;Xnode>, Kro,                  RCktL  353
     &                    0, 0, 1.,                                             RCktL  354
     &                    <#ro.Houtlet>, <sp:ERROR-H>, 1,                       RCktL  355
     &                    <#ro.Poutlet>, <sp:ERROR-P>, 1,                       RCktL  356
     &                    0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                       RCktL  357
c              Inlet history                                                    RCktL  358
        <rc;PlantHsty> = NewHistory(Jrs,0,Jrc, <ri;Xnode>, Kri,                 RCktL  359
     &                     0, 0, 1.,                                            RCktL  360
     &                     <#ri.Minlet>, <sp:ERROR-FLOW>, 2,                    RCktL  361
     &                     <#ri.Mreqd> , <sp:ERROR-FLOW>, 2,                    RCktL  362
     &                     <#ri.Preqd> , <sp:ERROR-P>   , 1,                    RCktL  363
     &                     <#ri.Treqd> , <sp:ERROR-T>   , 1,                    RCktL  364
     &                     0,0.,0, 0,0.,0)                                      RCktL  365
c                                                                               RCktL  366
c              History lists                                                    RCktL  367
      CASE (209)                                                                RCktL  368
c              Component histories                                              RCktL  369
        CALL ListHstys(<rc;Hstys>, 0, 0, Jrc)                                   RCktL  370
c                                                                               RCktL  371
c              Dump pointers                                                    RCktL  372
      CASE (210)                                                                RCktL  373
        IF (<rc;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         RCktL  374
        WRITE (IOUTPT, 9202)  (<rc:NAME>,II=1,8),                               RCktL  375
     &    Jrc, Kri, Kro, <rc;LossNode>, <rc;HtRecNode>                          RCktL  376
c                                                                               RCktL  377
c                                                                               RCktL  378
      END SELECT  ! Mode                                                        RCktL  379
c                                                                               RCktL  380
      RETURN                                                                    RCktL  381
c                                                                               RCktL  382
c              Message formats                                                  RCktL  383
 9002 FORMAT(14x,'Refg-Circuit: ',8A4,' has no attached'               /        RCktL  384
     &       14x,'loads.'                                              )        RCktL  385
 9003 FORMAT(14x,'Refg-Circuit: ',8A4,' has zero'                      /        RCktL  386
     &       14x,'design refrigerant flow from its loads.'             )        RCktL  387
 9004 FORMAT(14x,'Refg-Circuit: ',8A4,' has a specified'               /        RCktL  388
     &       14x,'flow = ',F10.1,', but the design flow = ',F10.1      )        RCktL  389
 9201 FORMAT(/' REFG-CIRCUITs                          Jrc       Kri',          RCktL  390
     &'       Kro      Loss     HtRec'                                 /        RCktL  391
     &1x,32('-'),5('  --------'))                                               RCktL  392
 9202 FORMAT(1x,8A4,5I10)                                                       RCktL  393
      END                                                                       RCktL  394
      SUBROUTINE RefgCircuit_Suction(Mode, Jrc)                                 RCktS    2
c                                                                               RCktS    3
c              Simulates a refrigerant circuit carrying suction gas             RCktS    4
c                                                                               RCktS    5
c              Mode = 0-9  Attachment calculations                              RCktS    6
c                      10  Design outlet M, T, Preqd, H as f(inlet)             RCktS    7
c                      11  Design inlet P as f(outlet)                          RCktS    8
c                      32  Simulate from upstream to downstream                 RCktS    9
c                            Outlet M, T, Preqd, H as f(inlet)                  RCktS   10
c                      33  Simulate from downstream to upstream                 RCktS   11
c                            Inlet P as f(outlet)                               RCktS   12
c                                                                               RCktS   13
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /HRREP / Irb, Ihrp, Lrb, Lhrp, Nrb, Nhrp, IVTLIM(3,50),           HRr      1
     &                 IGRPtr, IBRPtr, IRSch, IRSchT(5),                        HRr      2
     &                 NHRTyp(3), ITBUF(3), ITBUFB(3), ITBUFE(3),               HRr      3
     &                 IHREOF, ICDFLG                                           HRr      4
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
c ?? debug                                                                      RCktS   21
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
c                                                                               RCktS   23
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               RCktS   25
      INTEGER  Xro, rH                                                          RCktS   26
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             RCktS   27
c                                                                               RCktS   28
c                                                                               RCktS   29
c              Evaporator pressure regulators are located at the                RCktS   30
c              outlet end of the circuit.                                       RCktS   31
c                                                                               RCktS   32
c              Inlet, outlet, and downstream node pointers                      RCktS   33
      Kri = <rc;InletNode>                 ! Refrigerant inlet                  RCktS   34
      Kro = <rc;OutletNode>                ! Refrigerant outlet                 RCktS   35
      Xro = <ro;Xnode>                     ! node'd outlet                      RCktS   36
      Jre = <rc;Refrigerant>               ! Refrigerant table                  RCktS   37
c                                                                               RCktS   38
      SELECT CASE (Mode)                                                        RCktS   39
c                                                                               RCktS   40
c                                                                               RCktS   41
c ============ HOURLY SIMULATION - LOADS TO SUCTION-GROUP ===================== RCktS   42
      CASE (31)                                                                 RCktS   43
c                                                                               RCktS   44
c              This call calculates the outlet mass flow rate,                  RCktS   45
c              temperature, required pressure, and enthalpy as a                RCktS   46
c              function of the inlet conditions                                 RCktS   47
c                                                                               RCktS   48
c              Check if iteration required                                      RCktS   49
      IterNode = IterReqdNode(1, <rc;Nodes>)                                    RCktS   50
      IF (.NOT. IterNode  .AND.                                                 RCktS   51
     &    .NOT. IterReqdHsty(<rc;Hstys>))  RETURN                               RCktS   52
                                                                                RCktS   53
c              Get the loads on this circuit.  Note that the pressure           RCktS   54
c              is the required pressure that will be passed downstream,         RCktS   55
c              not the actual inlet pressure                                    RCktS   56
      CALL RefgNode(Kri, <ri.Minlet>,<ri.Mreqd>, <ri.Hinlet>, xTreqd,           RCktS   57
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     RCktS   58
      <ri.Qinlet> = <ri.Minlet> * (<ri.Hinlet>-AA(<rc;RefgHrefPtr>))            RCktS   59
c                                                                               RCktS   60
c              Initialize the outlet conditions to be same as inlet             RCktS   61
      <ro.Moutlet> = <ri.Minlet>                                                RCktS   62
      <ro.Houtlet> = <ri.Hinlet>                                                RCktS   63
                                                                                RCktS   64
c              Fraction of hour cycling equipment runs. If no flow, set         RCktS   65
c              local variable to 1.0 to avoid divide-by-zero                    RCktS   66
      <ro.RunFrac> = <ri.RunFrac>                                               RCktS   67
      IF (<ro.RunFrac> .gt. 0.) THEN                                            RCktS   68
        RunFrac = <ro.RunFrac>                                                  RCktS   69
      ELSE                                                                      RCktS   70
        RunFrac = 1.                                                            RCktS   71
      ENDIF                                                                     RCktS   72
c                                                                               RCktS   73
c              Enthalpy change due to thermal gains.  Currently, this           RCktS   74
c              is simulated as a fixed temperature rise all hours               RCktS   75
      IF (<rc:THERMAL-DT> .NE. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN            RCktS   76
        Cp           = RefgCp_Vapor_fP(Jre, <ri.Pinlet>)                        RCktS   77
        dH           = Cp * <rc:THERMAL-DT>                                     RCktS   78
        <ro.Houtlet> = <ro.Houtlet> + dH                                        RCktS   79
      ELSE                                                                      RCktS   80
        dH           = 0.                                                       RCktS   81
      ENDIF                                                                     RCktS   82
      <rc.Qconduct> = <ro.Moutlet> * dH                                         RCktS   83
      <ro.Qoutlet>  = <ro.Moutlet> * (<ro.Houtlet>-AA(<rc;RefgHrefPtr>))        RCktS   84
c                                                                               RCktS   85
c              Requested properties                                             RCktS   86
      <ro.Mreqd> = <ri.Mreqd>                                                   RCktS   87
      IF (<ro.Mreqd> .GT. 0.)  THEN                                             RCktS   88
c              pressure                                                         RCktS   89
        IF (<rc:EPR-VALVE> .GT. 0)  THEN                                        RCktS   90
c              a branch line EPR sets pressure requirement                      RCktS   91
          Vepr = RefgV_fPH(Jre, <rc;EPRsetpt>, <ro.Houtlet>)                    RCktS   92
          dP   = <rc:VALVE-DP>                                                  RCktS   93
     &         * (<ro.Mreqd>/RunFrac*<rc;1/DesignFlow>)**1.87                   RCktS   94
     &         * (Vepr*<rc;DesignValveD>)**1.6                                  RCktS   95
          <ro.Preqd> = MAX(<re;Pmin>, <rc;EPRsetpt>-dP)                         RCktS   96
        ELSE                                                                    RCktS   97
c              no EPR - worst case load sets pressure requirement               RCktS   98
          IF (<ri.Preqd> .LT. -888.)  THEN                                      RCktS   99
            <ro.Preqd> = -88888.                                                RCktS  100
          ELSE                                                                  RCktS  101
            Treqd  = RefgT_fP(Jre, <ri.Preqd>)  ! ?? debug                      RCktS  102
            Vinlet = RefgV_fPH(Jre, <ri.Preqd>, <ri.Hinlet>)                    RCktS  103
            dP     = <rc;dPfriction>                                            RCktS  104
     &             * (<ro.Mreqd>/RunFrac*<rc;1/DesignFlow>)**1.87               RCktS  105
     &             * (Vinlet*<rc;DesignInletD>)**1.6                            RCktS  106
            <ro.Preqd> = MAX(<re;Pmin>, <ri.Preqd>-dP)                          RCktS  107
          ENDIF                                                                 RCktS  108
        ENDIF  ! rc:EPR-VALVE                                                   RCktS  109
      ENDIF  ! ro,Mreqd                                                         RCktS  110
c                                                                               RCktS  111
      CALL CnvgCheck(1, <rc;PlantHsty>)                                         RCktS  112
c                                                                               RCktS  113
c                                                                               RCktS  114
c ============ HOURLY SIMULATION - SUCTION-GROUP TO LOADS ===================== RCktS  115
      CASE (32)                                                                 RCktS  116
c                                                                               RCktS  117
c              This call calculates the inlet pressure as a function            RCktS  118
c              of the outlet pressure set by the suction group or               RCktS  119
c              downstream trunk circuit.                                        RCktS  120
c                                                                               RCktS  121
c              Check if iteration required                                      RCktS  122
      IterNode = IterReqdNode(1, <rc;Nodes>)                                    RCktS  123
      IF (.NOT. IterNode  .AND.                                                 RCktS  124
     &    .NOT. IterReqdHsty(<rc;Hstys>))  RETURN                               RCktS  125
c                                                                               RCktS  126
c              Initialize the inlet pressure to be same as outlet               RCktS  127
      <ri.Pinlet> = <Xro.Poutlet>                                               RCktS  128
                                                                                RCktS  129
      IF (<ro.RunFrac> .gt. 0.) THEN                                            RCktS  130
        RunFrac = <ro.RunFrac>                                                  RCktS  131
      ELSE                                                                      RCktS  132
        RunFrac = 1.                                                            RCktS  133
      ENDIF                                                                     RCktS  134
c                                                                               RCktS  135
c              Adjust for evaporator pressure regulator                         RCktS  136
      IF (<rc:EPR-VALVE> .GT. 0)  THEN                                          RCktS  137
c              Evaporator pressure regulator                                    RCktS  138
        Voutlet = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                   RCktS  139
        dP      = <rc:VALVE-DP>                                                 RCktS  140
     &          * ((<ro.Moutlet>/RunFrac*<rc;1/DesignFlow>)**1.87)              RCktS  141
     &          * ((Voutlet*<rc;DesignOutletD>)**1.6)                           RCktS  142
        <ri.Pinlet> = MAX(<Xro.Poutlet>+dP, <rc;EPRsetpt>)                      RCktS  143
      ENDIF                                                                     RCktS  144
c                                                                               RCktS  145
c              Adjust for friction (upstream of EPR)                            RCktS  146
      Vinlet = RefgV_fPH(Jre, <ri.Pinlet>, <ro.Houtlet>)                        RCktS  147
      dP     = <rc;dPfriction>                                                  RCktS  148
     &       * (<ro.Moutlet>/RunFrac*<rc;1/DesignFlow>)**1.87                   RCktS  149
     &       * (Vinlet*<rc;DesignValveD>)**1.6                                  RCktS  150
      <ri.Pinlet> = <ri.Pinlet> + dP                                            RCktS  151
c                                                                               RCktS  152
c              Check for convergence; set Xnode flags if not                    RCktS  153
      CALL CnvgCheck(1, <rc;LoadHsty>)                                          RCktS  154
c                                                                               RCktS  155
c                                                                               RCktS  156
c ============ REPORT CREATION ================================================ RCktS  157
      CASE (50)                                                                 RCktS  158
c                                                                               RCktS  159
c              statistics blocks                                                RCktS  160
      Ks2Sup    = NewStat2(Kro,  <+ro.Moutlet>,  0, 1.)                         RCktS  161
      Ks5SupBin = NewStat5(Kro,  <+ro.Moutlet>,  0, 1.)                         RCktS  162
      Ks2Gain   = NewStat2(Jrc, <+rc.Qconduct>,  1, 1.)                         RCktS  163
      Ks2Loss   = NewStat2(Jrc, <+rc.Qconduct>, -1, 1.)                         RCktS  164
      Ks2Rcvr   = NewStat2(<rc;HtRecNode>, <+rx.Qrefg>,  0, 1.)                 RCktS  165
c                                                                               RCktS  166
      IF (<rc:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      RCktS  167
     &  <rc;PS-H> = NewReport_H(Jrc, 130,                                       RCktS  168
     &                          4, 5, 6,                                        RCktS  169
     &                          Ks2Sup, Ks2Gain, Ks2Loss, Ks2Rcvr,              RCktS  170
     &                          Ks5SupBin, 0, 0,                                RCktS  171
     &                          0, 0, 0)                                        RCktS  172
c                                                                               RCktS  173
c                                                                               RCktS  174
c ============ REPORT ORDER =================================================== RCktS  175
      CASE (52)                                                                 RCktS  176
c                                                                               RCktS  177
      Call Report_H(Mode, <rc;PS-H>)                                            RCktS  178
c                                                                               RCktS  179
c                                                                               RCktS  180
c ============ REPORTS - VERIFICATION DATA ==================================== RCktS  181
      CASE (54)                                                                 RCktS  182
c                                                                               RCktS  183
c              Output design information                                        RCktS  184
      IF (<rc;PS-H> .ne. 0)  THEN                                               RCktS  185
        rH = <rc;PS-H>                                                          RCktS  186
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       RCktS  187
        CALL GetAttachments(Jrc, 2)                                             RCktS  188
        WRITE (IREPFL)  23,<rH;Iuniq>,1,2,19,                                   RCktS  189
     &    (NameAttachments(II,1,1),II=1,8),                                     RCktS  190
     &    (NameAttachments(II,1,2),II=1,8),                                     RCktS  191
     &    <ri.Minlet>,<rc:THERMAL-DT>,<rc:FRICTION-DT>                          RCktS  192
        DO  Irow=2,NumRowsOfAttachments                                         RCktS  193
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 RCktS  194
     &      (NameAttachments(II,Irow,1),II=1,8),                                RCktS  195
     &      (NameAttachments(II,Irow,2),II=1,8)                                 RCktS  196
        ENDDO                                                                   RCktS  197
      ENDIF                                                                     RCktS  198
c                                                                               RCktS  199
c                                                                               RCktS  200
c ============ HOURLY REPORTS - HOURLY DATA =================================== RCktS  201
      CASE (62)                                                                 RCktS  202
c                                                                               RCktS  203
      IF (<rc;HourRepBuf> .EQ. 0)  RETURN                                       RCktS  204
c                                                                               RCktS  205
c              Hourly report variables                                          RCktS  206
      <ri.Tinlet>  = RefgT_fPH(Jre, <ri.Pinlet>,   <ri.Hinlet>)                 RCktS  207
      <ro.Toutlet> = RefgT_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                RCktS  208
c                                                                               RCktS  209
      IAptr = <rc;HourRepBuf> - 1                                               RCktS  210
c                                                                               RCktS  211
      AA(IAptr+ 1) = (<ro.Houtlet>-<ri.Hinlet>) * <ri.Minlet>                   RCktS  212
      AA(IAptr+ 2) = <ro.Houtlet> - <ri.Hinlet>                                 RCktS  213
      AA(IAptr+ 3) = <ro.Poutlet> - <ri.Pinlet>                                 RCktS  214
      AA(IAptr+ 4) = <ri.Qinlet>                                                RCktS  215
      AA(IAptr+ 5) = <ri.Minlet>                                                RCktS  216
      AA(IAptr+ 6) = <ri.Mreqd>                                                 RCktS  217
      AA(IAptr+ 7) = <ri.Tinlet>                                                RCktS  218
      AA(IAptr+ 8) = <ri.Treqd>                                                 RCktS  219
      AA(IAptr+ 9) = <ri.Pinlet>                                                RCktS  220
      AA(IAptr+10) = <ri.Preqd>                                                 RCktS  221
      AA(IAptr+11) = <ri.Hinlet>                                                RCktS  222
      AA(IAptr+12) = <ro.Qoutlet>                                               RCktS  223
      AA(IAptr+13) = <ro.Moutlet>                                               RCktS  224
      AA(IAptr+14) = <ro.Mreqd>                                                 RCktS  225
      AA(IAptr+15) = <ro.Toutlet>                                               RCktS  226
      AA(IAptr+16) = <ro.Treqd>                                                 RCktS  227
      AA(IAptr+17) = <ro.Poutlet>                                               RCktS  228
      AA(IAptr+18) = <ro.Preqd>                                                 RCktS  229
      AA(IAptr+19) = <ro.Houtlet>                                               RCktS  230
c                                                                               RCktS  231
c                                                                               RCktS  232
c ============ DESIGN CALCULATIONS - INITIALIZATION =========================== RCktS  233
      CASE (110)                                                                RCktS  234
c                                                                               RCktS  235
c              Inlet pressure                                                   RCktS  236
      Jsg = <rc:/SuctionGroup>                                                  RCktS  237
      IF (<sg:DESIGN-SST> .EQ. -66666.)  THEN                                   RCktS  238
        SST = -30.                                                              RCktS  239
      ELSE                                                                      RCktS  240
        SST = <sg:DESIGN-SST>                                                   RCktS  241
      ENDIF                                                                     RCktS  242
      <ri.Pinlet> = RefgP_fT(Jre, SST)                                          RCktS  243
c                                                                               RCktS  244
c                                                                               RCktS  245
c ============ DESIGN CALCULATIONS - LOADS TO SUCTION-GROUP =================== RCktS  246
      CASE (111)                                                                RCktS  247
c                                                                               RCktS  248
c              This call calculates the design outlet mass flow rate,           RCktS  249
c              enthalpy, and required pressure as a function of the             RCktS  250
c              inlet conditions                                                 RCktS  251
c                                                                               RCktS  252
c              Design quantities from suppliers (at inlet)                      RCktS  253
      CALL RefgNode(Kri, <rc;DesignFlow>,xMreqd, <ri.Hinlet>, xTreqd,           RCktS  254
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     RCktS  255
c                                                                               RCktS  256
c              Design flow                                                      RCktS  257
      IF (<rc:FLOW> .GT. 0.)  THEN                                              RCktS  258
        <ri.Minlet> = <rc:FLOW>                                                 RCktS  259
      ELSE                                                                      RCktS  260
        <ri.Minlet> = <rc;DesignFlow>                                           RCktS  261
      ENDIF                                                                     RCktS  262
      <ro.Moutlet> = <ri.Minlet>                                                RCktS  263
      <ro.Houtlet> = <ri.Hinlet>                                                RCktS  264
      <ro.Mreqd>   = <ri.Minlet>                                                RCktS  265
      <ri.Qinlet>  = <ri.Minlet> * (<ri.Hinlet>-AA(<rc;RefgHrefPtr>))           RCktS  266
c                                                                               RCktS  267
c              Thermal gains                                                    RCktS  268
      IF (<rc:THERMAL-DT> .NE. 0.)  THEN                                        RCktS  269
        Cp           = RefgCp_Vapor_fP(Jre, <ri.Pinlet>)                        RCktS  270
        dH           = Cp * <rc:THERMAL-DT>                                     RCktS  271
        <ro.Houtlet> = <ro.Houtlet> + dH                                        RCktS  272
      ELSE                                                                      RCktS  273
        dH           = 0.                                                       RCktS  274
      ENDIF                                                                     RCktS  275
      <ro.Qoutlet> = <ro.Moutlet> * (<ro.Houtlet>-AA(<rc;RefgHrefPtr>))         RCktS  276
c                                                                               RCktS  277
c              Pass along the required pressure of the upstream loads,          RCktS  278
c              adjusted for pipe friction and EPR valve                         RCktS  279
      <ro.Preqd> = <ri.Preqd> - <rc;dPfriction>                                 RCktS  280
      IF (<rc:EPR-VALVE> .GT. 0)                                                RCktS  281
     &  <ro.Preqd> = MIN(<ro.Preqd>    - <rc:VALVE-DP>,                         RCktS  282
     &                   <rc;EPRsetpt> - <rc:VALVE-DP>)                         RCktS  283
c                                                                               RCktS  284
c                                                                               RCktS  285
c ============ DESIGN CALCULATIONS - SUCTION-GROUP TO LOADS =================== RCktS  286
      CASE (112)                                                                RCktS  287
c                                                                               RCktS  288
c              This call calculates the design inlet pressure as a              RCktS  289
c              function of the outlet conditions                                RCktS  290
c                                                                               RCktS  291
c              Initialize the inlet pressure to be same as outlet               RCktS  292
      <ri.Pinlet> = <Xro.Poutlet>                                               RCktS  293
c                                                                               RCktS  294
c              Adjust for evaporator pressure regulator                         RCktS  295
      IF (<rc:EPR-VALVE> .GT. 0)  THEN                                          RCktS  296
        IF (<rc:EPR-SETPT> .EQ. -66666.)  THEN                                  RCktS  297
c              default the setpoint                                             RCktS  298
          <rc;EPRsetpt> = <Xro.Poutlet> + <rc:VALVE-DP>                         RCktS  299
        ELSE                                                                    RCktS  300
c              convert setpoint from temperature to pressure                    RCktS  301
          <rc;EPRsetpt> = RefgP_fT(Jre, <rc:EPR-SETPT>)                         RCktS  302
        ENDIF                                                                   RCktS  303
        <ri.Pinlet> = MAX(<ri.Pinlet>+<rc:VALVE-DP>, <rc;EPRsetpt>)             RCktS  304
      ENDIF                                                                     RCktS  305
c                                                                               RCktS  306
c              Adjust for friction                                              RCktS  307
      IF (<rc:FRICTION-DT> .GT. 0.)  THEN                                       RCktS  308
        SSToutlet       = RefgT_fP(Jre, <Xro.Poutlet>)                          RCktS  309
        SSTinlet        = SSToutlet + <rc:FRICTION-DT>                          RCktS  310
        <ri.Pinlet>     = RefgP_fT(Jre, SSTinlet)                               RCktS  311
        <rc;dPfriction> = <ri.Pinlet> - <Xro.Poutlet>                           RCktS  312
      ENDIF                                                                     RCktS  313
c                                                                               RCktS  314
c                                                                               RCktS  315
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== RCktS  316
      CASE (119)                                                                RCktS  317
c                                                                               RCktS  318
c              Circuit should have loads attached                               RCktS  319
      IF (<ri;Xnode> .EQ. 0)  THEN                                              RCktS  320
        CALL MSGSIM(-2,II,II,II,II)                                             RCktS  321
        WRITE (IOUTPT,9001)  (<rc:NAME>,II=1,8)                                 RCktS  322
      ENDIF                                                                     RCktS  323
c                                                                               RCktS  324
c              Check if flow is reasonable                                      RCktS  325
      IF (<ri.Minlet> .EQ. 0.)  THEN                                            RCktS  326
c              circuit has no flow                                              RCktS  327
        IF (<ri;Xnode> .GT. 0)  THEN                                            RCktS  328
          CALL MSGSIM(-2,II,II,II,II)                                           RCktS  329
          WRITE (IOUTPT,9002)  (<rc:NAME>,II=1,8)                               RCktS  330
        ENDIF                                                                   RCktS  331
      ELSEIF (<rc:FLOW> .GT. 0.)  THEN                                          RCktS  332
        IF (<rc:FLOW> .LT. <rc;DesignFlow>*0.95)  THEN                          RCktS  333
c              user specified flow undersizes circuit                           RCktS  334
          CALL MSGSIM(-3,II,II,II,II)                                           RCktS  335
          WRITE (IOUTPT, 9003) (<rc:NAME>,II=1,8),                              RCktS  336
     &                          <rc:FLOW>, <rc;DesignFlow>                      RCktS  337
        ENDIF                                                                   RCktS  338
      ENDIF                                                                     RCktS  339
      <rc;DesignFlow> = <ri.Minlet>                                             RCktS  340
      IF (<ri.Minlet> .GT. 0.)  <rc;1/DesignFlow> = 1.0/<ri.Minlet>             RCktS  341
c                                                                               RCktS  342
c              Design volume and density                                        RCktS  343
c              - at inlet                                                       RCktS  344
      <rc;DesignInletV> = RefgV_fPH(Jre, <ri.Pinlet>,<ri.Hinlet>)               RCktS  345
      <rc;DesignInletD> = 1.0 / <rc;DesignInletV>                               RCktS  346
c              - upstream of any EPR or desuperheater                           RCktS  347
      Pvalve = <ri.Pinlet> - <rc;dPfriction>                                    RCktS  348
      <rc;DesignValveV>  = RefgV_fPH(Jre, Pvalve, <ro.Houtlet>)                 RCktS  349
      <rc;DesignValveD>  = 1.0 / <rc;DesignValveV>                              RCktS  350
c              - at outlet                                                      RCktS  351
      <rc;DesignOutletV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)          RCktS  352
      <rc;DesignOutletD> = 1.0 / <rc;DesignOutletV>                             RCktS  353
c                                                                               RCktS  354
c                                                                               RCktS  355
c ============ ATTACHMENTS ==================================================== RCktS  356
c                                                                               RCktS  357
c              Initial attachments                                              RCktS  358
      CASE (201)                                                                RCktS  359
c              Component pointers, schedules, and curves                        RCktS  360
        <rc:COST-DATA>     = Jcomponent(18, <rc:COST-DATA>)                     RCktS  361
        <rc:/SuctionGroup> = Jcomponent(25, <rc:/SuctionGroup>)                 RCktS  362
        <rc:/RefgSystem/>  = Jcomponent(29, <rc:/RefgSystem/>)                  RCktS  363
        SELECT CASE (<rc:ATTACH-TO>)                                            RCktS  364
          CASE (2)  ! Suction-group                                             RCktS  365
            <rc:SUCTION-GROUP> = Jcomponent(25, <rc:SUCTION-GROUP>)             RCktS  366
          CASE (4)  ! Desuperheater                                             RCktS  367
            <rc:DESUPERHEATER> = Jcomponent(26, <rc:DESUPERHEATER>)             RCktS  368
          CASE (6)  ! Refg-circuit                                              RCktS  369
            <rc:TRUNK-CKT> = Jcomponent(22, <rc:TRUNK-CKT>)                     RCktS  370
        END SELECT  ! rc:ATTACH-TO                                              RCktS  371
c                                                                               RCktS  372
c              Create nodes                                                     RCktS  373
      CASE (203)                                                                RCktS  374
        Jrs = <rc:/RefgSystem/>                                                 RCktS  375
        Jsg = <rc:/SuctionGroup>                                                RCktS  376
        Keu = NewEndUse(Jrc)                                                    RCktS  377
c                                                                               RCktS  378
c              Circuit inlet and outlet                                         RCktS  379
        SELECT CASE (<rc:ATTACH-TO>)                                            RCktS  380
          CASE (2)  ! Suction-group                                             RCktS  381
            Joutlet = <rc:SUCTION-GROUP>                                        RCktS  382
          CASE (4)  ! Desuperheater                                             RCktS  383
            Joutlet = <rc:DESUPERHEATER>                                        RCktS  384
          CASE (6)  ! Refg-circuit                                              RCktS  385
            Joutlet = <rc:TRUNK-CKT>                                            RCktS  386
        END SELECT  ! rc:ATTACH-TO                                              RCktS  387
        <rc;InletNode>  = NewNode(1, Jrs,-Jsg,Jrc,      0, 62,1,Keu, 1.)        RCktS  388
        <rc;OutletNode> = NewNode(1, Jrs,-Jsg,Jrc,Joutlet, 62,2,Keu, 1.)        RCktS  389
c                                                                               RCktS  390
c              Thermal gains                                                    RCktS  391
c quck                                                                          RCktS  392
c        ZP1 = 0                                                                RCktS  393
c        <rc;LossNode> = NewNode(1, Jrs,-Jsg,Jrc,ZP1, 31,2,0, 1.)               RCktS  394
c              Heat reclaim attachments                                         RCktS  395
        <rc;HtRecNode> = NewNode(1, Jrs,-Jsg,Jrc,0, 68,1,0, 1.)                 RCktS  396
c                                                                               RCktS  397
c              Links, lists                                                     RCktS  398
      CASE (205)                                                                RCktS  399
c              Get refrigerant pointer from refg plant                          RCktS  400
        Jrs              = <rc:/RefgSystem/>                                    RCktS  401
        <rc;Refrigerant> = <rs:REFRIGERANT>                                     RCktS  402
c              Get pointer to reference enthalpy from liquid trunk              RCktS  403
        <rc;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     RCktS  404
c                                                                               RCktS  405
c              List of nodes                                                    RCktS  406
        CALL ListNodes(<rc;Nodes>, 0,0,Jrc,0, 0,0)                              RCktS  407
c                                                                               RCktS  408
c              Histories                                                        RCktS  409
      CASE (208)                                                                RCktS  410
c              Set up history on inlet conditions - set flags in inlet          RCktS  411
c              Xnodes when not converged (does not require zone attached        RCktS  412
c              to loss to re-iterate)                                           RCktS  413
        Jrs           = <rc:/RefgSystem/>                                       RCktS  414
        Jsg           = <rc:/SuctionGroup>                                      RCktS  415
        <rc;LoadHsty> = NewHistory(Jrs,-Jsg,Jrc, <ri;Xnode>, Kri,               RCktS  416
     &                    0, 0, 1.,                                             RCktS  417
     &                    <#ri.Pinlet>, <sp:ERROR-P>, 1,                        RCktS  418
     &                    0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)               RCktS  419
c              Outlet history                                                   RCktS  420
        <rc;PlantHsty> = NewHistory(Jrs,-Jsg,Jrc, <ro;Xnode>, Kro,              RCktS  421
     &                     0, 0, 1.,                                            RCktS  422
     &                       <#ro.Qoutlet>, <sp:ERROR-LOAD>, 2,                 RCktS  423
     &                       <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                 RCktS  424
     &                       <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                 RCktS  425
     &                       0,0.,0, 0,0.,0, 0,0.,0)                            RCktS  426
c                                                                               RCktS  427
c              History lists                                                    RCktS  428
      CASE (209)                                                                RCktS  429
c              Component histories                                              RCktS  430
        CALL ListHstys(<rc;Hstys>, 0, 0, Jrc)                                   RCktS  431
c                                                                               RCktS  432
c              Dump pointers                                                    RCktS  433
      CASE (210)                                                                RCktS  434
        IF (<rc;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         RCktS  435
        WRITE (IOUTPT, 9202)  (<rc:NAME>,II=1,8),                               RCktS  436
     &    Jrc, Kri, Kro, <rc;LossNode>, <rc;HtRecNode>                          RCktS  437
c                                                                               RCktS  438
c                                                                               RCktS  439
      END SELECT  ! Mode                                                        RCktS  440
c                                                                               RCktS  441
      RETURN                                                                    RCktS  442
c                                                                               RCktS  443
c              Message formats                                                  RCktS  444
 9001 FORMAT(14x,'Refg-Circuit: ',8A4,' has no attached'               /        RCktS  445
     &       14x,'loads.'                                              )        RCktS  446
 9002 FORMAT(14x,'Refg-Circuit: ',8A4,' has zero'                      /        RCktS  447
     &       14x,'design refrigerant flow from its loads.'             )        RCktS  448
 9003 FORMAT(14x,'Refg-Circuit: ',8A4,' has a specified'               /        RCktS  449
     &       14x,'flow = ',F10.1,', but the design flow = ',F10.1      )        RCktS  450
 9201 FORMAT(/' REFG-CIRCUITs                          Jrc       Kri',          RCktS  451
     &'       Kro      Loss     HtRec'                                 /        RCktS  452
     &1x,32('-'),5('  --------'))                                               RCktS  453
 9202 FORMAT(1x,8A4,5I10)                                                       RCktS  454
      END                                                                       RCktS  455
      SUBROUTINE SuctionGroup(Mode, Jsg)                                        SucGrp   2
c                                                                               SucGrp   3
c              Simulates a suction-group with all compressors in parallel       SucGrp   4
c                                                                               SucGrp   5
c              Mode = 0-9  Attachment calculations                              SucGrp   6
c                      10  Design calculations                                  SucGrp   7
c                      19  Design reconciliation                                SucGrp   8
c                      20  Hourly initialization                                SucGrp   9
c                      31  Hourly simulation - no history update                SucGrp  10
c                      32  Hourly simulation - with history update              SucGrp  11
c                                                                               SucGrp  12
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /DESHRQ/ INILZE,IDDFLG,NDSDY,DESHRQ(360),NWRMUP,IDDTYP(2)         /DESHRQ/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               SucGrp  22
C                                                                               SucGrp  23
      REAL      Mtop, Mbottom, Mbypass, Mcomp,                                  SucGrp  24
     &          SSTbin(6), CtrlSignalBin(6), BinSize(6)                         SucGrp  25
      REAL*8    McycleOn, McycleOff, FracCycleOn, FracCycleOff,                 SucGrp  26
     &          FracBinCycle, FracBinNoCycle, SumWeightBins,                    SucGrp  27
     &          CapSSTbin(6), CapCompCycle(6), WeightBin(6),                    SucGrp  28
     &          TimeOnBin(6), TimeOffBin(6)                                     SucGrp  29
      INTEGER   Routine(4), rH                                                  SucGrp  30
      DATA      Routine /4HSuct,4HionG,4Hroup,4H    /                           SucGrp  31
      DATA      BinSize       /0.5, 1.0, 1.0, 1.0, 1.0, 0.5/                    SucGrp  32
      DATA      CtrlSignalBin /0.0,  .2,  .4,  .6,  .8, 1.0/                    SucGrp  33
c                                                                               SucGrp  34
      Kri = <sg;SuctionNode>              ! refrigerant inlet                   SucGrp  35
      IF (<sg;CompNode> .GT. 0)  THEN                                           SucGrp  36
        Kro = <sg;CompNode>               ! compressor outlet                   SucGrp  37
      ELSE                                                                      SucGrp  38
        Kro = <sg;DischargeNode>          ! discharge outlet                    SucGrp  39
      ENDIF                                                                     SucGrp  40
      Kcs = <sg;CtrlNode>                 ! control block                       SucGrp  41
      Jre = <sg;Refrigerant>              ! refrigerant                         SucGrp  42
c                                                                               SucGrp  43
      SELECT CASE (Mode)                                                        SucGrp  44
c                                                                               SucGrp  45
c                                                                               SucGrp  46
c ============ HOURLY INITIALIZATION ========================================== SucGrp  47
      CASE (10)                                                                 SucGrp  48
c                                                                               SucGrp  49
c              Equip-ctrl sequence                                              SucGrp  50
      <sg;EquipCtrl>    = <sg:EQUIP-CTRL>                                       SucGrp  51
      <sg;CtrlPriority> = 0.                                                    SucGrp  52
c                                                                               SucGrp  53
c                                                                               SucGrp  54
c ============ HOURLY SIMULATION ============================================== SucGrp  55
      CASE (31,32)                                                              SucGrp  56
c                                                                               SucGrp  57
c              Get inlet conditions                                             SucGrp  58
      CALL RefgNode(Kri, <ri.Minlet>,<ri.Mreqd>, <ri.Hinlet>, xTreqd,           SucGrp  59
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     SucGrp  60
      <ri.Qinlet>  = <ri.Minlet> * (<ri.Hinlet>-AA(<sg;RefgHrefPtr>))           SucGrp  61
      <ro.Qoutlet> = <ri.Qinlet>                                                SucGrp  62
      <ro.Houtlet> = <ri.Hinlet>                                                SucGrp  63
c              Reduce the inlet flow by the amount of hot-gas bypass            SucGrp  64
      IF (<sg:HOT-GAS-BYPAS> .EQ. 1)  THEN                                      SucGrp  65
        Krx         = <sg;HGBsucNode>                                           SucGrp  66
        <ri.Minlet> = <ri.Minlet> - <rx.Mrefg>                                  SucGrp  67
      ENDIF                                                                     SucGrp  68
c                                                                               SucGrp  69
c              Suction pressure setpoint                                        SucGrp  70
      SELECT CASE (<sg:TEMP-CTRL>)                                              SucGrp  71
        CASE (0)  ! Float                                                       SucGrp  72
          <sg;SSTsetpt> = <sg:DESIGN-SST> - <sg;Throttle/2>                     SucGrp  73
        CASE (1)  ! Fixed                                                       SucGrp  74
          <sg;SSTsetpt> = <sg:TEMP-SETPT>                                       SucGrp  75
        CASE (2)  ! Scheduled                                                   SucGrp  76
          <sg;SSTsetpt> = SchVal(<sg:TEMP-SETPT-SC>)                            SucGrp  77
        CASE (3)  ! Load reset                                                  SucGrp  78
          IF (<ri.Mreqd> .GT. 0.  .AND.  <ri.Preqd> .GT. -888.)  THEN           SucGrp  79
            <sg;SSTsetpt> = RefgT_fP(Jre, <ri.Preqd>) - 1.                      SucGrp  80
            <sg;SSTsetpt> = MIN(<sg;SSTsetpt>, <sg;MaxCtrlSetpt>)               SucGrp  81
            <sg;SSTsetpt> = MAX(<sg;SSTsetpt>, <sg;MinCtrlSetpt>)               SucGrp  82
          ELSE                                                                  SucGrp  83
            <sg;SSTsetpt> = <sg:DESIGN-SST> - <sg;Throttle/2>                   SucGrp  84
          ENDIF                                                                 SucGrp  85
      END SELECT                                                                SucGrp  86
c                                                                               SucGrp  87
c              Skip if no compressors                                           SucGrp  88
      IF (<sg;CompNode> .EQ. 0)  THEN                                           SucGrp  89
        <sg;SSTtop>  = -88888.                                                  SucGrp  90
        <sg;SST>     = <sg;SSTsetpt>                                            SucGrp  91
        <ri.Pinlet>  = RefgP_fT(Jre, <sg;SST>)                                  SucGrp  92
        <ro.Poutlet> = <ri.Pinlet>                                              SucGrp  93
        GOTO 3191                                                               SucGrp  94
      ENDIF                                                                     SucGrp  95
c                                                                               SucGrp  96
c              Temperature at top and bottom of throttling range                SucGrp  97
      IF (<sg:TEMP-CTRL> .NE. 3)  THEN                                          SucGrp  98
        SSTtop = <sg;SSTsetpt> + <sg;Throttle/2>                                SucGrp  99
      ELSE  ! load reset, required is at top of range                           SucGrp 100
        SSTtop = <sg;SSTsetpt>                                                  SucGrp 101
      ENDIF                                                                     SucGrp 102
      <sg;SSTtop> = SSTtop                                                      SucGrp 103
      SSTbottom   = SSTtop - <sg:TEMP-THROTTLE>                                 SucGrp 104
c                                                                               SucGrp 105
c              Pointer to list of compressors                                   SucGrp 106
      Kli   = <ro;Xnode>                                                        SucGrp 107
      Ncomp = <li;NumItems>                                                     SucGrp 108
c              Check if no flow                                                 SucGrp 109
      IF (<ri.Minlet> .EQ. 0.)  THEN                                            SucGrp 110
c              no flow - zero compressor mass flow and power consumption        SucGrp 111
        DO  LI=1,Ncomp                                                          SucGrp 112
          CALL CompressorAlgs(32, <li;List>)                                    SucGrp 113
        ENDDO                                                                   SucGrp 114
c              set suction temperature to bottom of throttling range            SucGrp 115
        <sg;SST>    = SSTbottom                                                 SucGrp 116
        <sg;SSTtop> = -88888.                                                   SucGrp 117
        GOTO 3190                                                               SucGrp 118
      ENDIF                                                                     SucGrp 119
c                                                                               SucGrp 120
c              Compressor capacity at top of range                              SucGrp 121
      <cs.CtrlSignal>  = 1.         ! full capacity                             SucGrp 122
      <cs.KnxModulate> = 0          ! all compressors can modulate              SucGrp 123
      <ro.Tsetpt>      = SSTtop                                                 SucGrp 124
      DO  LI=1,Ncomp                                                            SucGrp 125
        CALL CompressorAlgs(21, <li;List>)                                      SucGrp 126
      ENDDO                                                                     SucGrp 127
c              Compressor mix at top of range                                   SucGrp 128
      IF (<sg:TEMP-CTRL> .EQ. 0)  THEN                                          SucGrp 129
c              No suction group temperature control mechanism - all             SucGrp 130
c              compressors always run                                           SucGrp 131
        Mtop = 0.                                                               SucGrp 132
        DO  LI=1,Ncomp                                                          SucGrp 133
          Krx          = <li;List>                                              SucGrp 134
          <rx.RunFrac> = 1.                                                     SucGrp 135
          Mtop         = Mtop + <rx.MaxMrefg>                                   SucGrp 136
        ENDDO                                                                   SucGrp 137
c              Capacity at bottom of range                                      SucGrp 138
        <cs.CtrlSignal> = 1.                                                    SucGrp 139
        <ro.Tsetpt>     = SSTbottom                                             SucGrp 140
        Call CompressorCapacity                                                 SucGrp 141
        Mbottom         = Mcomp                                                 SucGrp 142
      ELSE                                                                      SucGrp 143
        IF (<sg;EquipCtrl> .GT. 0)  THEN                                        SucGrp 144
c              Allocate using user-specified control sequence                   SucGrp 145
          Jec = <sg;EquipCtrl>                                                  SucGrp 146
          CALL Refg_EquipCtrl(Jec,<sg;EquipCtrlLast>,                           SucGrp 147
     &                   Kli, <ri.Minlet>, <ri.RunFrac>, Mtop, KnxCycle)        SucGrp 148
c              check if only one compressor should modulate                     SucGrp 149
          IF (<ec:PRORATE-LOAD> .eq. 0)  <cs.KnxModulate> = KnxCycle            SucGrp 150
        ELSE  ! default allocation                                              SucGrp 151
          CALL Refg_EquipCtrlDefault(                                           SucGrp 152
     &                   Kli, <ri.Minlet>, <ri.RunFrac>, Mtop, KnxCycle)        SucGrp 153
        ENDIF                                                                   SucGrp 154
        <sg;EquipCtrlLast> = <sg;EquipCtrl>                                     SucGrp 155
c              For the mix of compressors selected at top of range,             SucGrp 156
c              get capacity at bottom of range                                  SucGrp 157
        <cs.CtrlSignal> = 0.                                                    SucGrp 158
        <ro.Tsetpt>     = SSTbottom                                             SucGrp 159
        Call CompressorCapacity                                                 SucGrp 160
        Mbottom         = Mcomp                                                 SucGrp 161
      ENDIF  ! sg:TEMP-CTRL                                                     SucGrp 162
c                                                                               SucGrp 163
c              Check if hot-gas bypassing                                       SucGrp 164
      IF (<sg:HOT-GAS-BYPAS> .EQ. 1)  THEN                                      SucGrp 165
c              compressor capacity at bypass setpoint                           SucGrp 166
        <ro.Tsetpt> = <sg:HGB-SETPT>                                            SucGrp 167
        IF (<sg:TEMP-CTRL> .EQ. 0)  THEN                                        SucGrp 168
          <cs.CtrlSignal> = 1.                                                  SucGrp 169
        ELSE                                                                    SucGrp 170
          <cs.CtrlSignal> = (<sg:HGB-SETPT>-SSTbottom)*<sg;1/Throttle>          SucGrp 171
          <cs.CtrlSignal> = MAX(0., MIN(1., <cs.CtrlSignal>))                   SucGrp 172
        ENDIF                                                                   SucGrp 173
        Call CompressorCapacity                                                 SucGrp 174
        IF (Mcomp .LE. Mbottom  .AND.  Mcomp .LE. <ri.Minlet>) THEN             SucGrp 175
c              no hot-gas bypass needed                                         SucGrp 176
          Mbypass    = 0.                                                       SucGrp 177
          Krx        = <sg;HGBsucNode>                                          SucGrp 178
          <rx.Mrefg> = 0.                                                       SucGrp 179
          Krx        = <sg;HGBhiNode>                                           SucGrp 180
          <rx.Mrefg> = 0.                                                       SucGrp 181
          IF (<sg;HGBliqNode> .GT. 0)  THEN                                     SucGrp 182
            Krx        = <sg;HGBliqNode>                                        SucGrp 183
            <rx.Mrefg> = 0.                                                     SucGrp 184
          ENDIF                                                                 SucGrp 185
        ELSE                                                                    SucGrp 186
c              bypass flow                                                      SucGrp 187
          Mbypass     = Mcomp - <ri.Minlet>                                     SucGrp 188
          <ri.Minlet> = Mcomp                                                   SucGrp 189
c              enthalpy from discharge                                          SucGrp 190
          Krx     = <sg;HGBhiXnode>                                             SucGrp 191
          Hhiside = <rx.Hrefg>                                                  SucGrp 192
c              Check if desuperheated                                           SucGrp 193
          IF (<sg:HGB-LIQUID> .EQ. 0)  THEN                                     SucGrp 194
c              No desuperheat - feed directly into suction                      SucGrp 195
            Krx        = <sg;HGBsucNode>                                        SucGrp 196
            <rx.Mrefg> = Mbypass                                                SucGrp 197
            <rx.Hrefg> = Hhiside                                                SucGrp 198
c                 Amount taken from discharge - make negative so                SucGrp 199
c                 discharge flow is reduced                                     SucGrp 200
            Krx        = <sg;HGBhiNode>                                         SucGrp 201
            <rx.Mrefg> = -Mbypass                                               SucGrp 202
            <rx.Hrefg> = Hhiside                                                SucGrp 203
          ELSE                                                                  SucGrp 204
c                 Refrigerant liquid desuperheats hot gas;                      SucGrp 205
c                 conditions returning to suction                               SucGrp 206
            Krx        = <sg;HGBsucXnode>                                       SucGrp 207
            Hsuction   = RefgH_Vapor_fSP(Jre, <sg:HGB-SUPERHEAT>,               SucGrp 208
     &                                   <rx.Prefg>)                            SucGrp 209
            Krx        = <sg;HGBsucNode>                                        SucGrp 210
            <rx.Mrefg> = Mbypass                                                SucGrp 211
            <rx.Hrefg> = Hsuction                                               SucGrp 212
c                 conditions taken from liquid                                  SucGrp 213
            Krx        = <sg;HGBliqXnode>                                       SucGrp 214
            Hliquid    = <rx.Hrefg>                                             SucGrp 215
c                 fraction of bypassed flow that is liquid                      SucGrp 216
            Frac       = (Hhiside-Hsuction) / (Hhiside - Hliquid)               SucGrp 217
            Krx        = <sg;HGBliqNode>                                        SucGrp 218
            <rx.Mrefg> = Mbypass * Frac                                         SucGrp 219
c                 conditions taken from discharge - make flow negative          SucGrp 220
c                 so discharge flow is reduced                                  SucGrp 221
            Krx        = <sg;HGBhiNode>                                         SucGrp 222
            <rx.Mrefg> = Mbypass * (Frac - 1.0)                                 SucGrp 223
            <rx.Hrefg> = Hhiside                                                SucGrp 224
          ENDIF                                                                 SucGrp 225
c              simulate compressors                                             SucGrp 226
          Call RunAtBalancePoint                                                SucGrp 227
          GOTO 3190                                                             SucGrp 228
        ENDIF  ! Hot-gas bypass mass flow calcs                                 SucGrp 229
c              Check for convergence on HGB                                     SucGrp 230
        IF (Mode .EQ. 32)  THEN                                                 SucGrp 231
          CALL CnvgCheck(1, <sg;HGBHsty>)  ! Suction Group to Loads             SucGrp 232
        ELSE                                                                    SucGrp 233
          CALL CnvgCheck(0, <sg;HGBHsty>)  ! Loads to Suction Group             SucGrp 234
        ENDIF                                                                   SucGrp 235
      ENDIF  ! Hot-gas bypass                                                   SucGrp 236
c                                                                               SucGrp 237
c              Check if compressors can handle load at top of range             SucGrp 238
      IF (<ri.Minlet> .GT. Mtop)  THEN                                          SucGrp 239
c              Suction pressure is floating above range.  Find the range        SucGrp 240
c              in which the flow can be handled                                 SucGrp 241
        <cs.CtrlSignal> = 1.0                                                   SucGrp 242
        <ro.Tsetpt>     = SSTtop                                                SucGrp 243
        SSTmin          = SSTtop                                                SucGrp 244
        CapMin          = Mtop                                                  SucGrp 245
        DO  iCount=1,100  ! range                                               SucGrp 246
          <ro.Tsetpt> = <ro.Tsetpt> + 10.                                       SucGrp 247
          Call CompressorCapacity                                               SucGrp 248
          IF (Mcomp .GT. <ri.Minlet>)  THEN                                     SucGrp 249
c              range is found                                                   SucGrp 250
            SSTmax = <ro.Tsetpt>                                                SucGrp 251
            CapMax = Mcomp                                                      SucGrp 252
            EXIT                                                                SucGrp 253
          ELSEIF (Mcomp .LE. CapMin)  THEN                                      SucGrp 254
c              Compressor curves broke down; can't find balance point           SucGrp 255
            IF (<sg;Msg9103Flag> .EQ. 0)  THEN                                  SucGrp 256
              CALL MSGSIM(-2,II,II,II,II)                                       SucGrp 257
              WRITE (IOUTPT,9103) (<sg:NAME>,II=1,8), IMO, IDAY, IHR            SucGrp 258
C ??  activating this causes an abort for some reason; same with 9104           SucGrp 259
C             CALL MessageBox( NULL,                                            SucGrp 260
C    &          'Compressor curves are invalid '//char(10)//char(13)//          SucGrp 261
C    &          'over control range'//char(0),                                  SucGrp 262
C    &          'SUCTION-GROUP Errors'//char(0),                                SucGrp 263
C    &          MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                     SucGrp 264
            ENDIF                                                               SucGrp 265
            Call RunAtBalancePoint                                              SucGrp 266
            <sg;Msg9103Flag> = <sg;Msg9103Flag> + 1                             SucGrp 267
            GOTO 3190                                                           SucGrp 268
          ELSE                                                                  SucGrp 269
            SSTmin = <ro.Tsetpt>                                                SucGrp 270
            CapMin = Mcomp                                                      SucGrp 271
          ENDIF                                                                 SucGrp 272
          IF (iCount .EQ. 100)  CALL CnvgMsg2(1, Routine, Jsg)                  SucGrp 273
        ENDDO  ! range                                                          SucGrp 274
c              Find balance point within range and simulate compressors         SucGrp 275
        Call FindBalancePoint                                                   SucGrp 276
        Call RunAtBalancePoint                                                  SucGrp 277
        GOTO 3190                                                               SucGrp 278
      ENDIF  ! floating above balance point                                     SucGrp 279
c                                                                               SucGrp 280
c              Check if operating within range                                  SucGrp 281
      IF (<ri.Minlet> .GE. Mbottom)  THEN                                       SucGrp 282
        SSTmin = SSTbottom                                                      SucGrp 283
        CapMin = Mbottom                                                        SucGrp 284
        SSTmax = SSTtop                                                         SucGrp 285
        CapMax = Mtop                                                           SucGrp 286
        Call FindBalancePoint                                                   SucGrp 287
        Call RunAtBalancePoint                                                  SucGrp 288
        GOTO 3190                                                               SucGrp 289
      ENDIF                                                                     SucGrp 290
c                                                                               SucGrp 291
c              If here, compressors are operating below range.  Controls        SucGrp 292
c              may either float compressors or cycle on/off                     SucGrp 293
      IF (<sg:TEMP-CTRL> .EQ. 0  .OR.  <sg:CYCLE-COMPRES> .EQ. 0)  THEN         SucGrp 294
c              No temperature control or no compressor cycling allowed;         SucGrp 295
c              compressors are floating                                         SucGrp 296
c              Find the range in which the flow can be handled                  SucGrp 297
        IF (<sg:TEMP-CTRL> .EQ. 0)  THEN                                        SucGrp 298
          <cs.CtrlSignal> = 1.                                                  SucGrp 299
        ELSE                                                                    SucGrp 300
          <cs.CtrlSignal> = 0.                                                  SucGrp 301
        ENDIF                                                                   SucGrp 302
        <ro.Tsetpt> = SSTbottom                                                 SucGrp 303
        SSTmax      = SSTbottom                                                 SucGrp 304
        CapMax      = Mbottom                                                   SucGrp 305
        DO  iCount=1,100   ! range                                              SucGrp 306
          <ro.Tsetpt> = <ro.Tsetpt> - 10.                                       SucGrp 307
          Call CompressorCapacity                                               SucGrp 308
          IF (Mcomp .LE. <ri.Minlet>)  THEN                                     SucGrp 309
c              range is found                                                   SucGrp 310
            SSTmin = <ro.Tsetpt>                                                SucGrp 311
            CapMin = Mcomp                                                      SucGrp 312
            EXIT                                                                SucGrp 313
          ELSEIF (Mcomp .GE. CapMax)  THEN                                      SucGrp 314
c              Compressor curves broke down; can't find balance point           SucGrp 315
            IF (<sg;Msg9104Flag> .EQ. 0)  THEN                                  SucGrp 316
              CALL MSGSIM(-2,II,II,II,II)                                       SucGrp 317
              WRITE (IOUTPT,9104) (<sg:NAME>,II=1,8), IMO, IDAY, IHR            SucGrp 318
C             CALL MessageBox( NULL,                                            SucGrp 319
C    &          'Compressor curves are invalid '//char(10)//char(13)//          SucGrp 320
C    &          'over control range'//char(0),                                  SucGrp 321
C    &          'SUCTION-GROUP Errors'//char(0),                                SucGrp 322
C    &          MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                     SucGrp 323
            ENDIF                                                               SucGrp 324
            Call RunAtBalancePoint                                              SucGrp 325
            <sg;Msg9104Flag> = <sg;Msg9104Flag> + 1                             SucGrp 326
            GOTO 3190                                                           SucGrp 327
          ELSE                                                                  SucGrp 328
            SSTmax = <ro.Tsetpt>                                                SucGrp 329
            CapMax = Mcomp                                                      SucGrp 330
          ENDIF                                                                 SucGrp 331
          IF (iCount .EQ. 100)  CALL CnvgMsg2(2, Routine, Jsg)                  SucGrp 332
        ENDDO  ! range                                                          SucGrp 333
c              Find balance point within range and simulate compressors         SucGrp 334
        Call FindBalancePoint                                                   SucGrp 335
        Call RunAtBalancePoint                                                  SucGrp 336
        GOTO 3190                                                               SucGrp 337
      ENDIF  ! floating below balance point                                     SucGrp 338
c                                                                               SucGrp 339
c              Check to see if operation close to very top or                   SucGrp 340
c              very bottom of range                                             SucGrp 341
      IF (1.-<ri.Minlet>/Mtop .LT. <sp:ERROR-FLOW>)  THEN                       SucGrp 342
c              Operating extremely close to top of range                        SucGrp 343
        <ro.Tsetpt>     = SSTtop                                                SucGrp 344
        <cs.CtrlSignal> = 1.                                                    SucGrp 345
        Call RunAtBalancePoint                                                  SucGrp 346
        GOTO 3190                                                               SucGrp 347
      ELSEIF (1.-<ri.Minlet>/Mbottom .LT. <sp:ERROR-FLOW>)  THEN                SucGrp 348
c              Operating extremely close to bottom of range                     SucGrp 349
        <ro.Tsetpt>     = SSTbottom                                             SucGrp 350
        <cs.CtrlSignal> = 0.                                                    SucGrp 351
        Call RunAtBalancePoint                                                  SucGrp 352
        GOTO 3190                                                               SucGrp 353
      ENDIF                                                                     SucGrp 354
c                                                                               SucGrp 355
c              Compressors are cycling to maintain an average suction           SucGrp 356
c              temperature between the cut-in and cut-out temperatures          SucGrp 357
c              Divide the throttling range into 6 bins, where the top           SucGrp 358
c              and bottom bins are half the size of the middle bins             SucGrp 359
      dTbin     = <sg;dTbin>                                                    SucGrp 360
      SSTbin(1) = SSTbottom                                                     SucGrp 361
      DO  I=1,5                                                                 SucGrp 362
        SSTbin(I+1) = SSTbin(I) + dTbin                                         SucGrp 363
      ENDDO                                                                     SucGrp 364
c              get capacity in each bin                                         SucGrp 365
      SumWeightBins = 0.                                                        SucGrp 366
      DO  I=1,6                                                                 SucGrp 367
        <cs.CtrlSignal> = CtrlSignalBin(I)                                      SucGrp 368
        <ro.Tsetpt>     = SSTbin(I)                                             SucGrp 369
        CapSSTbin(I)    = 0.                                                    SucGrp 370
        DO  LI=1,Ncomp                                                          SucGrp 371
          Krx = <li;List>                                                       SucGrp 372
          IF (<rx.RunFrac> .GT. 0.)  THEN                                       SucGrp 373
            CALL CompressorAlgs(21, Krx)                                        SucGrp 374
            CapSSTbin(I) = CapSSTbin(I) + <rx.MaxMrefg>                         SucGrp 375
            IF (Krx .EQ. KnxCycle)  CapCompCycle(I) = <rx.MaxMrefg>             SucGrp 376
          ENDIF                                                                 SucGrp 377
        ENDDO                                                                   SucGrp 378
        WeightBin(I)  = BinSize(I) / (CapSSTbin(I) - <ri.Minlet>)               SucGrp 379
        SumWeightBins = SumWeightBins + WeightBin(I)                            SucGrp 380
      ENDDO                                                                     SucGrp 381
c              Approximate time spent in each bin when all compressors          SucGrp 382
c              in selected mix are cycled on                                    SucGrp 383
      SumWeightBins = 1. / SumWeightBins                                        SucGrp 384
      McycleOn      = 0.                                                        SucGrp 385
      DO  I=1,6                                                                 SucGrp 386
        TimeOnBin(I) = WeightBin(I) * SumWeightBins                             SucGrp 387
        McycleOn     = McycleOn     + CapSSTbin(I) * TimeOnBin(I)               SucGrp 388
      ENDDO                                                                     SucGrp 389
c                                                                               SucGrp 390
c              Repeat the above with one compressor cycled off                  SucGrp 391
      SumWeightBins = 0.                                                        SucGrp 392
      DO  I=1,6                                                                 SucGrp 393
        CapSSTbin(I)  = CapSSTbin(I) - CapCompCycle(I)                          SucGrp 394
        WeightBin(I)  = BinSize(I) / ABS(<ri.Minlet> - CapSSTbin(I))            SucGrp 395
        SumWeightBins = SumWeightBins + WeightBin(I)                            SucGrp 396
      ENDDO                                                                     SucGrp 397
c              Approximate time spent in each bin when one compressor           SucGrp 398
c              in the mix is cycled off                                         SucGrp 399
      SumWeightBins = 1. / SumWeightBins                                        SucGrp 400
      McycleOff     = 0.                                                        SucGrp 401
      DO  I=1,6                                                                 SucGrp 402
        TimeOffBin(I) = WeightBin(I) * SumWeightBins                            SucGrp 403
        McycleOff     = McycleOff    + CapSSTbin(I) * TimeOffBin(I)             SucGrp 404
      ENDDO                                                                     SucGrp 405
c                                                                               SucGrp 406
c              Relative amount of time spent cycled on vs. off                  SucGrp 407
      FracCycleOn  = (<ri.Minlet>-McycleOff) / (McycleOn-McycleOff)             SucGrp 408
c              Check if result reasonable                                       SucGrp 409
      IF (McycleOff   .GT. <ri.Minlet>  .OR.                                    SucGrp 410
     &    McycleOn    .LT. <ri.Minlet>  .OR.                                    SucGrp 411
     &    FracCycleOn .GT. 1.  .OR.  FracCycleOn .LT. 0.)  THEN                 SucGrp 412
        WRITE (IOUTPT, 9106)  (<sg:NAME>,II=1,8)                                SucGrp 413
        FracCycleOn = MAX(0.D0, MIN(1.D0, FracCycleOn))                         SucGrp 414
      ENDIF                                                                     SucGrp 415
      FracCycleOff = 1. - FracCycleOn                                           SucGrp 416
c                                                                               SucGrp 417
c              Initialize compressor bin operation                              SucGrp 418
      DO  LI=1,Ncomp                                                            SucGrp 419
        CALL CompressorAlgs(32, <li;List>)                                      SucGrp 420
      ENDDO                                                                     SucGrp 421
c              Simulate each compressor in each bin time step                   SucGrp 422
      SSTavg  = 0.                                                              SucGrp 423
      DO  I=1,6                                                                 SucGrp 424
        <cs.CtrlSignal> = CtrlSignalBin(I)                                      SucGrp 425
        <ro.Tsetpt>     = SSTbin(I)                                             SucGrp 426
c              fraction of time spent in this bin                               SucGrp 427
        FracBinCycle   = TimeOnBin(I)*FracCycleOn                               SucGrp 428
        FracBinNoCycle = FracBinCycle + TimeOffBin(I)*FracCycleOff              SucGrp 429
c              average SST during the hour                                      SucGrp 430
        SSTavg = SSTavg + SSTbin(I)* FracBinNoCycle                             SucGrp 431
        DO  LI=1,Ncomp                                                          SucGrp 432
          Krx = <li;List>                                                       SucGrp 433
          IF (<rx.RunFrac> .GT. 0.)  THEN                                       SucGrp 434
c              fraction of time this compressor operates in this bin            SucGrp 435
            IF (Krx .NE. KnxCycle)  THEN                                        SucGrp 436
              <cs.RunFrac> = FracBinNoCycle                                     SucGrp 437
            ELSE                                                                SucGrp 438
              <cs.RunFrac> = FracBinCycle                                       SucGrp 439
            ENDIF                                                               SucGrp 440
            CALL CompressorAlgs(33, Krx)                                        SucGrp 441
            IF (IwinReturn .eq. 1)  Return                                      SucGrp 442
          ENDIF                                                                 SucGrp 443
        ENDDO  ! Ncomp                                                          SucGrp 444
      ENDDO  ! bins                                                             SucGrp 445
c              Cycling compressors match flow exactly                           SucGrp 446
      <cs.Adjustment> = 1.0                                                     SucGrp 447
      <sg;SST>        = SSTavg                                                  SucGrp 448
c                                                                               SucGrp 449
c              Reconcile hourly operation of compressors                        SucGrp 450
 3190 <ri.Pinlet>  = RefgP_fT(Jre, <sg;SST>)                                    SucGrp 451
      <ro.Poutlet> = <ri.Pinlet>                                                SucGrp 452
      DO  LI=1,Ncomp                                                            SucGrp 453
        CALL CompressorAlgs(Mode+7, <li;List>)                                  SucGrp 454
      ENDDO                                                                     SucGrp 455
c              Reentry point for no compressors                                 SucGrp 456
 3191 CONTINUE                                                                  SucGrp 457
c              Convert SST to pressure for use by suction circuits              SucGrp 458
      <ri.Pinlet> = RefgP_fT(Jre, <sg;SST>)                                     SucGrp 459
c                                                                               SucGrp 460
c              Check for convergence                                            SucGrp 461
      IF (Mode .EQ. 31)  THEN                ! Loads to suction group           SucGrp 462
        CALL CnvgCheck(0, <sg;SuctionHsty>)                                     SucGrp 463
        IF (<sg;DischargeHsty> .GT. 0)                                          SucGrp 464
     &    CALL CnvgCheck(1, <sg;DischargeHsty>)                                 SucGrp 465
      ELSE                                   ! Suction group to loads           SucGrp 466
        CALL CnvgCheck(1, <sg;SuctionHsty>)                                     SucGrp 467
        IF (<sg;DischargeHsty> .GT. 0)                                          SucGrp 468
     &    CALL CnvgCheck(0, <sg;DischargeHsty>)                                 SucGrp 469
      ENDIF                                                                     SucGrp 470
      <ro.Moutlet> = <ri.Minlet>                                                SucGrp 471
c                                                                               SucGrp 472
c              Auxiliary power                                                  SucGrp 473
      IF (<sg:AUX-KW> .GT. 0.)  THEN                                            SucGrp 474
        SELECT CASE (<sg:AUX-MODE>)                                             SucGrp 475
          CASE (1)  ! Always                                                    SucGrp 476
            AuxKWh = <sg:AUX-KW>                                                SucGrp 477
          CASE (2)  ! When on                                                   SucGrp 478
            IF (FracCycleOn .LT. 1.  .AND.  McycleOff .LT. .001)  THEN          SucGrp 479
              AuxKWh = <sg:AUX-KW> * FracCycleOn                                SucGrp 480
            ELSE                                                                SucGrp 481
              AuxKWh = <sg:AUX-KW>                                              SucGrp 482
            ENDIF                                                               SucGrp 483
          CASE (3)  ! When off                                                  SucGrp 484
            IF (FracCycleOn .LT. 1.  .AND.  McycleOff .LT. .001)  THEN          SucGrp 485
              AuxKWh = <sg:AUX-KW> * (1.0 - FracCycleOn)                        SucGrp 486
            ELSE                                                                SucGrp 487
              AuxKWh = 0.                                                       SucGrp 488
            ENDIF                                                               SucGrp 489
          CASE (4)  ! Scheduled                                                 SucGrp 490
            AuxKWh = <sg:AUX-KW> * SchVal(<sg:AUX-SCH>)                         SucGrp 491
        END SELECT                                                              SucGrp 492
        Kmd = <sg:AUX-METER>                                                    SucGrp 493
        Kmx = <md;Xnode>                                                        SucGrp 494
        IF (AuxKWh .GT. 0.)  THEN                                               SucGrp 495
          IF (ABS(1. - <md.Elec>/AuxKWh) .GT. <sp:ERROR-LOAD>)                  SucGrp 496
     &      <mx.IterFlag> = Jsg                                                 SucGrp 497
        ELSE                                                                    SucGrp 498
          IF (<md.Elec> .GT. 0.)  <mx.IterFlag> = Jsg                           SucGrp 499
        ENDIF                                                                   SucGrp 500
        <md.Elec> = AuxKWh                                                      SucGrp 501
      ENDIF                                                                     SucGrp 502
c                                                                               SucGrp 503
c                                                                               SucGrp 504
c ============ STATISTICS - HOURLY DATA ======================================= SucGrp 505
      CASE (42)                                                                 SucGrp 506
c                                                                               SucGrp 507
c              Warn if suction group setpoint too warm for loads                SucGrp 508
      IF (<ri.Mreqd> .GT. 0.  .AND.  <ri.Preqd> .GT. 0.)  THEN                  SucGrp 509
        dP = <ri.Pinlet> - <ri.Preqd>                                           SucGrp 510
        IF (dP+0.01 .GT. 0.)  THEN                                              SucGrp 511
          SSTreqd = RefgT_fP(Jre, <ri.Preqd>)                                   SucGrp 512
          SST     = RefgT_fP(Jre, <ri.Pinlet>)                                  SucGrp 513
          dT      = SST - SSTreqd                                               SucGrp 514
          IF (dT .GT. <sg;SSTdTmax>)  THEN                                      SucGrp 515
            <sg;SSTdTmax>    = dT                                               SucGrp 516
            <sg;SSTreqdMin>  = SSTreqd                                          SucGrp 517
            <sg;SSTreqdMo>  = IMO                                               SucGrp 518
            <sg;SSTreqdDay> = IDAY                                              SucGrp 519
            <sg;SSTreqdHr>  = ISCHR                                             SucGrp 520
          ENDIF                                                                 SucGrp 521
        ENDIF                                                                   SucGrp 522
      ENDIF                                                                     SucGrp 523
c                                                                               SucGrp 524
c                                                                               SucGrp 525
c ============ STATISTICS - YEARLY DATA ======================================= SucGrp 526
      CASE (47)                                                                 SucGrp 527
c                                                                               SucGrp 528
c              Warn if suction group setpoint too warm for loads                SucGrp 529
      IF (<sg;SSTdTmax> .GT. 0.)  THEN                                          SucGrp 530
        CALL MSGSIM(-3,II,II,II,II)                                             SucGrp 531
        WRITE (IOUTPT,9105)  (<sg:NAME>,II=1,8),                                SucGrp 532
     &    <sg;SSTreqdMo>,<sg;SSTreqdDay>,<sg;SSTreqdHr>,                        SucGrp 533
     &    <sg;SSTreqdMin>+<sg;SSTdTmax>, <sg;SSTreqdMin>                        SucGrp 534
      ENDIF                                                                     SucGrp 535
c                                                                               SucGrp 536
c                                                                               SucGrp 537
c ============ REPORT CREATION ================================================ SucGrp 538
      CASE (50)                                                                 SucGrp 539
c                                                                               SucGrp 540
c              Create a list of the elec-meter nodes of all                     SucGrp 541
c              compressors attached to this suction group for use               SucGrp 542
c              in statistics                                                    SucGrp 543
      Kli = <ro;Xnode>                                                          SucGrp 544
      Neq = <li;NumItems>                                                       SucGrp 545
      DO  LI=1,Neq                                                              SucGrp 546
        Knx = <li;List>                                                         SucGrp 547
        Jcp = <nx;Component>                                                    SucGrp 548
        CALL ListAdd(<sg;ListCompElec>, <cp:ELEC-METER>)                        SucGrp 549
        IF (<cp:AUX-METER> .GT. 0)                                              SucGrp 550
     &    CALL ListAdd(<sg;ListCompElec>, <cp:AUX-METER>)                       SucGrp 551
      ENDDO                                                                     SucGrp 552
c                                                                               SucGrp 553
c              statistics blocks                                                SucGrp 554
      Ks2Load    = NewStat2(Kri, <+ri.Qinlet>, 0, 1.)                           SucGrp 555
      Ks2Flow    = NewStat2(Kri, <+ri.Minlet>, 0, 1.)                           SucGrp 556
      Ks2Elec    = NewStat2(<sg;ListCompElec>, <+md.Elec>, 0, 1.)               SucGrp 557
      Kli        = 0                                                            SucGrp 558
      CALL ListAdd(Kli, <sg;ListCompElec>)                                      SucGrp 559
      CALL ListAdd(Kli, <sg:AUX-METER>)                                         SucGrp 560
      Ks2ElecT   = NewStat2(Kli,   <+md.Elec>, 0, 1.)                           SucGrp 561
      Ks5FlowBin = NewStat5(Kri, <+ri.Minlet>, 0, 1.)                           SucGrp 562
      Ks5ElecBin = NewStat5(Kli,   <+md.Elec>, 0, 1.)                           SucGrp 563
c                                                                               SucGrp 564
c              Create the type "H" report                                       SucGrp 565
      IF (<sg:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      SucGrp 566
     &  <sg;PS-H> = NewReport_H(Jsg, 133,                                       SucGrp 567
     &                          4, 5, 6,                                        SucGrp 568
     &                          Ks2Load, Ks2Flow, Ks2Elec, Ks2ElecT,            SucGrp 569
     &                          Ks5FlowBin, Ks5ElecBin, 0,                      SucGrp 570
     &                          0, 0, 0)                                        SucGrp 571
c                                                                               SucGrp 572
c              Setpoint overload                                                SucGrp 573
      <sg;s10> = NewStat10(Jsg, <#sg;SSTtop>, <#sg;SST>, 0.1,1,                 SucGrp 574
     &                          <#ri.Minlet>)                                   SucGrp 575
c                                                                               SucGrp 576
c                                                                               SucGrp 577
c ============ REPORT ORDER =================================================== SucGrp 578
      CASE (52)                                                                 SucGrp 579
c                                                                               SucGrp 580
      Call Report_H(Mode, <sg;PS-H>)                                            SucGrp 581
c                                                                               SucGrp 582
      IF (<sg;CompNode> .ne. 0)  THEN                                           SucGrp 583
        Kli = <ro;Xnode>                                                        SucGrp 584
        DO  LI=1,<li;NumItems>                                                  SucGrp 585
          CALL CompressorAlgs(Mode, <li;List>)                                  SucGrp 586
        ENDDO                                                                   SucGrp 587
      ENDIF                                                                     SucGrp 588
c                                                                               SucGrp 589
c                                                                               SucGrp 590
c ============ REPORTS - VERIFICATION DATA ==================================== SucGrp 591
      CASE (54)                                                                 SucGrp 592
c                                                                               SucGrp 593
c              Output design information                                        SucGrp 594
      IF (<sg;PS-H> .ne. 0)  THEN                                               SucGrp 595
        rH = <sg;PS-H>                                                          SucGrp 596
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       SucGrp 597
        CALL GetAttachments(Jsg, 2)                                             SucGrp 598
        WRITE (IREPFL)  23,<rH;Iuniq>,1,2,19,                                   SucGrp 599
     &    (NameAttachments(II,1,1),II=1,8),                                     SucGrp 600
     &    (NameAttachments(II,1,2),II=1,8),                                     SucGrp 601
     &    <ri.Qinlet>,<ri.Minlet>,<ro.Tsetpt>                                   SucGrp 602
        DO  Irow=2,NumRowsOfAttachments                                         SucGrp 603
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 SucGrp 604
     &      (NameAttachments(II,Irow,1),II=1,8),                                SucGrp 605
     &      (NameAttachments(II,Irow,2),II=1,8)                                 SucGrp 606
        ENDDO                                                                   SucGrp 607
      ENDIF                                                                     SucGrp 608
c                                                                               SucGrp 609
c                                                                               SucGrp 610
c ============ REPORTS - YEARLY SUMMARY (SPECIAL) ============================= SucGrp 611
      CASE (58)                                                                 SucGrp 612
c                                                                               SucGrp 613
c              Setpoint overload                                                SucGrp 614
      IF (<sg;PS-H> .ne. 0)  THEN                                               SucGrp 615
        rH = <sg;PS-H>                                                          SucGrp 616
        CALL Report_s10(<rH;Iuniq>, 7, <sg;s10>)                                SucGrp 617
      ENDIF                                                                     SucGrp 618
c                                                                               SucGrp 619
c                                                                               SucGrp 620
c ============ HOURLY REPORTS - HOURLY DATA =================================== SucGrp 621
      CASE (62)                                                                 SucGrp 622
c                                                                               SucGrp 623
      IF (<sg;HourRepBuf> .EQ. 0)  RETURN                                       SucGrp 624
c                                                                               SucGrp 625
      IAptr        = <sg;HourRepBuf> - 1                                        SucGrp 626
c                                                                               SucGrp 627
      AA(IAptr+1)  = <ri.Qinlet>                                                SucGrp 628
      AA(IAptr+2)  = <ri.Minlet>                                                SucGrp 629
      IF (<sg;HGBhiNode> .GT. 0)  THEN                                          SucGrp 630
        Krx          = <sg;HGBhiNode>                                           SucGrp 631
        AA(IAptr+3)  = -<rx.Mrefg>                                              SucGrp 632
      ENDIF                                                                     SucGrp 633
      IF (<sg;HGBliqNode> .GT. 0)  THEN                                         SucGrp 634
        Krx          = <sg;HGBliqNode>                                          SucGrp 635
        AA(IAptr+4)  = <rx.Mrefg>                                               SucGrp 636
      ENDIF                                                                     SucGrp 637
      AA(IAptr+5)  = SumList(<sg;ListCompElec>, <+md.Elec>, -1.)                SucGrp 638
      Kmd          = <sg:AUX-METER>                                             SucGrp 639
      AA(IAptr+6)  = <md.Elec>                                                  SucGrp 640
      IF (<ri.Preqd> .GT. -888.)                                                SucGrp 641
     &  AA(IAptr+7)  = RefgT_fP(Jre, <ri.Preqd>)                                SucGrp 642
      AA(IAptr+8)  = <sg;SSTsetpt>                                              SucGrp 643
      AA(IAptr+9)  = <sg;SST>                                                   SucGrp 644
      IF (<ri.Pinlet> .GT. -888.  .AND.  <ri.Hinlet> .GT. -888.)                SucGrp 645
     &  AA(IAptr+10) = RefgSuper_fPH(Jre, <ri.Pinlet>, <ri.Hinlet>)             SucGrp 646
      AA(IAptr+11) = <ri.Pinlet>                                                SucGrp 647
      AA(IAptr+12) = <ri.Hinlet>                                                SucGrp 648
      AA(IAptr+13) = <cs.CtrlSignal>                                            SucGrp 649
c                                                                               SucGrp 650
c                                                                               SucGrp 651
c ============ DESIGN CALCULATIONS ============================================ SucGrp 652
      CASE (111)                                                                SucGrp 653
c                                                                               SucGrp 654
c              Get the requirements of the suction circuit(s)                   SucGrp 655
      CALL RefgNode(Kri, <ri.Minlet>,<ri.Mreqd>, <ri.Hinlet>, xTreqd,           SucGrp 656
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     SucGrp 657
      IF (<ri.Minlet> .EQ. 0.)  RETURN                                          SucGrp 658
c                                                                               SucGrp 659
c              Suction pressure setpoint                                        SucGrp 660
      IF (<sg:DESIGN-SST> .NE. -66666.)  THEN                                   SucGrp 661
        SSTtop = <sg:DESIGN-SST>                                                SucGrp 662
      ELSEIF (<sg:TEMP-SETPT> .NE. -66666.)  THEN                               SucGrp 663
        SSTtop = <sg:TEMP-SETPT> + <sg:TEMP-THROTTLE>*0.5                       SucGrp 664
      ELSE                                                                      SucGrp 665
c              default to worst-case suction load                               SucGrp 666
        SSTtop = RefgT_fP(Jre, <ri.Preqd>)                                      SucGrp 667
      ENDIF                                                                     SucGrp 668
c                                                                               SucGrp 669
c              Conditions at inlet from suction circuits                        SucGrp 670
      <ri.Pinlet>  = RefgP_fT(Jre, SSTtop)                                      SucGrp 671
      <ri.Qinlet>  = <ri.Minlet> * (<ri.Hinlet>-AA(<sg;RefgHrefPtr>))           SucGrp 672
c              conditions at outlet to compressors                              SucGrp 673
      <ro.Moutlet> = <ri.Minlet>                                                SucGrp 674
      <ro.Qoutlet> = <ri.Qinlet>                                                SucGrp 675
      <ro.Houtlet> = <ri.Hinlet>                                                SucGrp 676
      IF (<sg;CompNode> .GT. 0)  THEN                                           SucGrp 677
c              Design each compressor                                           SucGrp 678
        <ro.Tsetpt>  = SSTtop                                                   SucGrp 679
        Kli = <ro;Xnode>                                                        SucGrp 680
        Neq = <li;NumItems>                                                     SucGrp 681
        DO  LI=1,Neq                                                            SucGrp 682
          CALL CompressorAlgs(Mode, <li;List>)                                  SucGrp 683
        ENDDO                                                                   SucGrp 684
      ENDIF                                                                     SucGrp 685
c                                                                               SucGrp 686
c              Auxiliary power                                                  SucGrp 687
      IF (<sg:AUX-METER> .GT. 0.)  THEN                                         SucGrp 688
        Kmd       = <sg:AUX-METER>                                              SucGrp 689
        <md.Elec> = <sg:AUX-KW>                                                 SucGrp 690
      ENDIF                                                                     SucGrp 691
c                                                                               SucGrp 692
c                                                                               SucGrp 693
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== SucGrp 694
      CASE (119)                                                                SucGrp 695
c                                                                               SucGrp 696
c              Must have non-zero design flow                                   SucGrp 697
      IF (<ri.Minlet> .EQ. 0.)  THEN                                            SucGrp 698
        CALL MSGSIM(-1,II,II,II,II)                                             SucGrp 699
        WRITE (IOUTPT,9005)  (<sg:NAME>,II=1,8)                                 SucGrp 700
        CALL MessageBox( NULL,                                                  SucGrp 701
     &    'A suction-group has zero design flow'//char(0),                      SucGrp 702
     &    'SUCTION-GROUP Errors'//char(0),                                      SucGrp 703
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  SucGrp 704
        IwinReturn = 1                                                          SucGrp 705
        RETURN                                                                  SucGrp 706
      ENDIF                                                                     SucGrp 707
c              Design suction temperature                                       SucGrp 708
      IF (<sg:DESIGN-SST> .EQ. -66666.)                                         SucGrp 709
     &    <sg:DESIGN-SST> = RefgT_fP(Jre, <ri.Pinlet>)                          SucGrp 710
      CALL RefgNode(Kri, <ri.Minlet>,xMreqd, <ri.Hinlet>, xTreqd,               SucGrp 711
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     SucGrp 712
c                                                                               SucGrp 713
c              Check if compressor capacity sufficient                          SucGrp 714
      IF (<sg;CompNode> .GT. 0)  THEN                                           SucGrp 715
        CALL RefgNode(Kro, Mcomp,xMreqd, xH, xTreqd,                            SucGrp 716
     &                     xPmin,xPmax, xPminReqd,xPmaxReqd)                    SucGrp 717
        IF (<ri.Minlet> .GT. Mcomp*1.01)  THEN                                  SucGrp 718
          CALL MSGSIM(-2,II,II,II,II)                                           SucGrp 719
          WRITE (IOUTPT,9004)  (<sg:NAME>,II=1,8),                              SucGrp 720
     &                          <ri.Minlet>, Mcomp                              SucGrp 721
        ENDIF                                                                   SucGrp 722
      ENDIF                                                                     SucGrp 723
c                                                                               SucGrp 724
c              Suction pressure setpoint                                        SucGrp 725
      IF (<sg:TEMP-SETPT> .EQ. -66666.)  THEN                                   SucGrp 726
        SSTreqd = RefgT_fP(Jre, <ri.Preqd>)                                     SucGrp 727
        <sg:TEMP-SETPT> = SSTreqd - <sg:TEMP-THROTTLE>*0.5                      SucGrp 728
      ENDIF                                                                     SucGrp 729
c              Maximum and minimum allowable setpoints                          SucGrp 730
      IF (<sg:MAX-TEMP-SETP> .NE. -66666.)  THEN                                SucGrp 731
        <sg;MaxCtrlSetpt> = <sg:MAX-TEMP-SETP>                                  SucGrp 732
      ELSE                                                                      SucGrp 733
        <sg;MaxCtrlSetpt> = 1.E10                                               SucGrp 734
      ENDIF                                                                     SucGrp 735
      IF (<sg:MIN-TEMP-SETP> .NE. -66666.)  THEN                                SucGrp 736
        <sg;MinCtrlSetpt> = <sg:MIN-TEMP-SETP>                                  SucGrp 737
      ELSE                                                                      SucGrp 738
        <sg;MinCtrlSetpt> = -1.E10                                              SucGrp 739
      ENDIF                                                                     SucGrp 740
c                                                                               SucGrp 741
c              Minimum refrigerant table temperature                            SucGrp 742
      RefgTmin  = RefgTableValue(Jre, 1, 1.)                                    SucGrp 743
c                                                                               SucGrp 744
c              Temp change/bin when cycling                                     SucGrp 745
      <sg;dTbin> = <sg:TEMP-THROTTLE> * 0.2                                     SucGrp 746
      IF (<sg:TEMP-THROTTLE> .NE. 0.)                                           SucGrp 747
     &  <sg;1/Throttle> = 1.0 / <sg:TEMP-THROTTLE>                              SucGrp 748
      <sg;Throttle/2> = <sg:TEMP-THROTTLE> / 2.                                 SucGrp 749
c                                                                               SucGrp 750
c              check if control range below table values                        SucGrp 751
      SSTbottom = <sg:DESIGN-SST> - <sg:TEMP-THROTTLE>                          SucGrp 752
      IF (SSTbottom .LT. RefgTmin)  THEN                                        SucGrp 753
        CALL MSGSIM(-1,II,II,II,II)                                             SucGrp 754
        WRITE (IOUTPT,9006)  (<sg:NAME>,II=1,8),                                SucGrp 755
     &                        RefgTmin, SSTbottom                               SucGrp 756
        CALL MessageBox( NULL,                                                  SucGrp 757
     &    'A suction-group control range is below'//char(10)//char(13)//        SucGrp 758
     &    ' the minimum value in the refrigerant table'//char(0),               SucGrp 759
     &    'SUCTION-GROUP Errors'//char(0),                                      SucGrp 760
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  SucGrp 761
        IwinReturn = 1                                                          SucGrp 762
        RETURN                                                                  SucGrp 763
      ENDIF                                                                     SucGrp 764
c                                                                               SucGrp 765
c              Initialize required pressure in suction node for                 SucGrp 766
c              hot-gas bypass                                                   SucGrp 767
      IF (<sg;HGBsucNode> .GT. 0)  THEN                                         SucGrp 768
        Krx = <sg;HGBsucNode>                                                   SucGrp 769
        <rx.Preqd> = 1.E10                                                      SucGrp 770
      ENDIF                                                                     SucGrp 771
c                                                                               SucGrp 772
c              Finish history on suction pressure, 0.5F error                   SucGrp 773
      ErrorP = RefgP_fT(Jre, <sg:DESIGN-SST>)                                   SucGrp 774
     &       - RefgP_fT(Jre, <sg:DESIGN-SST>-0.5)                               SucGrp 775
      CALL HstyError(<sg;SuctionHsty>, <#ri.Pinlet>, ErrorP)                    SucGrp 776
c                                                                               SucGrp 777
c                                                                               SucGrp 778
c ============ ATTACHMENTS ==================================================== SucGrp 779
c                                                                               SucGrp 780
c              Initial attachments                                              SucGrp 781
      CASE (201)                                                                SucGrp 782
c              Component pointers, schedules, and curves                        SucGrp 783
        <sg:/RefgSystem/>  = Jcomponent(29, <sg:/RefgSystem/>)                  SucGrp 784
        <sg:DISCHARGE-CKT> = Jcomponent(22, <sg:DISCHARGE-CKT>)                 SucGrp 785
        <sg:HGB-SUCTION>   = Jcomponent(22, <sg:HGB-SUCTION>)                   SucGrp 786
        <sg:HGB-LIQUID>    = Jcomponent(22, <sg:HGB-LIQUID>)                    SucGrp 787
        <sg:EQUIP-CTRL>    = Jcomponent(11, <sg:EQUIP-CTRL>)                    SucGrp 788
        <sg:AUX-METER>     = Jcomponent(13, <sg:AUX-METER>)                     SucGrp 789
        <sg:COST-DATA>     = Jcomponent(18, <sg:COST-DATA>)                     SucGrp 790
        <sg:TEMP-SETPT-SC> = Jsched(<sg:TEMP-SETPT-SC>)                         SucGrp 791
        <sg:AUX-SCH>       = Jsched(<sg:AUX-SCH>)                               SucGrp 792
c                                                                               SucGrp 793
c              Create nodes                                                     SucGrp 794
      CASE (203)                                                                SucGrp 795
        Jrs = <sg:/RefgSystem/>                                                 SucGrp 796
        Keu = NewEndUse(Jsg)                                                    SucGrp 797
c              Inlet and outlet                                                 SucGrp 798
        <sg;SuctionNode> = NewNode(1, Jrs,Jsg,Jsg,0, 62,1,Keu, 1.)              SucGrp 799
        <sg;CompNode>    = NewNode(1,   0,Jsg,Jsg,0, 62,2,Keu, 1.)              SucGrp 800
c              Hot-gas bypass interface to suction, liquid, and                 SucGrp 801
c              discharge circuits                                               SucGrp 802
        IF (<sg:HOT-GAS-BYPAS> .EQ. 1)  THEN                                    SucGrp 803
c              Check for cross-connected systems                                SucGrp 804
          CALL RefgX(Jsg, <sg:DISCHARGE-CKT>,                                   SucGrp 805
     &                               <sg:HGB-SUCTION>,<sg:HGB-LIQUID>)          SucGrp 806
          IF (<sg:HGB-SUCTION> .GT. 0)  THEN                                    SucGrp 807
c              feed bypassed-gas into an upstream suction circuit               SucGrp 808
            <sg;HGBsucNode> = NewNode(1, Jrs,Jsg,Jsg,<sg:HGB-SUCTION>,          SucGrp 809
     &                                                       62,2,0, 1.)        SucGrp 810
          ELSE                                                                  SucGrp 811
            <sg;HGBsucNode> = NewNode(1, Jrs,Jsg,Jsg,Jsg,    62,2,0, 1.)        SucGrp 812
          ENDIF                                                                 SucGrp 813
c              liquid to desuperheat bypassed gas                               SucGrp 814
          IF (<sg:HGB-LIQUID> .GT. 0)                                           SucGrp 815
     &      <sg;HGBliqNode> = NewNode(1, Jrs,Jsg,Jsg,<sg:HGB-LIQUID>,           SucGrp 816
     &                                                       61,1,0, 1.)        SucGrp 817
c              draw bypassed gas from discharge                                 SucGrp 818
          <sg;HGBhiNode> = NewNode(1, Jrs,Jsg,Jsg,<sg:DISCHARGE-CKT>,           SucGrp 819
     &                                                       63,2,0, 1.)        SucGrp 820
c              Check hot gas bypass connections                                 SucGrp 821
          IF (<sg:HGB-SUCTION> .GT. 0)  THEN                                    SucGrp 822
            Jrc = <sg:HGB-SUCTION>                                              SucGrp 823
            IF (<rc:/SuctionGroup> .NE. Jsg)  THEN                              SucGrp 824
              CALL MSGSIM(-1,II,II,II,II)                                       SucGrp 825
              WRITE (IOUTPT,9010) (<sg:NAME>,II=1,8)                            SucGrp 826
              CALL MessageBox( NULL,                                            SucGrp 827
     &          'Hot-gas bypass may not crossconnect suction groups'            SucGrp 828
     &                                                        //char(0),        SucGrp 829
     &          'SUCTION-GROUP Errors'//char(0),                                SucGrp 830
     &           MB_OK + MB_ICONSTOP + MB_TASKMODAL )                           SucGrp 831
              IwinReturn = 1                                                    SucGrp 832
              RETURN                                                            SucGrp 833
            ENDIF                                                               SucGrp 834
          ENDIF                                                                 SucGrp 835
        ENDIF                                                                   SucGrp 836
c              Control block for compressors                                    SucGrp 837
        <sg;CtrlNode> = NewNode(1, 0,0,Jsg,0, 21,1,0, 0.)                       SucGrp 838
c              Auxiliary meter                                                  SucGrp 839
        IF (<sg:AUX-METER> .GT. 0)  THEN                                        SucGrp 840
          Jme = <sg:AUX-METER>                                                  SucGrp 841
          <sg:AUX-METER>= NewNode(1, Jrs,Jsg,Jsg,Jme, 11,2,7, 1.)               SucGrp 842
        ENDIF                                                                   SucGrp 843
c                                                                               SucGrp 844
c              Create nodes, 2nd call                                           SucGrp 845
      CASE (204)                                                                SucGrp 846
c              See if any compressors attached.  If not, create                 SucGrp 847
c              discharge node                                                   SucGrp 848
        IF (LocateNode(0,0,0,Jsg, 62,1) .EQ. 0)  THEN                           SucGrp 849
          CALL MSGSIM(-2,II,II,II,II)                                           SucGrp 850
          WRITE (IOUTPT, 9002) (<sg:NAME>,II=1,8)                               SucGrp 851
          CALL DetachNode(<sg;CompNode>)                                        SucGrp 852
          Jrc = <sg:DISCHARGE-CKT>                                              SucGrp 853
          I   = 60 + <rc:TYPE>                                                  SucGrp 854
          <sg;DischargeNode> = NewNode(1, <sg:/RefgSystem/>,Jsg,Jsg,Jrc,        SucGrp 855
     &                                                        I,2,0, 1.)        SucGrp 856
        ENDIF                                                                   SucGrp 857
c                                                                               SucGrp 858
c              Links, lists                                                     SucGrp 859
      CASE (205)                                                                SucGrp 860
c              Get refrigerant pointer from refg plant                          SucGrp 861
        Jrs              = <sg:/RefgSystem/>                                    SucGrp 862
        <sg;Refrigerant> = <rs:REFRIGERANT>                                     SucGrp 863
c              Get pointer to reference enthalpy from liquid trunk              SucGrp 864
        <sg;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     SucGrp 865
c                                                                               SucGrp 866
c              Inlet side                                                       SucGrp 867
        IF (<ri;Xnode> .EQ. 0)  THEN                                            SucGrp 868
          CALL MSGSIM(-1,II,II,II,II)                                           SucGrp 869
          WRITE (IOUTPT, 9001)  (<sg:NAME>,II=1,8)                              SucGrp 870
          CALL MessageBox( NULL,                                                SucGrp 871
     &      'A suction-group must have a suction circuit'//char(0),             SucGrp 872
     &      'SUCTION-GROUP Errors'//char(0),                                    SucGrp 873
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SucGrp 874
          IwinReturn = 1                                                        SucGrp 875
          RETURN                                                                SucGrp 876
        ENDIF                                                                   SucGrp 877
c                                                                               SucGrp 878
c              Nodes in suction-group/compressor subsystem                      SucGrp 879
        CALL ListNodes(<sg;SubSysNodes>, Jrs,Jsg,0,0, 0,0)                      SucGrp 880
c              Nodes in subsystem plus suction circuits, desuperheaters         SucGrp 881
        CALL ListNodes(<sg;SystemNodes>, Jrs,-Jsg,0,0, 0,0)                     SucGrp 882
        CALL ListAdd  (<sg;SystemNodes>, <sg;SubSysNodes>)                      SucGrp 883
c                                                                               SucGrp 884
c              Links, lists, 2nd call                                           SucGrp 885
      CASE (206)                                                                SucGrp 886
c                                                                               SucGrp 887
c              Store pointers to cross-linked hot-gas bypass component          SucGrp 888
c              nodes for easy hourly access.                                    SucGrp 889
        IF (<sg:HOT-GAS-BYPAS> .EQ. 1)  THEN                                    SucGrp 890
          <sg;HGBsucXnode> = KXXComponent(<sg;HGBsucNode>)                      SucGrp 891
          IF(<sg;HGBliqNode> .GT. 0)                                            SucGrp 892
     &      <sg;HGBliqXnode> = KXXComponent(<sg;HGBliqNode>)                    SucGrp 893
          <sg;HGBhiXnode>  = KXXComponent(<sg;HGBhiNode>)                       SucGrp 894
        ENDIF                                                                   SucGrp 895
c                                                                               SucGrp 896
c              Histories                                                        SucGrp 897
      CASE (208)                                                                SucGrp 898
        Jrs = <sg:/RefgSystem/>                                                 SucGrp 899
c              Suction pressure - ErrorP will be updated during design          SucGrp 900
        <sg;SuctionHsty> = NewHistory(Jrs,Jsg,Jsg, <ri;Xnode>, 0,               SucGrp 901
     &                       5, 10, 1.25,                                       SucGrp 902
     &                       <#ri.Pinlet>, <sp:ERROR-P>, 1,                     SucGrp 903
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)            SucGrp 904
        IF (<sg;CompNode> .EQ. 0)  THEN                                         SucGrp 905
          <sg;DischargeHsty> = NewHistory(Jrs,Jsg,Jsg, <ro;Xnode>, 0,           SucGrp 906
     &                           0, 0, 1.25,                                    SucGrp 907
     &                           <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,             SucGrp 908
     &                           <#ro.Houtlet>,    <sp:ERROR-H>, 1,             SucGrp 909
     &                           0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                SucGrp 910
        ENDIF                                                                   SucGrp 911
c                                                                               SucGrp 912
c              Hot-gas bypass history                                           SucGrp 913
        IF (<sg:HOT-GAS-BYPAS> .EQ. 1)  THEN                                    SucGrp 914
          Kli = 0                                                               SucGrp 915
          CALL ListAdd(Kli, <sg;HGBsucNode>)                                    SucGrp 916
          CALL ListAdd(Kli, <sg;HGBhiNode>)                                     SucGrp 917
          IF(<sg;HGBliqNode> .GT. 0)                                            SucGrp 918
     &      CALL ListAdd(Kli, <sg;HGBliqNode>)                                  SucGrp 919
          KliX = 0                                                              SucGrp 920
          CALL ListXNodes(Kli, KliX)                                            SucGrp 921
          Kro = <sg;HGBsucNode>                                                 SucGrp 922
          <sg;HGBHsty> = NewHistory(Jrs,Jsg,Jsg, KliX, Kli,                     SucGrp 923
     &                     5, 3, 1.,                                            SucGrp 924
     &                     <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                   SucGrp 925
     &                     <#ro.Houtlet>,    <sp:ERROR-H>, 1,                   SucGrp 926
     &                     0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                      SucGrp 927
        ENDIF                                                                   SucGrp 928
c                                                                               SucGrp 929
c              History lists                                                    SucGrp 930
      CASE (209)                                                                SucGrp 931
c              Histories in suction-group/compressor subsystem                  SucGrp 932
        CALL ListHstys(<sg;SubSysHstys>, 0, Jsg, 0)                             SucGrp 933
c              Histories in subsystem plus suction circuits, desuperheaters     SucGrp 934
        CALL ListHstys(<sg;SystemHstys>, 0, -Jsg, 0)                            SucGrp 935
        CALL ListAdd  (<sg;SystemHstys>, <sg;SubSysHstys>)                      SucGrp 936
c                                                                               SucGrp 937
c              Dump pointers                                                    SucGrp 938
      CASE (210)                                                                SucGrp 939
        IF (<sg;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         SucGrp 940
        WRITE (IOUTPT, 9202)  (<sg:NAME>,II=1,8),                               SucGrp 941
     &    Jsg, <sg;SuctionNode>, <sg;CompNode>, <sg;DischargeNode>,             SucGrp 942
     &    <sg;HGBsucNode>, <sg;HGBliqNode>, <sg;HGBhiNode>,                     SucGrp 943
     &    <sg;CtrlNode>                                                         SucGrp 944
c                                                                               SucGrp 945
c                                                                               SucGrp 946
      END SELECT  ! Mode                                                        SucGrp 947
c                                                                               SucGrp 948
      RETURN                                                                    SucGrp 949
c                                                                               SucGrp 950
c              Message formats                                                  SucGrp 951
 9001 FORMAT(                                                                   SucGrp 952
     &14x,'Suction-group: ',8A4,' has no suction'                      /        SucGrp 953
     &14x,'circuits attached.'                                         )        SucGrp 954
 9002 FORMAT(                                                                   SucGrp 955
     &14x,'Suction-group: ',8A4,' has no compressors'                  /        SucGrp 956
     &14x,'The suction temperature setpoint will be maintained all'    /        SucGrp 957
     &14x,'hours, and no compressor energy will be calculated.'        )        SucGrp 958
 9004 FORMAT(                                                                   SucGrp 959
     &14x,'Suction-group: ',8A4,' has a design'                        /        SucGrp 960
     &14x,'refrigerant flow of',F8.1,' lbs/hr, but the design '        /        SucGrp 961
     &14x,'compressor capacity is only',F8.1,' lbs/hr.'                )        SucGrp 962
 9005 FORMAT(                                                                   SucGrp 963
     &14x,'Suction-group: ',8A4,' has no design flow'                  )        SucGrp 964
 9006 FORMAT(                                                                   SucGrp 965
     &14x,'Suction-group: ',8A4,' has a control range'                 /        SucGrp 966
     &14x,'outside the bounds of the refrigerant table.'               /        SucGrp 967
     &14x,'Table minimum: ',F5.0,' Minimum setpoint: ',F5.0            )        SucGrp 968
 9007 FORMAT(                                                                   SucGrp 969
     &14x,'Compressor: ',8A4,' has a capacity'                  /               SucGrp 970
     &14x,'performance curve that is unstable below',F6.1,'F, but the' /        SucGrp 971
     &14x,'bottom of the suction-group throttling range is:',F6.1,'F'  )        SucGrp 972
 9008 FORMAT(                                                                   SucGrp 973
     &14x,'Compressor: ',8A4,' has a capacity'                         /        SucGrp 974
     &14x,'performance curve that is unstable below',F6.1,' PLR'       /        SucGrp 975
     &14x,'Operation will be restricted to this range.'                )        SucGrp 976
 9009 FORMAT(                                                                   SucGrp 977
     &14x,'Suction-group: ',8A4,' throttling range'                    /        SucGrp 978
     &14x,'is limited by the bounds of the refrigerant table.'         )        SucGrp 979
 9010 FORMAT(                                                                   SucGrp 980
     &14x,'Suction-group: ',8A4,' has hot gas bypass'                  /        SucGrp 981
     &14x,'attached to a suction circuit that does not feed this'      /        SucGrp 982
     &14x,'suction-group.'                                             )        SucGrp 983
 9101 FORMAT(                                                                   SucGrp 984
     &14x,'Suction-group: ',8A4,' has inadequate'                      /        SucGrp 985
     &14x,'compressor capacity to handle the required mass flow at the'/        SucGrp 986
     &14x,'suction setpoint.  Suction pressure will float up until a'  /        SucGrp 987
     &14x,'balance point is reached.  Loads may become undercooled.'   /        SucGrp 988
     &14x,'First occurrence:',3I3                                      )        SucGrp 989
 9102 FORMAT(                                                                   SucGrp 990
     &14x,'Suction-group: ',8A4,' SST has failed to'                   /        SucGrp 991
     &14x,'to converge.  Simulation results may be erroneous. If'      /        SucGrp 992
     &14x,'compressor capacity is also inadequate, try specifying a'   /        SucGrp 993
     &14x,'greater capacity. First occurrence: ',I2,'/',I2,'/',I2      )        SucGrp 994
 9103 FORMAT(                                                                   SucGrp 995
     &14x,'Suction-Group: ',8A4,' has exceeded'                        /        SucGrp 996
     &14x,'the upper limit of suction temperature on a compressor'     /        SucGrp 997
     &14x,'capacity curve and cannot solve for the balance point.'     /        SucGrp 998
     &14x,'Compressors will operate at the top of their curve which'   /        SucGrp 999
     &14x,'may cause compressor power and discharge mass flow rates to'/        SucGrp1000
     &14x,'be understated.  First occurence: ',I2,'/',I2,'/',I2        )        SucGrp1001
 9104 FORMAT(                                                                   SucGrp1002
     &14x,'Suction-Group: ',8A4,' has exceeded'                        /        SucGrp1003
     &14x,'the lower limit of suction temperature on a compressor'     /        SucGrp1004
     &14x,'capacity curve and cannot solve for the balance point.'     /        SucGrp1005
     &14x,'Compressors will operate at the bottom of their curve which'/        SucGrp1006
     &14x,'may cause compressor power and discharge mass flow rates to'/        SucGrp1007
     &14x,'be overstated.  First occurence: ',I2,'/',I2,'/',I2         )        SucGrp1008
 9105 FORMAT(                                                                   SucGrp1009
     &14x,'Suction-group: ',8A4,' has a suction'                       /        SucGrp1010
     &14x,'temperature higher than required by the worst case load.'   /        SucGrp1011
     &14x,'Loads may float. Peak occurrance:',I2,'/',I2,'/',I2         /        SucGrp1012
     &14x,'Suction T/Required T:',2F7.2                                )        SucGrp1013
 9106 FORMAT(                                                                   SucGrp1014
     &14x,'Compressor cycling error: ',8A4                             )        SucGrp1015
 9201 FORMAT(/' SUCTION-GROUPs                         Jsg   Suction',          SucGrp1016
     &'      Comp    Dischg   HGB Suc   HGB Liq    HGB Hi      Ctrl'   /        SucGrp1017
     &1x,32('-'),8('  --------'))                                               SucGrp1018
 9202 FORMAT(1x,8A4,8I10)                                                       SucGrp1019
c                                                                               SucGrp1020
c                                                                               SucGrp1021
      CONTAINS                                                                  SucGrp1022
c ============== CompressorCapacity =========================================== SucGrp1023
      Subroutine CompressorCapacity                                             SucGrp1024
c                                                                               SucGrp1025
c              Gets the capacity of the selected mix of compressors             SucGrp1026
c              at the current conditions                                        SucGrp1027
c                                                                               SucGrp1028
      Mcomp = 0.                                                                SucGrp1029
      DO  LI=1,Ncomp                                                            SucGrp1030
        Krx = <li;List>                                                         SucGrp1031
c              load allocation routine set rx,RunFrac as a flag                 SucGrp1032
        IF (<rx.RunFrac> .GT. 0.)  THEN                                         SucGrp1033
          CALL CompressorAlgs(21, Krx)                                          SucGrp1034
          Mcomp = Mcomp + <rx.MaxMrefg>                                         SucGrp1035
        ENDIF                                                                   SucGrp1036
      ENDDO                                                                     SucGrp1037
c                                                                               SucGrp1038
      End Subroutine CompressorCapacity                                         SucGrp1039
c                                                                               SucGrp1040
c                                                                               SucGrp1041
c ============== FindBalancePoint ============================================= SucGrp1042
      Subroutine FindBalancePoint                                               SucGrp1043
c                                                                               SucGrp1044
c              Solves for the balance point between suction temperature         SucGrp1045
c              and compressor mass flow by using an interpolating               SucGrp1046
c              bi-sectional search                                              SucGrp1047
c                                                                               SucGrp1048
      Denom = 1.0 / <ri.Minlet>                                                 SucGrp1049
      DO  nFindBal=1,100                                                        SucGrp1050
c              Interpolate for SST between solution boundaries                  SucGrp1051
        Ratio       = (<ri.Minlet>-CapMin) / (CapMax-CapMin)                    SucGrp1052
        Ratio       = MIN(0.85, MAX(0.15, Ratio))                               SucGrp1053
        <ro.Tsetpt> = SSTmin + (SSTmax-SSTmin)*Ratio                            SucGrp1054
c              pumping capacity at this SST                                     SucGrp1055
        IF (<sg:TEMP-CTRL> .NE. 0)  THEN                                        SucGrp1056
c              suction group has a control setpoint                             SucGrp1057
          <cs.CtrlSignal> = (<ro.Tsetpt>-SSTbottom)*<sg;1/Throttle>             SucGrp1058
          <cs.CtrlSignal> = MAX(0., MIN(1., <cs.CtrlSignal>))                   SucGrp1059
        ENDIF                                                                   SucGrp1060
        Call CompressorCapacity                                                 SucGrp1061
c              compare capacity to required flow                                SucGrp1062
        Error = 1. - Mcomp*Denom                                                SucGrp1063
        IF (ABS(Error) .LT. <sp:ERROR-FLOW>)  EXIT                              SucGrp1064
c              tighten the solution boundaries                                  SucGrp1065
        IF (Mcomp .GT. <ri.Minlet>)  THEN                                       SucGrp1066
          SSTmax = <ro.Tsetpt>                                                  SucGrp1067
          CapMax = Mcomp                                                        SucGrp1068
        ELSE                                                                    SucGrp1069
          SSTmin = <ro.Tsetpt>                                                  SucGrp1070
          CapMin = Mcomp                                                        SucGrp1071
        ENDIF                                                                   SucGrp1072
        IF (nFindBal .EQ. 100)  CALL CnvgMsg2(3, Routine, Jsg)                  SucGrp1073
      ENDDO  ! nFindBal                                                         SucGrp1074
c                                                                               SucGrp1075
      End Subroutine FindBalancePoint                                           SucGrp1076
c                                                                               SucGrp1077
c                                                                               SucGrp1078
c ============== RunAtBalancePoint ============================================ SucGrp1079
      Subroutine RunAtBalancePoint                                              SucGrp1080
c                                                                               SucGrp1081
c              Runs selected mix of compressors at balance point                SucGrp1082
      <cs.RunFrac> = 1.                                                         SucGrp1083
      Mcomp        = 0.                                                         SucGrp1084
      DO  LI=1,Ncomp                                                            SucGrp1085
        Krx = <li;List>                                                         SucGrp1086
c              initialize compressor bins                                       SucGrp1087
        CALL CompressorAlgs(32, Krx)                                            SucGrp1088
c              simulate for the entire hour                                     SucGrp1089
        IF (<rx.RunFrac> .GT. 0.)  THEN                                         SucGrp1090
          CALL CompressorAlgs(33, Krx)                                          SucGrp1091
          Mcomp = Mcomp + <rx.Mrefg>                                            SucGrp1092
        ENDIF                                                                   SucGrp1093
      ENDDO                                                                     SucGrp1094
c              average saturated suction temperature, run time                  SucGrp1095
      <sg;SST>    = <ro.Tsetpt>                                                 SucGrp1096
      FracCycleOn = 1.0                                                         SucGrp1097
c              Set correction factor to force compressor(s) to conserve         SucGrp1098
c              refrigerant flow                                                 SucGrp1099
      <cs.Adjustment> = <ri.Minlet> / Mcomp                                     SucGrp1100
c                                                                               SucGrp1101
      End Subroutine RunAtBalancePoint                                          SucGrp1102
c                                                                               SucGrp1103
      END                                                                       SucGrp1104
      SUBROUTINE Refg_EquipCtrl(Jec, JecLast,                                   REqCtl   2
     &                        Kli, Mrefg, RunFrac, FlowCap, KrxLast)            REqCtl   3
c                                                                               REqCtl   4
c              Allocates a refrigerant flow to a set of refrigeration           REqCtl   5
c              equipment components using a user-specified control              REqCtl   6
c              sequence.                                                        REqCtl   7
c                                                                               REqCtl   8
c              Control can be specified for up to 5 flow ranges.  The           REqCtl   9
c              keywords and EDTT variables for each flow range are              REqCtl  10
c              identical except for the number of the range (1-5); this         REqCtl  11
c              routine uses the EDTT variables of the first range for           REqCtl  12
c              all ranges.                                                      REqCtl  13
c                                                                               REqCtl  14
c              Jec          Pointer to equip-ctrl sequence                      REqCtl  15
c              JecLast      Last equip-ctrl sequence used by calling            REqCtl  16
c                              component                                        REqCtl  17
c              Kli          List of all equipment attached to calling           REqCtl  18
c                              component                                        REqCtl  19
c              Mrefg        Required flow, hourly                               REqCtl  20
c              RunFrac      Fraction of hour flow exists                        REqCtl  21
c              FlowCap      Flow capacity of all active equipment               REqCtl  22
c              KrxLast      Pointer to last unit turned on                      REqCtl  23
c                                                                               REqCtl  24
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /EqCtrl/ LengthLoadRange, xEqCtrl                                 /EqCtrl/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /SimDat/ NumMechIter, NumMechFail, xSimDat                        /SimDat/ 2
c                                                                               REqCtl  31
                                                                                REqCtl  32
      Real      Mrefg, Mcycle                                                   REqCtl  33
      Logical   FlowSatisfied                                                   REqCtl  34
      Dimension CapMax(10)                                                      REqCtl  35
                                                                                REqCtl  36
c              Mcycle is the hourly flow adjusted for equipment cycling         REqCtl  37
      IF (RunFrac .gt. 0.) THEN                                                 REqCtl  38
        Mcycle  = Mrefg / RunFrac                                               REqCtl  39
      ELSE                                                                      REqCtl  40
        Mcycle  = Mrefg                                                         REqCtl  41
        RunFrac = 1.                                                            REqCtl  42
        CALL MSGSIM(-1,II,II,II,II)                                             REqCtl  43
        WRITE (IOUTPT,9001)                                                     REqCtl  44
      ENDIF                                                                     REqCtl  45
                                                                                REqCtl  46
      FlowCap       = 0.               ! total enabled capacity                 REqCtl  47
      ProrateFlow   = Mcycle           ! flow to be prorated to equipment       REqCtl  48
      ProrateCap    = 0.                                                        REqCtl  49
      FlowSatisfied = .FALSE.          ! True if the flow is satisfied          REqCtl  50
      KrxLast       = 0                ! Last equipment unit turned on          REqCtl  51
                                                                                REqCtl  52
c              Check if using same equip-ctrl sequence as last time             REqCtl  53
      IF (Jec .EQ. JecLast  .or.  NumMechIter .gt. 15)  THEN                    REqCtl  54
c              Capacity using last hour's or iteration's equipment mix          REqCtl  55
        CapLast  = 0.                  ! capacity of last mix                   REqCtl  56
        FlowLast = 0.                  ! flow of last mix                       REqCtl  57
        IR              = <ec;LastLoadRange>                                    REqCtl  58
        NumEquipInRange = <ec;NumEquipInRng>    ! using IR index                REqCtl  59
        IIstart         = (IR-1)*LengthLoadRange                                REqCtl  60
        DO  Neq=1,NumEquipInRange                                               REqCtl  61
          II  = IIstart + Neq                                                   REqCtl  62
          Krx = <ec;EQUIP>                                                      REqCtl  63
          IF (<rx.RunFrac> .GT. 0.)  THEN                                       REqCtl  64
            CapLast  = CapLast  + MIN(<rx.MaxMrefg>,<ec;EQUIP-MAX-LD>)          REqCtl  65
            FlowLast = FlowLast + <rx.Mrefg>                                    REqCtl  66
          ENDIF                                                                 REqCtl  67
        ENDDO                                                                   REqCtl  68
c                                                                               REqCtl  69
        IF (NumMechIter .gt. 15  .and.  CapLast .gt. Mcycle)  THEN              REqCtl  70
c              Last mix is still suitable and oscillating                       REqCtl  71
          FlowSatisfied = .TRUE.                                                REqCtl  72
          FlowCap       = CapLast                                               REqCtl  73
          KrxLast       = <ec;KrxLast>                                          REqCtl  74
          Prorate       = Mrefg / FlowLast                                      REqCtl  75
          DO  Neq=1,NumEquipInRange                                             REqCtl  76
            II  = IIstart + Neq                                                 REqCtl  77
            Krx = <ec;EQUIP>                                                    REqCtl  78
            <rx.Mrefg>   = <rx.Mrefg> * Prorate                                 REqCtl  79
            <rx.RunFrac> = RunFrac                                              REqCtl  80
          ENDDO                                                                 REqCtl  81
          RETURN                                                                REqCtl  82
        ENDIF                                                                   REqCtl  83
      ENDIF  ! Jec .eq. JecLast                                                 REqCtl  84
c                                                                               REqCtl  85
c              Initialize flows                                                 REqCtl  86
      Neq = <li;NumItems>                                                       REqCtl  87
      DO  LI=1,Neq                                                              REqCtl  88
        Krx          = <li;List>                                                REqCtl  89
        <rx.Mrefg>   = 0.                                                       REqCtl  90
        <rx.RunFrac> = 0.                                                       REqCtl  91
      ENDDO                                                                     REqCtl  92
c                                                                               REqCtl  93
c              Find the correct range                                           REqCtl  94
      NumLoadRanges = <ec;NumLoadRanges>                                        REqCtl  95
      DO  Nrange=1,NumLoadRanges                                                REqCtl  96
        IR = Nrange                                                             REqCtl  97
        IF (<ec:FLOWS-THRU> .NE. 0.)  THEN                                      REqCtl  98
c              user-specified load range                                        REqCtl  99
          CapRange = <ec:FLOWS-THRU>                                            REqCtl 100
        ELSE                                                                    REqCtl 101
c              default range to equipment capacity                              REqCtl 102
          NumEquipInRange = <ec;NumEquipInRng>    ! using IR index              REqCtl 103
          CapRange        = 0.                                                  REqCtl 104
          IIstart         = (IR-1)*LengthLoadRange                              REqCtl 105
          DO  Neq=1,NumEquipInRange                                             REqCtl 106
            II       = IIstart + Neq                                            REqCtl 107
            Krx      = <ec;EQUIP>                                               REqCtl 108
            CapRange = CapRange + MIN(<rx.MaxMrefg>,<ec;EQUIP-MAX-LD>)          REqCtl 109
          ENDDO                                                                 REqCtl 110
        ENDIF    ! CapRange calc                                                REqCtl 111
        IF (Mcycle .LE. CapRange)  EXIT                                         REqCtl 112
      ENDDO  ! Nrange                                                           REqCtl 113
c                                                                               REqCtl 114
c              Correct range has been found - get maximum sequence number       REqCtl 115
      NumEquipInRange = <ec;NumEquipInRng>  ! using IR index                    REqCtl 116
      MaxSequenceNum  = <ec;MaxSeqNum>      ! using IR index                    REqCtl 117
      DO  Neq=1,NumEquipInRange                                                 REqCtl 118
        CapMax(Neq) = 0.                                                        REqCtl 119
      ENDDO                                                                     REqCtl 120
c                                                                               REqCtl 121
c              Loop thru and turn on enough equipment to satisfy flow.  If      REqCtl 122
c              any unit of a given sequence number is activated, all            REqCtl 123
c              equipment having the same sequence number must be activated,     REqCtl 124
c              even if the flow has already been satisfied.                     REqCtl 125
      IIstart = (IR-1)*LengthLoadRange                                          REqCtl 126
      DO  NumSeq=1,MaxSequenceNum                                               REqCtl 127
c              maximum capacity of all equipment having this sequence number    REqCtl 128
        CapSeq = 0.                                                             REqCtl 129
        DO  Neq=1,NumEquipInRange                                               REqCtl 130
          II = IIstart + Neq                                                    REqCtl 131
          IF (<ec;EQUIP-SEQ> .EQ. NumSeq)  THEN                                 REqCtl 132
            Krx     = <ec;EQUIP>                                                REqCtl 133
            KrxLast = Krx                                                       REqCtl 134
c              limit maximum output                                             REqCtl 135
            CapMax(Neq) = MIN(<rx.MaxMrefg>, <ec;EQUIP-MAX-LD>)                 REqCtl 136
            CapSeq      = CapSeq + CapMax(Neq)                                  REqCtl 137
          ENDIF                                                                 REqCtl 138
        ENDDO                                                                   REqCtl 139
c              increment total loop capacity and proration capacity by          REqCtl 140
c              new capacity to be prorated                                      REqCtl 141
        FlowCap    = FlowCap    + CapSeq                                        REqCtl 142
        ProrateCap = ProrateCap + CapSeq                                        REqCtl 143
c              see if equipment activated so far can handle the load            REqCtl 144
        IF (FlowCap .GT. Mcycle)  THEN                                          REqCtl 145
          FlowSatisfied = .TRUE.                                                REqCtl 146
          EXIT                                                                  REqCtl 147
        ENDIF                                                                   REqCtl 148
      ENDDO    ! NumSeq                                                         REqCtl 149
c                                                                               REqCtl 150
c              Prorate the flow to all activated equipment.                     REqCtl 151
      IF (FlowSatisfied)  THEN                                                  REqCtl 152
        Prorate = ProrateFlow/ProrateCap * RunFrac                              REqCtl 153
        DO  Neq=1,NumEquipInRange                                               REqCtl 154
          II         = IIstart + Neq                                            REqCtl 155
          Krx        = <ec;EQUIP>                                               REqCtl 156
          <rx.Mrefg> = CapMax(Neq) * Prorate                                    REqCtl 157
          IF (<rx.Mrefg> .GT. 0.)  THEN                                         REqCtl 158
            <rx.RunFrac> = RunFrac                                              REqCtl 159
          ELSE                                                                  REqCtl 160
            <rx.RunFrac> = 0.                                                   REqCtl 161
          ENDIF                                                                 REqCtl 162
        ENDDO                                                                   REqCtl 163
      ELSE                                                                      REqCtl 164
c              overload - prorate based on design flow                          REqCtl 165
        ProrateCap = 0.                                                         REqCtl 166
        DO  Neq=1,NumEquipInRange                                               REqCtl 167
          II           = IIstart + Neq                                          REqCtl 168
          Krx          = <ec;EQUIP>                                             REqCtl 169
          ProrateCap   = ProrateCap + <rx;DesMrefg>                             REqCtl 170
        ENDDO                                                                   REqCtl 171
        Prorate = ProrateFlow/ProrateCap * RunFrac                              REqCtl 172
        DO  Neq=1,NumEquipInRange                                               REqCtl 173
          II           = IIstart + Neq                                          REqCtl 174
          Krx          = <ec;EQUIP>                                             REqCtl 175
          <rx.RunFrac> = RunFrac                                                REqCtl 176
          <rx.Mrefg>   = <rx;DesMrefg> * Prorate                                REqCtl 177
        ENDDO                                                                   REqCtl 178
      ENDIF                                                                     REqCtl 179
c                                                                               REqCtl 180
c              Store index to the load-range for next call                      REqCtl 181
      <ec;LastLoadRange> = IR                                                   REqCtl 182
      <ec;KrxLast>       = KrxLast                                              REqCtl 183
c                                                                               REqCtl 184
      RETURN                                                                    REqCtl 185
                                                                                REqCtl 186
c              Message formats                                                  REqCtl 187
 9001 FORMAT(14x,'Programmer Error: Refg_EquipCtrl was called'         /        REqCtl 188
     &14x,'with RunFrac = 0'                                           )        REqCtl 189
      END                                                                       REqCtl 190
      SUBROUTINE Refg_EquipCtrlDefault(Kli, Mrefg, RunFrac, FlowCap,            REqCtlD  2
     &                                 KrxSmallest)                             REqCtlD  3
c                                                                               REqCtlD  4
c              Allocates refrigerant flows to components when                   REqCtlD  5
c              no EQUIP-CTRL is specified.                                      REqCtlD  6
c                                                                               REqCtlD  7
c              Finds the combination of equipment that best matches the         REqCtlD  8
c              load with equipment loaded as fully as possible.  Uses           REqCtlD  9
c              the method of comparing all possibilities.                       REqCtlD 10
c                                                                               REqCtlD 11
c              Mode         Calling mode                                        REqCtlD 12
c                               0 = Always use best mix                         REqCtlD 13
c                               1 = Use last mix if meets load                  REqCtlD 14
c              Kli          Pointer to list of component nodes                  REqCtlD 15
c              Mrefg        Refrigerant flow, lbs/hr                            REqCtlD 16
c              RunFrac      Fraction of hour flow exists                        REqCtlD 17
c              FlowCap      Capacity of selected equipment mix, lbs/hr          REqCtlD 18
c              KrxSmallest  Pointer to component with smallest capacity         REqCtlD 19
c                                                                               REqCtlD 20
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /SimDat/ NumMechIter, NumMechFail, xSimDat                        /SimDat/ 2
c                                                                               REqCtlD 26
c                                                                               REqCtlD 27
      Real    Mrefg, Mcycle                                                     REqCtlD 28
      Integer BestCode                                                          REqCtlD 29
      Logical FlowSatisfied                                                     REqCtlD 30
                                                                                REqCtlD 31
c              Mcycle is the hourly flow adjusted for equipment cycling         REqCtlD 32
      IF (RunFrac .gt. 0.) THEN                                                 REqCtlD 33
        Mcycle  = Mrefg / RunFrac                                               REqCtlD 34
      ELSE                                                                      REqCtlD 35
        Mcycle  = Mrefg                                                         REqCtlD 36
        RunFrac = 1.                                                            REqCtlD 37
        CALL MSGSIM(-1,II,II,II,II)                                             REqCtlD 38
        WRITE (IOUTPT,9001)                                                     REqCtlD 39
      ENDIF                                                                     REqCtlD 40
                                                                                REqCtlD 41
      Neq      = <li;NumItems>         ! number of components                   REqCtlD 42
      Smallest = 1.E10                 ! capacity of smallest component         REqCtlD 43
                                                                                REqCtlD 44
      CapOp    = 0.                    ! total capacity                         REqCtlD 45
      CapLast  = 0.                    ! capacity of last mix                   REqCtlD 46
      FlowLast = 0.                    ! flow of last mix                       REqCtlD 47
      DO  LI=1,Neq                                                              REqCtlD 48
        Krx      = <li;List>                                                    REqCtlD 49
        CapOp    = CapOp    + <rx.MaxMrefg>                                     REqCtlD 50
        IF (<rx.RunFrac> .GT. 0.)  THEN                                         REqCtlD 51
          CapLast  = CapLast  + <rx.MaxMrefg>                                   REqCtlD 52
          FlowLast = FlowLast + <rx.Mrefg>                                      REqCtlD 53
        ENDIF                                                                   REqCtlD 54
      ENDDO                                                                     REqCtlD 55
                                                                                REqCtlD 56
c              See if this hour's or iteration's mix is already known           REqCtlD 57
      FlowSatisfied = .FALSE.          ! True if the flow is satisfied          REqCtlD 58
      IF (Neq .EQ. 1)  THEN                                                     REqCtlD 59
c              Only one unit                                                    REqCtlD 60
        FlowCap      = CapOp                                                    REqCtlD 61
        <rx.RunFrac> = RunFrac                                                  REqCtlD 62
        IF (Mcycle .LE. FlowCap)  FlowSatisfied = .TRUE.                        REqCtlD 63
      ELSEIF (CapOp .LE. Mcycle)  THEN                                          REqCtlD 64
c              Equipment is overloaded                                          REqCtlD 65
        FlowCap = CapOp                                                         REqCtlD 66
        DO  LI=1,Neq                                                            REqCtlD 67
          Krx          = <li;List>                                              REqCtlD 68
          <rx.RunFrac> = RunFrac                                                REqCtlD 69
        ENDDO                                                                   REqCtlD 70
                                                                                REqCtlD 71
      ELSEIF (NumMechIter .gt. 15  .and. CapLast .gt. Mcycle)  THEN             REqCtlD 72
c              Last mix is still suitable, and oscillating                      REqCtlD 73
        FlowCap       = CapLast                                                 REqCtlD 74
        FlowSatisfied = .TRUE.                                                  REqCtlD 75
                                                                                REqCtlD 76
      ELSE                                                                      REqCtlD 77
c              Find the mix of equipment that best satisfies the load           REqCtlD 78
        Ncombs   = 2**Neq - 1          ! Number of combinations                 REqCtlD 79
        FlowCap  = 0.                  ! Best capacity found so far             REqCtlD 80
        BestCode = 0                   ! Best combination so far                REqCtlD 81
        Error    = 1.E25               ! Error of best combination              REqCtlD 82
c              Loop thru the combinations                                       REqCtlD 83
        DO  M=1,Ncombs                                                          REqCtlD 84
c              calculate the capacity for this combination                      REqCtlD 85
          MQ     = M                                                            REqCtlD 86
          CapOp  = 0.                                                           REqCtlD 87
          DO  LI=1,Neq                                                          REqCtlD 88
            MX    = MQ / 2                                                      REqCtlD 89
            Krx   = <li;List>                                                   REqCtlD 90
            CapOp = CapOp + FLOAT(MQ - 2*MX) * <rx.MaxMrefg>                    REqCtlD 91
            MQ    = MX                                                          REqCtlD 92
          ENDDO                                                                 REqCtlD 93
          IF (CapOp .GT. Mcycle)  THEN                                          REqCtlD 94
c              this combination is acceptable; see if better                    REqCtlD 95
            FlowSatisfied = .TRUE.                                              REqCtlD 96
            ErrorNew      = CapOp - Mcycle                                      REqCtlD 97
            IF (ErrorNew .LT. Error)  THEN                                      REqCtlD 98
              FlowCap  = CapOp                                                  REqCtlD 99
              Error    = ErrorNew                                               REqCtlD100
              BestCode = M                                                      REqCtlD101
            ENDIF                                                               REqCtlD102
          ENDIF                                                                 REqCtlD103
        ENDDO                                                                   REqCtlD104
c              The best mix has been found.  Flag active equipment.             REqCtlD105
c              Note that Enable is 0 or 1                                       REqCtlD106
        DO  LI=1,Neq                                                            REqCtlD107
          Krx          = <li;List>                                              REqCtlD108
          MX           = BestCode / 2                                           REqCtlD109
          Enable       = FLOAT(BestCode - 2*MX)                                 REqCtlD110
          <rx.RunFrac> = RunFrac * Enable                                       REqCtlD111
          BestCode     = MX                                                     REqCtlD112
        ENDDO                                                                   REqCtlD113
      ENDIF  ! possible equipment mixes                                         REqCtlD114
c                                                                               REqCtlD115
c              Allocate flow to active equipment                                REqCtlD116
      IF (FlowSatisfied)  THEN                                                  REqCtlD117
        Prorate = Mcycle/FlowCap * RunFrac                                      REqCtlD118
        DO  LI=1,Neq                                                            REqCtlD119
          Krx = <li;List>                                                       REqCtlD120
          IF (<rx.RunFrac> .EQ. 0.)  THEN                                       REqCtlD121
            <rx.Mrefg> = 0.                                                     REqCtlD122
          ELSE                                                                  REqCtlD123
            <rx.Mrefg> = <rx.MaxMrefg> * Prorate                                REqCtlD124
c              remember which component is the smallest                         REqCtlD125
            IF (<rx.Mrefg> .LT. Smallest)  THEN                                 REqCtlD126
              Smallest    = <rx.Mrefg>                                          REqCtlD127
              KrxSmallest = Krx                                                 REqCtlD128
            ENDIF                                                               REqCtlD129
          ENDIF                                                                 REqCtlD130
        ENDDO                                                                   REqCtlD131
      ELSE                                                                      REqCtlD132
c              overloaded - prorate based on design flow                        REqCtlD133
        DesignCap = 0.                                                          REqCtlD134
        DO  LI=1,Neq                                                            REqCtlD135
          Krx       = <li;List>                                                 REqCtlD136
          DesignCap = DesignCap + <rx;DesMrefg>                                 REqCtlD137
        ENDDO                                                                   REqCtlD138
        Prorate = Mcycle/DesignCap * RunFrac                                    REqCtlD139
        DO  LI=1,Neq                                                            REqCtlD140
          Krx          = <li;List>                                              REqCtlD141
          <rx.RunFrac> = RunFrac                                                REqCtlD142
          <rx.Mrefg>   = <rx;DesMrefg> * Prorate                                REqCtlD143
c              remember which component is the smallest                         REqCtlD144
          IF (<rx.Mrefg> .LT. Smallest)  THEN                                   REqCtlD145
            Smallest    = <rx.Mrefg>                                            REqCtlD146
            KrxSmallest = Krx                                                   REqCtlD147
          ENDIF                                                                 REqCtlD148
        ENDDO                                                                   REqCtlD149
      ENDIF                                                                     REqCtlD150
c                                                                               REqCtlD151
      RETURN                                                                    REqCtlD152
                                                                                REqCtlD153
c              Message formats                                                  REqCtlD154
 9001 FORMAT(14x,'Programmer Error: EquipCtrl was called'              /        REqCtlD155
     &14x,'with RunFrac = 0'                                           )        REqCtlD156
      END                                                                       REqCtlD157
      FUNCTION NewAirCoil(Jparent)                                              NewAX    2
                                                                                NewAX    3
c              Creates an air coil block for components that have an            NewAX    4
c              embedded air coil, rather than a referenced                      NewAX    5
c              component.                                                       NewAX    6
c                                                                               NewAX    7
c              Jparent   Pointer to parent component                            NewAX    8
                                                                                NewAX    9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
                                                                                NewAX   14
      DATA NameSubcomponent /4H$Sub/                                            /SubNam/ 2
                                                                                NewAX   16
      Save Kac                                                                  NewAX   17
                                                                                NewAX   18
c              Create an air coil block and link                                NewAX   19
      NewAirCoil = NewRecord(<+ac~Len>)                                         NewAX   20
      IF (Iac .eq. 0)  THEN                                                     NewAX   21
        Iac         = NewAirCoil                                                NewAX   22
        KacPrevious = 0                                                         NewAX   23
      ELSE                                                                      NewAX   24
        <ac;Next>   = NewAirCoil                                                NewAX   25
        KacPrevious = Kac                                                       NewAX   26
      ENDIF                                                                     NewAX   27
      Kac           = NewAirCoil                                                NewAX   28
      <ac;Previous> = KacPrevious                                               NewAX   29
                                                                                NewAX   30
      <ac;Ident>    = NameSubComponent                                          NewAX   31
      <ac;Parent>   = Jparent                                                   NewAX   32
                                                                                NewAX   33
      RETURN                                                                    NewAX   34
      END                                                                       NewAX   35
C ##############################################################################FxAlgs   2
C ##############################################################################FxAlgs   3
C ##############################################################################FxAlgs   4
C ##############################################################################FxAlgs   5
C ##########                                                          ##########FxAlgs   6
C ##########                  REFRIGERATED FIXTURES                   ##########FxAlgs   7
C ##########                                                          ##########FxAlgs   8
C ##############################################################################FxAlgs   9
C ##############################################################################FxAlgs  10
C ##############################################################################FxAlgs  11
C ##############################################################################FxAlgs  12
c                                                                               FxAlgs  13
      SUBROUTINE RefgFixtureAlgs(Mode, Knx)                                     FxAlgs  14
c                                                                               FxAlgs  15
c              Selects the correct refrigeration fixture simulation algorithm   FxAlgs  16
c                                                                               FxAlgs  17
c              Knx  Pointer to the component or one of its nodes                FxAlgs  18
c                                                                               FxAlgs  19
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               FxAlgs  22
      DATA IdNode /4H$Kno/                                                      /IdNode/ 2
c              Knx may point either to the component or to one of the           FxAlgs  24
c              component's nodes                                                FxAlgs  25
      IF (<nx;Ident> .EQ. IdNode)  THEN                                         FxAlgs  26
        Jna = <nx;Component>                                                    FxAlgs  27
      ELSE                                                                      FxAlgs  28
        Jna = Knx                                                               FxAlgs  29
      ENDIF                                                                     FxAlgs  30
c                                                                               FxAlgs  31
      SELECT CASE (<na:ALGORITHM>)                                              FxAlgs  32
c                                                                               FxAlgs  33
        CASE (1)  ! Refrigerated display fixture                                FxAlgs  34
            CALL RefgFixture_Display(Mode, Jna)                                 FxAlgs  35
c                                                                               FxAlgs  36
        CASE (2)  ! Walk-in box (future)                                        FxAlgs  37
c                                                                               FxAlgs  38
      END SELECT                                                                FxAlgs  39
c                                                                               FxAlgs  40
      RETURN                                                                    FxAlgs  41
      END                                                                       FxAlgs  42
      SUBROUTINE RefgFixture_Display(Mode, Jrf)                                 Disply   2
c                                                                               Disply   3
c              Simulates supermarket refrigerated display fixtures              Disply   4
c                                                                               Disply   5
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
c                                                                               Disply  16
      INTEGER  Xai, Xao, ZP1, ZP2, rH                                           Disply  17
      LOGICAL  IterReqdHsty                                                     Disply  18
      REAL     Mfix, MWfix, Minf1, Minf2, Mcoil, Mint, Mcond                    Disply  19
c                                                                               Disply  20
      DBair(H,W) = (H - 1061.*W) / (0.24 + 0.444*W)                             DBair    2
      HAir(DB,W) = 0.24*DB + (1061.0 + 0.444*DB)*W                              HAir     2
      HLat(DB,W) = (1061.0 + 0.444*DB)*W                                        HLat     2
      Hice(T)    = (T-32.)*.487 - 143.35                                        Hice     2
      Hliq(T)    = (T-32.)                                                      Hliq     2
      V(DB,W,P) = 0.754*(DB+459.7)*(1.0+1.605*W)/P                              V        2
c                                                                               Disply  27
      Kac = <rf;AirCoil>                 ! Air coil subcomponent                Disply  28
      Kai = <rf;AirInletNode>            ! Inlet node                           Disply  29
      Xai = <ai;Xnode>                   ! Air coil outlet                      Disply  30
      Kao = <rf;AirOutletNode>           ! Outlet node                          Disply  31
      Xao = <ao;Xnode>                   ! Air coil inlet                       Disply  32
c                                                                               Disply  33
      SELECT CASE (Mode)                                                        Disply  34
c                                                                               Disply  35
c                                                                               Disply  36
c ============ HOURLY INITIALIZATION ========================================== Disply  37
      CASE (10)                                                                 Disply  38
c                                                                               Disply  39
      CALL ZeroAA(<#rf.HrZeroStart..>, <#rf.HrZeroEnd....>)                     Disply  40
c                                                                               Disply  41
c              Update thermal mass temperature and internal latent heat         Disply  42
      <rf;Tsurface>     = <rf;Tsurface''>                                       Disply  43
      <rf;Tsurface'>    = <rf;Tsurface''>                                       Disply  44
      <rf;MIntLat>      = <rf;MIntLat''>                                        Disply  45
      <rf;MIntLat'>     = <rf;MIntLat''>                                        Disply  46
      <rf;QIntLat>      = <rf;QIntLat''>                                        Disply  47
      <rf;QIntLat'>     = <rf;QIntLat''>                                        Disply  48
      <rf;MIntLatDef>   = <rf;MIntLatDef''>                                     Disply  49
      <rf;MIntLatDef'>  = <rf;MIntLatDef''>                                     Disply  50
      <rf;MIntLatProd>  = <rf;MIntLatProd''>                                    Disply  51
      <rf;MIntLatProd'> = <rf;MIntLatProd''>                                    Disply  52
c                                                                               Disply  53
c              Calculate values that are independent of zone and fixture        Disply  54
c              conditions and will remain fixed for the hour.                   Disply  55
c                                                                               Disply  56
c              Zone conductance and infiltration                                Disply  57
      <rf;UA>       = <rf;SurfaceUA>   * SchVal(<rf:COND-SCH>)                  Disply  58
      <rf;CFMinfil> = <rf;DesCFMinf> * SchVal(<rf:AIR-INF-SCH>)                 Disply  59
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                         Disply  60
        <rf;UA2>       = <rf;SurfaceUA2>   * SchVal(<rf:COND-SCH2>)             Disply  61
        <rf;CFMinfil2> = <rf;DesCFMinf2> * SchVal(<rf:AIR-INF-SCH2>)            Disply  62
      ENDIF                                                                     Disply  63
c                                                                               Disply  64
c              Internal latent gains (produce sprays, etc.)                     Disply  65
      IF (<rf;ProductLat> .NE. 0.)  THEN                                        Disply  66
c              maximum amount that can be evaporated from product               Disply  67
        <rf;dMIntLatProd> = <rf;ProductLat> * SchVal(<rf:LATENT-SCH>)           Disply  68
      ELSE                                                                      Disply  69
        <rf;dMIntLatProd> = 0.                                                  Disply  70
      ENDIF                                                                     Disply  71
c                                                                               Disply  72
c              Temperature control strategy                                     Disply  73
      SELECT CASE (<rf:TEMP-CTRL>)                                              Disply  74
        CASE (1)  ! floating                                                    Disply  75
          <ai.Treqd> = <rf:SUPPLY-T>                                            Disply  76
        CASE (2,4)  ! thermostat, EPR                                           Disply  77
          <ai.Treqd> = <rf:TEMP-SETPT>                                          Disply  78
        CASE (3,5)  ! thermostat, EPR schedule                                  Disply  79
          <ai.Treqd> = SchVal(<rf:TEMP-SETPT-SC>)                               Disply  80
      END SELECT                                                                Disply  81
      <ai.Wreqd> = -88888.                                                      Disply  82
c                                                                               Disply  83
c              Initialize the air coil                                          Disply  84
      CALL AirCoil_DX(Mode, <rf;AirCoil>)                                       Disply  85
c                                                                               Disply  86
c                                                                               Disply  87
c ============ HOURLY SIMULATION ============================================== Disply  88
      CASE (30,31)                                                              Disply  89
c                                                                               Disply  90
c              Mode 30  Before TEMDEV - Estimate values which may change        Disply  91
c                       during the hour.  Base the estimates on last            Disply  92
c                       hour's zone conditions.                                 Disply  93
c              Mode 31  After TEMDEV - Calculate values based on average        Disply  94
c                       zone temperature during the hour.  Pass any             Disply  95
c                       errors in zone sensible or latent heat (Mode 30)        Disply  96
c                       extraction on to the next hour.                         Disply  97
c                                                                               Disply  98
c              Zone conditions                                                  Disply  99
      ZP1    = <rf:ZONE-NAME>                                                   Disply 100
      Tzone1 = <zn;Tavg>                                                        Disply 101
      Wzone1 = <zn;W'>                                                          Disply 102
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                         Disply 103
        ZP1    = <rf:ZONE-NAME2>                                                Disply 104
        Tzone2 = <zn;Tavg>                                                      Disply 105
        Wzone2 = <zn;W'>                                                        Disply 106
      ENDIF                                                                     Disply 107
c                                                                               Disply 108
c ------------ DEFROST CYCLE -------------------------------------------------- Disply 109
c                                                                               Disply 110
c              Initialize coil terms                                            Disply 111
      UAsup  = 0.                                                               Disply 112
      UATsup = 0.                                                               Disply 113
      Msup   = 0.                                                               Disply 114
      MWsup  = 0.                                                               Disply 115
c                                                                               Disply 116
c              Start of iterative loop on defrost conditions                    Disply 117
      CALL HistoryInit(<rf;ReturnDefHsty>)                                      Disply 118
      CALL HistoryInit(<ac;UAerHsty>)                                           Disply 119
      IterT = 0                                                                 Disply 120
      DO 3010                                                                   Disply 121
        IterT = IterT + 1                                                       Disply 122
        IF (IterT .EQ. 100)  THEN                                               Disply 123
          CALL DumpHstyTrack(<rf;ReturnDefHsty>)                                Disply 124
          EXIT                                                                  Disply 125
        ENDIF                                                                   Disply 126
c              Get inlet conditions by simulating air coil using last           Disply 127
c              defrost cycle's or iteration's outlet conditions                 Disply 128
        <rf;Tavg> = <rf;Tdefrost>                                               Disply 129
        <rf;Wavg> = <rf;Wdefrost>                                               Disply 130
        CALL AirCoil_DX(31, Kac)                                                Disply 131
        IF (IwinReturn .eq. 1)  Return                                          Disply 132
c                                                                               Disply 133
        DefFrac = <ac;DefrostFrac>                                              Disply 134
        RunFrac = 1.0 - DefFrac                                                 Disply 135
c                                                                               Disply 136
c              Calculate loads which may vary with the defrost period           Disply 137
c              Note that rf.RunFrac is initialized to zero at the               Disply 138
c              beginning of the hour so that this branch will always            Disply 139
c              execute at least once during the hour                            Disply 140
        IF (RunFrac .NE. <rf.RunFrac>)  THEN                                    Disply 141
          <rf.RunFrac> = RunFrac                                                Disply 142
c              Fixture lighting                                                 Disply 143
          SchV = SchVal(<rf:LIGHTING-SCH>)                                      Disply 144
          IF (DefFrac .GT. 0. .AND. <rf:LIGHTS-W/DEF> .EQ. 0) THEN              Disply 145
            SchVt = SchV            ! defrost, with lights on                   Disply 146
          ELSE                                                                  Disply 147
            SchVt = SchV * RunFrac  ! no defrost, or lights off                 Disply 148
          ENDIF                                                                 Disply 149
          <rf;kWlights>  = <rf;LightskWDes>   * SchVt                           Disply 150
          <rf;Qlights>   = <rf;LightToFixtur> * SchVt                           Disply 151
          <rf;QfixZone>  = <rf;LightToZone>   * SchVt                           Disply 152
          <rf;QfixZone2> = <rf;LightToZone2>  * SchVt                           Disply 153
          <rf;QfixCoil>  = <rf;LightToFixtur> * SchV * RunFrac                  Disply 154
          <rf;QfixCoil'> = <rf;LightToFixtur> * SchV * DefFrac                  Disply 155
c              Air coil fan                                                     Disply 156
          IF (DefFrac .GT. 0. .AND. <rf:FAN-W/DEFROST> .EQ. 0) THEN             Disply 157
            SchVt = 1.        ! defrost, with fans on                           Disply 158
          ELSE                                                                  Disply 159
            SchVt = RunFrac   ! no defrost, or fans off                         Disply 160
          ENDIF                                                                 Disply 161
          <rf;kWfans>    = <rf;FankW>        * SchVt                            Disply 162
          <rf;Qfans>     = <rf;FanToFixture> * SchVt                            Disply 163
          <rf;QfixZone>  = <rf;FanToZone>    * SchVt   + <rf;QfixZone>          Disply 164
          <rf;QfixZone2> = <rf;FanToZone2>   * SchVt   + <rf;QfixZone2>         Disply 165
          <rf;QfixCoil>  = <rf;FanToFixture> * RunFrac + <rf;QfixCoil>          Disply 166
          <rf;QfixCoil'> = <rf;FanToFixture> * DefFrac + <rf;QfixCoil'>         Disply 167
c              Anti-sweat heater                                                Disply 168
          IF (<rf:HEATER-CTRL> .GT. 0)  THEN                                    Disply 169
            SELECT CASE (<rf:HEATER-CTRL>)                                      Disply 170
              CASE (1)   ! Fixed                                                Disply 171
                SchV = 1.0                                                      Disply 172
              CASE (2)   ! Scheduled                                            Disply 173
                SchV = SchVal(<rf:HEATER-SCH>)                                  Disply 174
              CASE (3)   ! Relative humidity (last hour's)                      Disply 175
                ZP1 = <rf:ZONE-NAME>                                            Disply 176
                Wmax = WFUNC(<TNOW>, <rf:MAX-HUMIDITY>, Patm)                   Disply 177
                Wmin = WFUNC(<TNOW>, <rf:MIN-HUMIDITY>, Patm)                   Disply 178
                SchV = Min(1., Max(0., (Wzone1-Wmin)/(Wmax-Wmin)))              Disply 179
                SchV = <rf:MIN-HEATER>                                          Disply 180
     &               + Dim(<rf:MAX-HEATER>,<rf:MIN-HEATER>) * SchV              Disply 181
              CASE (4)   ! Humidity ratio (last hour's)                         Disply 182
                ZP1 = <rf:ZONE-NAME>                                            Disply 183
                SchV = Min(1., Max(0.,                                          Disply 184
     &                     (<zn;W>-<rf:MIN-W>)/(<rf:MAX-W>-<rf:MIN-W>)))        Disply 185
                SchV = <rf:MIN-HEATER>                                          Disply 186
     &               + Dim(<rf:MAX-HEATER>,<rf:MIN-HEATER>) * SchV              Disply 187
            END SELECT                                                          Disply 188
            IF(DefFrac .GT. 0. .AND. <rf:HTR-W/DEFROST> .EQ. 0) THEN            Disply 189
              SchVt = SchV            ! defrost, with heaters on                Disply 190
            ELSE                                                                Disply 191
              SchVt = SchV * RunFrac  ! no defrost, or heaters off              Disply 192
            ENDIF                                                               Disply 193
            <rf;kWsweat>   = <rf;HeaterkW>     * SchVt                          Disply 194
            <rf;Qsweat>    = <rf;HtrToFixture> * SchVt                          Disply 195
            <rf;QfixZone>  = <rf;HtrToZone>    * SchVt + <rf;QfixZone>          Disply 196
            <rf;QfixZone2> = <rf;HtrToZone2>   * SchVt + <rf;QfixZone2>         Disply 197
            <rf;QfixCoil>  = <rf;QfixCoil>                                      Disply 198
     &                     + <rf;HtrToFixture> * SchV * RunFrac                 Disply 199
            <rf;QfixCoil'> = <rf;QfixCoil'>                                     Disply 200
     &                     + <rf;HtrToFixture> * SchV * DefFrac                 Disply 201
          ENDIF  ! rf:HEATER-CTRL                                               Disply 202
c              Sensible product load                                            Disply 203
          IF (<rf;ProductSen> .NE. 0.)  THEN                                    Disply 204
            SchV           = SchVal(<rf:SENSIBLE-SCH>)                          Disply 205
            <rf;QprodSen>  = <rf;ProductSen> * SchV                             Disply 206
            <rf;QfixCoil>  = <rf;QfixCoil>                                      Disply 207
     &                     + <rf;ProductSen> * SchV * RunFrac                   Disply 208
            <rf;QfixCoil'> = <rf;QfixCoil'>                                     Disply 209
     &                     + <rf;ProductSen> * SchV * DefFrac                   Disply 210
          ENDIF                                                                 Disply 211
        ENDIF  ! DefFrac .ne. ev;DefrostFrac                                    Disply 212
c                                                                               Disply 213
        IF (DefFrac .EQ. 0.)  THEN                                              Disply 214
c              No defrost this hour                                             Disply 215
          <rf;dMIntLat'> = 0.                                                   Disply 216
          IF (<rf:DEF-TYPE> .GT. 0)  THEN                                       Disply 217
c              store extraction rate terms                                      Disply 218
            Kex       = <rf;QsensDefNode>                                       Disply 219
            <ex.UA>   = 0.                                                      Disply 220
            Kex       = <rf;QlatDefNode>                                        Disply 221
            <ex.Mair> = 0.                                                      Disply 222
            IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                   Disply 223
              Kex       = <rf;QsensDefNode2>                                    Disply 224
              <ex.UA>   = 0.                                                    Disply 225
              Kex       = <rf;QlatDefNode2>                                     Disply 226
              <ex.Mair> = 0.                                                    Disply 227
            ENDIF                                                               Disply 228
          ENDIF                                                                 Disply 229
          CALL HstyClearFlag(<rf;ReturnDefHsty>)                                Disply 230
          GOTO 3040                                                             Disply 231
        ENDIF  ! DefFrac                                                        Disply 232
c                                                                               Disply 233
c              Calculate fixture temperature and humidity during defrost        Disply 234
c              Storage decay rate and capacity of fixture contents              Disply 235
        DecayRate  = EXP(<rf;-rSensible>*DefFrac)                               Disply 236
        StorageCap = (1.0-DecayRate) * <rf;StorageSen>                          Disply 237
c              Moisture stored on fixture contents                              Disply 238
        dMIntMax = <rf;MIntLat> + <rf;dMIntLatProd>*DefFrac                     Disply 239
c              Heat balance terms                                               Disply 240
c              First, storage and internal heat                                 Disply 241
        xUAfix  = StorageCap                                                    Disply 242
        xUATfix = StorageCap*<rf;Tsurface> + <rf;QfixCoil'>                     Disply 243
     &                                     + <ac;QdefLoss>                      Disply 244
        xMfix   = 0.                                                            Disply 245
        xMWfix  = 0.                                                            Disply 246
c              zone infiltration and conduction                                 Disply 247
        Minf1   = <rf;CFMinfil> * <rf;Lbs/CFMinfDef> * DefFrac                  Disply 248
        UAinf1  = Minf1*0.242 + <rf;UA>*DefFrac                                 Disply 249
        xUAfix  = xUAfix  + UAinf1                                              Disply 250
        xUATfix = xUATfix + UAinf1*Tzone1                                       Disply 251
        xMfix   = xMfix   + Minf1                                               Disply 252
        xMWfix  = xMWfix  + Minf1*Wzone1                                        Disply 253
        IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                       Disply 254
c              second zone                                                      Disply 255
          Minf2   = <rf;CFMinfil2> * <rf;Lbs/CFMinfDef> * DefFrac               Disply 256
          UAinf2  = Minf2*0.242 + <rf;UA2>*DefFrac                              Disply 257
          xUAfix  = xUAfix  + UAinf2                                            Disply 258
          xUATfix = xUATfix + UAinf2*Tzone2                                     Disply 259
          xMfix   = xMfix   + Minf2                                             Disply 260
          xMWfix  = xMWfix  + Minf2*Wzone2                                      Disply 261
        ENDIF                                                                   Disply 262
c                                                                               Disply 263
c              Start of iterative loop on internal evaporation                  Disply 264
        CALL HistoryInit(<rf;WdefrostHsty>)                                     Disply 265
        IterW = 0                                                               Disply 266
        DO 3008                                                                 Disply 267
          IterW = IterW + 1                                                     Disply 268
          IF (IterW .EQ. 100)  THEN                                             Disply 269
            CALL DumpHstyTrack(<rf;WdefrostHsty>)                               Disply 270
            EXIT                                                                Disply 271
          ENDIF                                                                 Disply 272
          UAfix  = xUAfix                                                       Disply 273
          UATfix = xUATfix + <rf;dQIntLat'>  ! sens/latent conversion           Disply 274
          Mfix   = xMfix                                                        Disply 275
          MWfix  = xMWfix                                                       Disply 276
c              Air coil has effect only if fan on during defrost                Disply 277
          IF (<rf:FAN-W/DEFROST> .EQ. 0)  THEN                                  Disply 278
c              coil extraction rate terms - sensible cooling                    Disply 279
            IF (<ac;TcoilUA> .GT. 0.  .AND.                                     Disply 280
     &                           <ac;TcoilNoQ> .LT. <rf;Tdefrost>)  THEN        Disply 281
              UAcoil = <ac;TcoilUA> * DefFrac                                   Disply 282
              UAfix  = UAfix  + UAcoil                                          Disply 283
              UATfix = UATfix + UAcoil*<ac;TcoilNoQ>                            Disply 284
            ENDIF                                                               Disply 285
c              latent effect - may humidity or dehumidify                       Disply 286
            Mcoil = <ac;SurfWoUA> * DefFrac                                     Disply 287
            Mfix  = Mfix  + Mcoil                                               Disply 288
            MWfix = MWfix + Mcoil*<ac;SurfWo>                                   Disply 289
          ENDIF                                                                 Disply 290
c              Average fixture temperature during defrost                       Disply 291
          IF (UAfix .GT. 0.)  <rf;Tdefrost> = UATfix / UAfix                    Disply 292
c              adjust temperature of contents                                   Disply 293
          <rf;Tsurface'> = <rf;Tdefrost>                                        Disply 294
     &                   + (<rf;Tsurface>-<rf;Tdefrost>)*DecayRate              Disply 295
c              Fixture humidity and internal evaporation/condensation           Disply 296
          IF (Mfix .GT. 0.)  THEN                                               Disply 297
c              fixture humidity ratio w/o internal exchange                     Disply 298
            <rf;Wdefrost> = MWfix / Mfix                                        Disply 299
c              internal surface humidity at saturation                          Disply 300
            Wint = Wfunc(<rf;Tsurface'>, 100., Patm)                            Disply 301
            IF (Wint .LT. <rf;Wdefrost>)  THEN                                  Disply 302
c                 internal condensation                                         Disply 303
              Mint  = MAX(xMfix,<ai.Minlet>*RunFrac) * <rf:LAT-EFF-COND>        Disply 304
              Mfix  = Mfix  + Mint                                              Disply 305
              MWfix = MWfix + Mint*Wint                                         Disply 306
              <rf;Wdefrost> = MWfix / Mfix                                      Disply 307
c                  mass transport and heat released by condensation             Disply 308
c                  (relative to air, not surface)                               Disply 309
              <rf;dMIntLat'> = Mint * (Wint - <rf;Wdefrost>)                    Disply 310
              IF (<rf;Tsurface'> .LT. 31.)  THEN                                Disply 311
                dQIntLat = Hice(<rf;Tsurface'>)                                 Disply 312
              ELSEIF (<rf;Tsurface'> .GT. 33.)  THEN                            Disply 313
                dQIntLat = Hliq(<rf;Tsurface'>)                                 Disply 314
              ELSE                                                              Disply 315
                FracCond = (<rf;Tsurface'>-31.) * 0.5                           Disply 316
                dQIntLat = Hliq(<rf;Tsurface'>) * FracCond                      Disply 317
     &                   + Hice(<rf;Tsurface'>) * (1.-FracCond)                 Disply 318
              ENDIF                                                             Disply 319
              <rf;dQIntLat'> = dQIntLat*<rf;dMIntLat'>                          Disply 320
     &                       - HLat(<rf;Tdefrost>,<rf;dMIntLat'>)               Disply 321
            ELSEIF (Wint .GT. <rf;Wdefrost>  .AND.                              Disply 322
     &                                          dMIntMax .GT. 0.)  THEN         Disply 323
c                 internal evaporation - assumes frost evaporates slower        Disply 324
c                 than condensate                                               Disply 325
              IF (<rf;Tsurface'> .LT. 31.)  THEN                                Disply 326
                EvapEff  = <rf:LAT-EFF-FROST>                                   Disply 327
              ELSEIF (<rf;Tsurface'> .GT. 33.)  THEN                            Disply 328
                EvapEff  = <rf:LAT-EFF-COND>                                    Disply 329
              ELSE                                                              Disply 330
                FracCond = (<rf;Tsurface'> - 31.) * 0.5    ! mixture            Disply 331
                EvapEff  = <rf:LAT-EFF-COND>  * FracCond                        Disply 332
     &                   + <rf:LAT-EFF-FROST> * (1.-FracCond)                   Disply 333
              ENDIF                                                             Disply 334
              Mint          = MAX(xMfix, <ai.Minlet>*RunFrac) * EvapEff         Disply 335
              <rf;Wdefrost> = (MWfix+Mint*Wint) / (Mfix+Mint)                   Disply 336
c                  mass transport (relative to air, not surface)                Disply 337
              <rf;dMIntLat'> = Mint * (Wint - <rf;Wdefrost>)                    Disply 338
              <rf;dMIntLat'> = MIN(dMIntMax, <rf;dMIntLat'>)                    Disply 339
              <rf;Wdefrost> = (MWfix+<rf;dMIntLat'>) / Mfix                     Disply 340
c                 heat absorbed by evaporation                                  Disply 341
              IF (<rf;MIntLat> .GT. 0.)  THEN                                   Disply 342
                dQIntLat = <rf;QIntLat> * <rf;dMIntLat'>/<rf;MIntLat>           Disply 343
              ELSE                                                              Disply 344
                dQIntLat = 0.                                                   Disply 345
              ENDIF                                                             Disply 346
              <rf;dQIntLat'> = dQIntLat                                         Disply 347
     &                       - HLat(<rf;Tdefrost>,<rf;dMIntLat'>)               Disply 348
            ELSE  ! no internal moisture conversion                             Disply 349
              <rf;dMIntLat'> = 0.                                               Disply 350
              <rf;dQIntLat'> = 0.                                               Disply 351
            ENDIF                                                               Disply 352
          ELSE  ! no airflow                                                    Disply 353
            <rf;dMIntLat'> = 0.                                                 Disply 354
            <rf;dQIntLat'> = 0.                                                 Disply 355
          ENDIF                                                                 Disply 356
c              check for convergence on evaporation rate                        Disply 357
          CALL CnvgCheck(2, <rf;WdefrostHsty>)                                  Disply 358
          IF (.NOT. IterReqdHsty(<rf;WdefrostHsty>))  EXIT                      Disply 359
 3008   CONTINUE  ! IterW                                                       Disply 360
c                                                                               Disply 361
c              Fixture outlet (return) conditions                               Disply 362
        <ao.Toutlet> = <rf;Tdefrost>                                            Disply 363
        <ao.Woutlet> = <rf;Wdefrost>                                            Disply 364
c              Defroster load on fixture                                        Disply 365
        IF (<rf:FAN-W/DEFROST> .EQ. 1)  THEN                                    Disply 366
          <rf;QdefSen> = <ac;QdefLoss>                                          Disply 367
        ELSE                                                                    Disply 368
c              Sensible gain from defrost inefficiency                          Disply 369
          <rf;QdefSen> = <ac;TcoilUA> * (<rf;Tdefrost>-<ac;TcoilNoQ>)           Disply 370
          IF (<rf:SUPPLY-DIST> .EQ. 2)  THEN                                    Disply 371
c              Modify for plug flow w/ fan on                                   Disply 372
            dT = MAX(0., <rf;QdefSen> / (<ai.Minlet>*<ac;CpDemand>))            Disply 373
            <ao.Toutlet> = <rf;Tdefrost> + dT*0.5                               Disply 374
c              latent effect - may humidity or dehumidify                       Disply 375
            Mcond        = <ac;SurfWoUA> * (<rf;Wdefrost>-<ac;SurfWo>)          Disply 376
            dW           = Mcond / <ai.Minlet>                                  Disply 377
            <ao.Woutlet> = <rf;Wdefrost> + dW*0.5                               Disply 378
          ENDIF                                                                 Disply 379
          <rf;QdefSen> = <rf;QdefSen> + <ac;QdefLoss>                           Disply 380
        ENDIF                                                                   Disply 381
c              Check for converence on outlet conditions                        Disply 382
        CALL CnvgCheck(2, <rf;ReturnDefHsty>)                                   Disply 383
        IF (IterT .GT. 1  .AND.                                                 Disply 384
     &                     .NOT. IterReqdHsty(<rf;ReturnDefHsty>))  EXIT        Disply 385
 3010 CONTINUE  ! IterT                                                         Disply 386
c                                                                               Disply 387
c              Warn if defrost appears to be excessive                          Disply 388
      IF (<rf;Tdefrost> .GT. 70.  .AND.  <rf;FlagHighDefT> .EQ. 0)  THEN        Disply 389
        <rf;FlagHighDefT> = 1                                                   Disply 390
        CALL MSGSIM(-3,II,II,II,II)                                             Disply 391
        WRITE (IOUTPT,9102)  (<rf:NAME>,II=1,8), <rf;Tdefrost>,                 Disply 392
     &                       IMO, IDAY, IHR                                     Disply 393
c       CALL MessageBox( NULL,                                                  Disply 394
c    &    'A defrost cycle is producing a'//char(10)//char(13)//                Disply 395
c    &    'fixture temperature > 70F'//char(0),                                 Disply 396
c    &    'Refg-Fixture Errors'//char(0),                                       Disply 397
c    &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  Disply 398
      ENDIF                                                                     Disply 399
c                                                                               Disply 400
c              Moisture from coil, product, and net moisture stored             Disply 401
      dMLatCoil         = <ai.Minlet> * (<Xai.Winlet>-<ao.Woutlet>)             Disply 402
     &                                * DefFrac                                 Disply 403
      dMLatProd         = <rf;dMIntLatProd> * DefFrac                           Disply 404
      dMLatStore        = dMLatProd - <rf;dMIntLat'>                            Disply 405
      <rf;MIntLatDef'>  = MAX(0., <rf;MIntLatDef>  + dMLatCoil)                 Disply 406
      <rf;MIntLatProd'> = MAX(0., <rf;MIntLatProd> + dMLatProd)                 Disply 407
      <rf;MIntLat'>     = MAX(0., <rf;MIntLat>     + dMLatStore)                Disply 408
      IF (dMLatStore .GT. 0.000001)  THEN                                       Disply 409
c              stored moisture is accumulating                                  Disply 410
c              Enthalpy stored in moisture relative to 32F                      Disply 411
        IF (<rf;Tsurface'> .LT. 31.)  THEN                                      Disply 412
          dQstore = Hice(<rf;Tsurface'>)                                        Disply 413
        ELSEIF (<rf;Tsurface'> .GT. 33.)  THEN                                  Disply 414
          dQstore = Hliq(<rf;Tsurface'>)                                        Disply 415
        ELSE                                                                    Disply 416
          FracCond = (<rf;Tsurface'>-31.) * 0.5                                 Disply 417
          dQstore  = Hliq(<rf;Tsurface'>) * FracCond                            Disply 418
     &             + Hice(<rf;Tsurface'>) * (1.-FracCond)                       Disply 419
        ENDIF                                                                   Disply 420
        <rf;QIntLat'> = <rf;QIntLat> + dMLatStore*dQstore                       Disply 421
        IF (<rf;MIntLat'> .GT. <rf;MaxH2OStore>)  THEN                          Disply 422
c              Moisture must be drained or frost removed.  Put priority         Disply 423
c              on reducing defrost moisture, as product and infiltration        Disply 424
c              moisture would occur anyway, then reduce product moisture        Disply 425
c              (infiltration will be remainder, if any)                         Disply 426
          dMsurplus         = <rf;MIntLat'> - <rf;MaxH2OStore>                  Disply 427
          dMLatStore        = dMLatStore - dMsurplus                            Disply 428
          <rf;QIntLat'>     = <rf;QIntLat'> - dMsurplus*dQstore                 Disply 429
          dM                = MIN(<rf;MIntLatDef'>, dMsurplus)                  Disply 430
          <rf;MIntLatDef'>  = <rf;MIntLatDef'> - dM                             Disply 431
          dMsurplus         = dMsurplus - dM                                    Disply 432
          dM                = MIN(<rf;MIntLatProd'>, dMsurplus)                 Disply 433
          <rf;MIntLatProd'> = <rf;MIntLatProd'> - dM                            Disply 434
          <rf;MIntLat'>     = <rf;MaxH2OStore>                                  Disply 435
        ENDIF                                                                   Disply 436
      ELSEIF (dMLatStore .LT. -0.000001)  THEN                                  Disply 437
c              stored moisture is evaporating                                   Disply 438
        dMsurplus = dMLatStore - (dMLatCoil+dMLatProd)                          Disply 439
        IF (dMsurplus .LT. 0.)  THEN                                            Disply 440
c              Proportionately reduce product & coil storage quantities         Disply 441
c              (remainder is from infiltration)                                 Disply 442
          SumDefProd = <rf;MIntLatDef'> + <rf;MIntLatProd'>                     Disply 443
          IF (SumDefProd .GT. 0.000001)  THEN                                   Disply 444
            FracDef           = <rf;MIntLatDef'> / SumDefProd                   Disply 445
            <rf;MIntLatDef'>  = MAX(0., <rf;MIntLatDef'>                        Disply 446
     &                                         + dMsurplus*FracDef)             Disply 447
            <rf;MIntLatProd'> = MAX(0., <rf;MIntLatProd'>                       Disply 448
     &                                         + dMsurplus*(1.-FracDef))        Disply 449
          ENDIF                                                                 Disply 450
        ENDIF                                                                   Disply 451
        <rf;QIntLat'> = <rf;QIntLat> * (1.+dMLatStore/<rf;MIntLat>)             Disply 452
      ENDIF  ! dMLatStore .gt. 0.                                               Disply 453
c                                                                               Disply 454
c              store extraction rate terms                                      Disply 455
      Kex           = <rf;QsensDefNode>                                         Disply 456
      <ex.Textract> = <rf;Tdefrost>                                             Disply 457
      <ex.UA>       = UAinf1                                                    Disply 458
      Kex           = <rf;QlatDefNode>                                          Disply 459
      <ex.Mair>     = Minf1                                                     Disply 460
      <ex.Wextract> = <rf;Wdefrost>                                             Disply 461
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                         Disply 462
        Kex           = <rf;QsensDefNode2>                                      Disply 463
        <ex.Textract> = <rf;Tdefrost>                                           Disply 464
        <ex.UA>       = UAinf2                                                  Disply 465
        Kex           = <rf;QlatDefNode2>                                       Disply 466
        <ex.Mair>     = Minf2                                                   Disply 467
        <ex.Wextract> = <rf;Wdefrost>                                           Disply 468
      ENDIF                                                                     Disply 469
c                                                                               Disply 470
c                                                                               Disply 471
c ------------ NORMAL OPERATION ----------------------------------------------- Disply 472
 3040 CONTINUE                                                                  Disply 473
c                                                                               Disply 474
c              Store fixed loads                                                Disply 475
      Kmd = <rf:ELEC-METER>                                                     Disply 476
      Kmx = <md;Xnode>                                                          Disply 477
      ElecKWh = <rf;kWlights> + <rf;kWfans> + <rf;kWsweat>                      Disply 478
      IF (ElecKWh .GT. 0.)  THEN                                                Disply 479
        IF (ABS(1. - <md.Elec>/ElecKWh) .GT. <sp:ERROR-LOAD>)                   Disply 480
     &    <mx.IterFlag> = Jrf                                                   Disply 481
      ELSE                                                                      Disply 482
        IF (<md.Elec> .GT. 0.)  <mx.IterFlag> = Jrf                             Disply 483
      ENDIF                                                                     Disply 484
      <md.Elec> = ElecKWh                                                       Disply 485
c                                                                               Disply 486
      Kex           = <rf;QfixedNode>                                           Disply 487
      <ex.Qextract> = -<rf;QfixZone>                                            Disply 488
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                         Disply 489
        Kex           = <rf;QfixedNode2>                                        Disply 490
        <ex.Qextract> = -<rf;QfixZone2>                                         Disply 491
      ENDIF                                                                     Disply 492
c                                                                               Disply 493
c              Auxiliary power                                                  Disply 494
      IF (<rf:AUX-KW> .GT. 0.)  THEN                                            Disply 495
        SELECT CASE (<rf:AUX-MODE>)                                             Disply 496
          CASE (1)  ! Always                                                    Disply 497
            AuxKW = <rf:AUX-KW>                                                 Disply 498
          CASE (2)  ! When on                                                   Disply 499
            AuxKW = <rf:AUX-KW> * RunFrac                                       Disply 500
          CASE (3)  ! When off                                                  Disply 501
            AuxKW = <rf:AUX-KW> * DefFrac                                       Disply 502
          CASE (4)  ! Scheduled                                                 Disply 503
            AuxKW = <rf:AUX-KW> * SchVal(<rf:AUX-SCH>)                          Disply 504
        END SELECT                                                              Disply 505
        Kmd = <rf:AUX-METER>                                                    Disply 506
        Kmx = <md;Xnode>                                                        Disply 507
        IF (AuxKW .GT. 0.)  THEN                                                Disply 508
          IF (ABS(1. - <md.Elec>/AuxKW) .GT. <sp:ERROR-LOAD>)                   Disply 509
     &      <mx.IterFlag> = Jrf                                                 Disply 510
        ELSE                                                                    Disply 511
          IF (<md.Elec> .GT. 0.)  <mx.IterFlag> = Jrf                           Disply 512
        ENDIF                                                                   Disply 513
        <md.Elec> = AuxKW                                                       Disply 514
      ENDIF                                                                     Disply 515
c                                                                               Disply 516
c                                                                               Disply 517
c              Now calculate the average fixture conditions during              Disply 518
c              normal operation.  Note that the fixture temperature and         Disply 519
c              humidity may be elevated due to the heat and moisture            Disply 520
c              stored in the contents if we have just come out of a             Disply 521
c              defrost cycle.                                                   Disply 522
      <ai.RunFrac> = <rf.RunFrac>                                               Disply 523
c                                                                               Disply 524
c              Storage decay rate and capacity of fixture contents              Disply 525
      DecayRate  = EXP(<rf;-rSensible>*RunFrac)                                 Disply 526
      StorageCap = (1.0-DecayRate) * <rf;StorageSen>                            Disply 527
c              Moisture stored on fixture contents                              Disply 528
      dMIntMax = <rf;MIntLat'> + <rf;dMIntLatProd>*RunFrac                      Disply 529
c              Extraction terms, including storage and internal heat            Disply 530
      xUAfix  = StorageCap                                                      Disply 531
      xUATfix = StorageCap*<rf;Tsurface'> + <rf;QfixCoil>                       Disply 532
      xMfix   = 0.                                                              Disply 533
      xMWfix  = 0.                                                              Disply 534
c              zone conduction and infiltration                                 Disply 535
      Minf1   = <rf;CFMinfil> * <rf;Lbs/CFMinf> * RunFrac                       Disply 536
      UAinf1  = Minf1*0.242 + <rf;UA>*RunFrac                                   Disply 537
      xUAfix  = xUAfix  + UAinf1                                                Disply 538
      xUATfix = xUATfix + UAinf1*Tzone1                                         Disply 539
      xMfix   = xMfix   + Minf1                                                 Disply 540
      xMWfix  = xMWfix  + Minf1*Wzone1                                          Disply 541
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                         Disply 542
c              second zone                                                      Disply 543
        Minf2   = <rf;CFMinfil2> * <rf;Lbs/CFMinf> * RunFrac                    Disply 544
        UAinf2  = Minf2*0.242 + <rf;UA2>*RunFrac                                Disply 545
        xUAfix  = xUAfix  + UAinf2                                              Disply 546
        xUATfix = xUATfix + UAinf2*Tzone2                                       Disply 547
        xMfix   = xMfix   + Minf2                                               Disply 548
        xMWfix  = xMWfix  + Minf2*Wzone2                                        Disply 549
      ENDIF                                                                     Disply 550
c                                                                               Disply 551
c              Start of iterative loop on outlet conditions                     Disply 552
      CALL HistoryInit(<rf;ReturnHsty>)                                         Disply 553
      CALL HistoryInit(<ac;UAerHsty>)                                           Disply 554
      IterT = 0                                                                 Disply 555
      DO 3050                                                                   Disply 556
        IterT = IterT + 1                                                       Disply 557
        IF (IterT .EQ. 100)  THEN                                               Disply 558
          CALL DumpHstyTrack(<rf;ReturnHsty>)                                   Disply 559
          EXIT                                                                  Disply 560
        ENDIF                                                                   Disply 561
c              Get coil conditions by simulating using last iteration's         Disply 562
c              outlet conditions                                                Disply 563
        <rf;Tavg> = <rf;Tfixture>                                               Disply 564
        <rf;Wavg> = <rf;Wfixture>                                               Disply 565
        CALL AirCoil_DX(32, Kac)                                                Disply 566
        IF (IwinReturn .eq. 1)  Return                                          Disply 567
c                                                                               Disply 568
c              Start of iterative loop on internal evaporation                  Disply 569
        CALL HistoryInit(<rf;WfixtureHsty>)                                     Disply 570
        IterW = 0                                                               Disply 571
        DO 3048                                                                 Disply 572
          IterW = IterW + 1                                                     Disply 573
          IF (IterW .EQ. 100)  THEN                                             Disply 574
            CALL DumpHstyTrack(<rf;WfixtureHsty>)                               Disply 575
            EXIT                                                                Disply 576
          ENDIF                                                                 Disply 577
          UAfix  = xUAfix                                                       Disply 578
          UATfix = xUATfix + <rf;dQIntLat''>  ! sens/latent conversion          Disply 579
          Mfix   = xMfix                                                        Disply 580
          MWfix  = xMWfix                                                       Disply 581
c              Air coil extraction rate terms                                   Disply 582
          IF (<ac;TcoilNoQ> .LT. <rf;Tfixture>                                  Disply 583
     &                                .AND.  <ac;TcoilUA> .GT. 0.)  THEN        Disply 584
            UAcoil = <ac;TcoilUA> * RunFrac                                     Disply 585
            UAfix  = UAfix  + UAcoil                                            Disply 586
            UATfix = UATfix + UAcoil*<ac;TcoilNoQ>                              Disply 587
            IF (<ac;SurfWo> .LT. <rf;Wfixture>)  THEN                           Disply 588
              Mcoil = <ac;SurfWoUA> * RunFrac                                   Disply 589
              Mfix  = Mfix  + Mcoil                                             Disply 590
              MWfix = MWfix + Mcoil*<ac;SurfWo>                                 Disply 591
            ENDIF                                                               Disply 592
          ENDIF                                                                 Disply 593
c              Average fixture temperature                                      Disply 594
          IF (UAfix .GT. 0.)  <rf;Tfixture> = UATfix / UAfix                    Disply 595
c              adjust temperature of contents                                   Disply 596
          <rf;Tsurface''> = <rf;Tfixture>                                       Disply 597
     &                    + (<rf;Tsurface'>-<rf;Tfixture>)*DecayRate            Disply 598
c              Fixture humidity and internal evaporation/condensation           Disply 599
          IF (Mfix .GT. 0.)  THEN                                               Disply 600
c              fixture humidity ratio w/o internal exchange                     Disply 601
            <rf;Wfixture> = MWfix / Mfix                                        Disply 602
c              internal surface humidity at saturation                          Disply 603
            Wint = Wfunc(<rf;Tsurface''>, 100., Patm)                           Disply 604
            IF (Wint .LT. <rf;Wfixture>)  THEN                                  Disply 605
c                 internal condensation                                         Disply 606
              Mint  = MAX(xMfix,<ai.Minlet>*RunFrac) * <rf:LAT-EFF-COND>        Disply 607
              Mfix  = Mfix  + Mint                                              Disply 608
              MWfix = MWfix + Mint*Wint                                         Disply 609
              <rf;Wfixture> = MWfix / Mfix                                      Disply 610
c                  mass transport and heat released by condensation             Disply 611
c                  (relative to air, not surface)                               Disply 612
              <rf;dMIntLat''> = Mint * (Wint - <rf;Wfixture>)                   Disply 613
              IF (<rf;Tsurface''> .LT. 31.)  THEN                               Disply 614
                dQIntLat = Hice(<rf;Tsurface''>)                                Disply 615
              ELSEIF (<rf;Tsurface''> .GT. 33.)  THEN                           Disply 616
                dQIntLat = Hliq(<rf;Tsurface''>)                                Disply 617
              ELSE                                                              Disply 618
                FracCond = (<rf;Tsurface''>-31.) * 0.5                          Disply 619
                dQIntLat = Hliq(<rf;Tsurface''>) * FracCond                     Disply 620
     &                   + Hice(<rf;Tsurface''>) * (1.-FracCond)                Disply 621
              ENDIF                                                             Disply 622
              <rf;dQIntLat''> = dQIntLat*<rf;dMIntLat''>                        Disply 623
     &                        - HLat(<rf;Tfixture>,<rf;dMIntLat''>)             Disply 624
            ELSEIF (Wint .GT. <rf;Wfixture>  .AND.                              Disply 625
     &                                          dMIntMax .GT. 0.)  THEN         Disply 626
c                 internal evaporation - assumes frost evaporates slower        Disply 627
c                 than condensate                                               Disply 628
              IF (<rf;Tsurface''> .LT. 31.)  THEN                               Disply 629
                EvapEff  = <rf:LAT-EFF-FROST>                                   Disply 630
              ELSEIF (<rf;Tsurface''> .GT. 33.)  THEN                           Disply 631
                EvapEff  = <rf:LAT-EFF-COND>                                    Disply 632
              ELSE                                                              Disply 633
                FracCond = (<rf;Tsurface''> - 31.) * 0.5    ! mixture           Disply 634
                EvapEff  = <rf:LAT-EFF-COND>  * FracCond                        Disply 635
     &                   + <rf:LAT-EFF-FROST> * (1.-FracCond)                   Disply 636
              ENDIF                                                             Disply 637
              Mint          = MAX(xMfix, <ai.Minlet>*RunFrac) * EvapEff         Disply 638
              <rf;Wfixture> = (MWfix+Mint*Wint) / (Mfix+Mint)                   Disply 639
c                  mass transport (relative to air, not surface)                Disply 640
              <rf;dMIntLat''> = Mint * (Wint - <rf;Wfixture>)                   Disply 641
              <rf;dMIntLat''> = MIN(dMIntMax, <rf;dMIntLat''>)                  Disply 642
              <rf;Wfixture> = (MWfix+<rf;dMIntLat''>) / Mfix                    Disply 643
c                 heat absorbed by evaporation                                  Disply 644
              IF (<rf;MIntLat'> .GT. 0.)  THEN                                  Disply 645
                dQIntLat = <rf;QIntLat'> * <rf;dMIntLat''>/<rf;MIntLat'>        Disply 646
              ELSE                                                              Disply 647
                dQIntLat = 0.                                                   Disply 648
              ENDIF                                                             Disply 649
              <rf;dQIntLat''> = dQIntLat                                        Disply 650
     &                        - HLat(<rf;Tfixture>,<rf;dMIntLat''>)             Disply 651
            ELSE  ! no internal moisture conversion                             Disply 652
              <rf;dMIntLat''> = 0.                                              Disply 653
              <rf;dQIntLat''> = 0.                                              Disply 654
            ENDIF                                                               Disply 655
          ELSE  ! no airflow                                                    Disply 656
            <rf;dMIntLat''> = 0.                                                Disply 657
            <rf;dQIntLat''> = 0.                                                Disply 658
          ENDIF                                                                 Disply 659
          CALL CnvgCheck(2, <rf;WfixtureHsty>)                                  Disply 660
          IF (.NOT. IterReqdHsty(<rf;WfixtureHsty>))  EXIT                      Disply 661
 3048   CONTINUE  ! IterW                                                       Disply 662
c                                                                               Disply 663
c              Fixture outlet (return) conditions                               Disply 664
        IF (<rf:SUPPLY-DIST> .EQ. 1)  THEN                                      Disply 665
c              fully mixed flow                                                 Disply 666
          <ao.Toutlet> = <rf;Tfixture>                                          Disply 667
          <ao.Woutlet> = <rf;Wfixture>                                          Disply 668
        ELSE                                                                    Disply 669
c              Modify for plug (unmixed) flow                                   Disply 670
c              sensible cooling                                                 Disply 671
          Qsens        = <ac;TcoilUA> * (<rf;Tfixture>-<ac;TcoilNoQ>)           Disply 672
          dT           = MAX(0., Qsens / (<ai.Minlet>*<ac;CpDemand>))           Disply 673
          <ao.Toutlet> = <rf;Tfixture> + dT*0.5                                 Disply 674
c              latent cooling                                                   Disply 675
          Mcond        = <ac;SurfWoUA> * (<rf;Wfixture>-<ac;SurfWo>)            Disply 676
          dW           = MAX(0., Mcond / <ai.Minlet>)                           Disply 677
          <ao.Woutlet> = <rf;Wfixture> + dW*0.5                                 Disply 678
        ENDIF                                                                   Disply 679
c              Check for converence on outlet conditions                        Disply 680
        CALL CnvgCheck(2, <rf;ReturnHsty>)                                      Disply 681
        IF (<ac;DefrostReqd> .EQ. 1  .AND.  IterT .EQ. 1)  CYCLE                Disply 682
        IF (.NOT. IterReqdHsty(<rf;ReturnHsty>))  EXIT                          Disply 683
 3050 CONTINUE  ! IterT                                                         Disply 684
c                                                                               Disply 685
c              Moisture from product, and net moisture stored                   Disply 686
      dMLatProd          = <rf;dMIntLatProd> * RunFrac                          Disply 687
      dMLatStore         = dMLatProd - <rf;dMIntLat''>                          Disply 688
      <rf;MIntLatDef''>  = <rf;MIntLatDef'>                                     Disply 689
      <rf;MIntLatProd''> = MAX(0., <rf;MIntLatProd'> + dMLatProd)               Disply 690
      <rf;MIntLat''>     = MAX(0., <rf;MIntLat'>     + dMLatStore)              Disply 691
      IF (dMLatStore .GT. 0.000001)  THEN                                       Disply 692
c              stored moisture is accumulating                                  Disply 693
c              Enthalpy stored in moisture relative to 32F                      Disply 694
        IF (<rf;Tsurface''> .LT. 31.)  THEN                                     Disply 695
          dQstore = Hice(<rf;Tsurface''>)                                       Disply 696
        ELSEIF (<rf;Tsurface''> .GT. 33.)  THEN                                 Disply 697
          dQstore = Hliq(<rf;Tsurface''>)                                       Disply 698
        ELSE                                                                    Disply 699
          FracCond = (<rf;Tsurface''>-31.) * 0.5                                Disply 700
          dQstore  = Hliq(<rf;Tsurface''>) * FracCond                           Disply 701
     &             + Hice(<rf;Tsurface''>) * (1.-FracCond)                      Disply 702
        ENDIF                                                                   Disply 703
        <rf;QIntLat''> = <rf;QIntLat'> + dMLatStore*dQstore                     Disply 704
        IF (<rf;MIntLat''> .GT. <rf;MaxH2OStore>)  THEN                         Disply 705
c              Moisture must be drained or frost removed.  Put priority         Disply 706
c              on reducing defrost moisture, as product and infiltration        Disply 707
c              moisture would occur anyway, then reduce product moisture        Disply 708
c              (infiltration will be remainder, if any)                         Disply 709
          dMsurplus          = <rf;MIntLat''> - <rf;MaxH2OStore>                Disply 710
          dMLatStore         = dMLatStore - dMsurplus                           Disply 711
          <rf;QIntLat''>     = <rf;QIntLat''> - dMsurplus*dQstore               Disply 712
          dM                 = MIN(<rf;MIntLatDef''>, dMsurplus)                Disply 713
          <rf;MIntLatDef''>  = <rf;MIntLatDef''> - dM                           Disply 714
          dMsurplus          = dMsurplus - dM                                   Disply 715
          dM                 = MIN(<rf;MIntLatProd''>, dMsurplus)               Disply 716
          <rf;MIntLatProd''> = <rf;MIntLatProd''> - dM                          Disply 717
          <rf;MIntLat''>     = <rf;MaxH2OStore>                                 Disply 718
c              Account for defrost and product latent coil loads                Disply 719
          IF (<rf;dMIntLat''> .GT. 0.)  THEN                                    Disply 720
            <rf;QdefLat>  = -<rf;dQIntLat''>                                    Disply 721
     &                    * <rf;MIntLatDef''>/<rf;MIntLat''>                    Disply 722
            <rf;QprodLat> = -<rf;dQIntLat''>                                    Disply 723
     &                    * <rf;MIntLatProd''>/<rf;MIntLat''>                   Disply 724
          ENDIF                                                                 Disply 725
        ELSE                                                                    Disply 726
c              Account for defrost and product latent coil loads                Disply 727
          IF (<rf;dMIntLat''> .GT. 0.)  THEN                                    Disply 728
            <rf;QdefLat>  = -<rf;dQIntLat''>                                    Disply 729
     &                    * <rf;MIntLatDef'>/<rf;MIntLat''>                     Disply 730
            <rf;QprodLat> = -<rf;dQIntLat''>                                    Disply 731
     &                    * <rf;MIntLatProd'>/<rf;MIntLat''>                    Disply 732
          ENDIF                                                                 Disply 733
        ENDIF                                                                   Disply 734
      ELSEIF (dMLatStore .LT. 0.)  THEN                                         Disply 735
c              stored moisture is evaporating                                   Disply 736
        <rf;QdefLat>  = -<rf;dQIntLat''>*<rf;MIntLatDef'>/<rf;MIntLat'>         Disply 737
        <rf;QprodLat> = -<rf;dQIntLat''>*<rf;MIntLatProd'>/<rf;MIntLat'>        Disply 738
c                                                                               Disply 739
        dMsurplus = dMLatStore - dMLatProd                                      Disply 740
        IF (dMsurplus .LT. 0.)  THEN                                            Disply 741
c              Proportionately reduce product & coil storage quantities         Disply 742
c              (remainder is from infiltration)                                 Disply 743
          SumDefProd = <rf;MIntLatDef''> + <rf;MIntLatProd''>                   Disply 744
          IF (SumDefProd .GT. 0.000001)  THEN                                   Disply 745
            FracDef           = <rf;MIntLatDef''> / SumDefProd                  Disply 746
            <rf;MIntLatDef''>  = MAX(0., <rf;MIntLatDef''>                      Disply 747
     &                                         + dMsurplus*FracDef)             Disply 748
            <rf;MIntLatProd''> = MAX(0.,<rf;MIntLatProd''>                      Disply 749
     &                                         + dMsurplus*(1.-FracDef))        Disply 750
          ENDIF                                                                 Disply 751
        ENDIF                                                                   Disply 752
        <rf;QIntLat''> = <rf;QIntLat'> * (1.+dMLatStore/<rf;MIntLat'>)          Disply 753
      ELSEIF (<rf;dMIntLat''> .GT. 0.)  THEN                                    Disply 754
c              Produce sprays, etc., without any storage                        Disply 755
        <rf;QprodLat> = -<rf;dQIntLat''>                                        Disply 756
      ENDIF  ! dMLatStore .lt. 0.                                               Disply 757
c                                                                               Disply 758
c              Simulate the cooling coil, coolant side                          Disply 759
      CALL AirCoil_DX(33, Kac)                                                  Disply 760
c                                                                               Disply 761
      IF (Mode .EQ. 30)  THEN                                                   Disply 762
c              End of beginning of hour calculations                            Disply 763
c              Store sensible and latent extraction rate terms for use          Disply 764
c              in zone and air handler simulations                              Disply 765
        Kex           = <rf;QsensNode>                                          Disply 766
        <ex.Textract> = <rf;Tfixture>                                           Disply 767
        <ex.UA>       = UAinf1                                                  Disply 768
        Kex           = <rf;QlatNode>                                           Disply 769
        <ex.Mair>     = Minf1                                                   Disply 770
        <ex.Wextract> = <rf;Wfixture>                                           Disply 771
        IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                       Disply 772
          Kex           = <rf;QsensNode2>                                       Disply 773
          <ex.Textract> = <rf;Tfixture>                                         Disply 774
          <ex.UA>       = UAinf2                                                Disply 775
          Kex           = <rf;QlatNode2>                                        Disply 776
          <ex.Mair>     = Minf2                                                 Disply 777
          <ex.Wextract> = <rf;Wfixture>                                         Disply 778
        ENDIF                                                                   Disply 779
      ELSE                                                                      Disply 780
c              End of hour calculations                                         Disply 781
c                                                                               Disply 782
c              Calculate the error between the sensible and latent              Disply 783
c              extraction rates calculated in TEMDEV and the corrected          Disply 784
c              rates calculated here.  The next hour's zone extraction          Disply 785
c              rates will be adjusted by these amounts so that zonal            Disply 786
c              energy and moisture are conserved.                               Disply 787
        ZP1            = <rf:ZONE-NAME>                                         Disply 788
        Kex            = <rf;QsensNode>                                         Disply 789
        dT             = <zn;Tavg> - <rf;Tfixture>                              Disply 790
        <ex.Qextract>  = <ex.UA> * dT                                           Disply 791
        <ex.Qerror>    = <ex.UA> * (<ex.Textract>-<rf;Tfixture>)                Disply 792
        <rf;Qua>       = <rf;UA> * <rf.RunFrac> * dT                            Disply 793
        <rf;QinfSen>   = <ex.Qextract> - <rf;Qua>                               Disply 794
        Kex            = <rf;QlatNode>                                          Disply 795
        <ex.MWextract> = <ex.Mair> * (<zn;W'> - <rf;Wfixture>)                  Disply 796
        <ex.Qextract>  = <ex.MWextract> * 1061.                                 Disply 797
        <rf;QinfLat>   = <ex.Qextract>                                          Disply 798
        <ex.MWerror>   = <ex.Mair> * (<rf;Wfixture> - <ex.Wextract>)            Disply 799
        IF (<ac;DefrostFrac> .GT. 0)  THEN                                      Disply 800
          Kex            = <rf;QsensDefNode>                                    Disply 801
          dT             = <zn;Tavg> - <rf;Tdefrost>                            Disply 802
          <ex.Qextract>  = <ex.UA> * dT                                         Disply 803
          <ex.Qerror>    = <ex.UA> * (<ex.Textract>-<rf;Tdefrost>)              Disply 804
          Qua            = <rf;UA> * <ac;DefrostFrac> * dT                      Disply 805
          <rf;Qua>       = <rf;Qua> + Qua                                       Disply 806
          <rf;QinfSen>   = <rf;QinfSen> + <ex.Qextract> - Qua                   Disply 807
          Kex            = <rf;QlatDefNode>                                     Disply 808
          <ex.MWextract> = <ex.Mair> * (<zn;W'> - <rf;Wdefrost>)                Disply 809
          <ex.Qextract>  = <ex.MWextract> * 1061.                               Disply 810
          <rf;QinfLat>   = <rf;QinfLat> + <ex.Qextract>                         Disply 811
          <ex.MWerror>   = <ex.Mair> * (<rf;Wdefrost> - <ex.Wextract>)          Disply 812
        ENDIF                                                                   Disply 813
        IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                       Disply 814
          ZP1            = <rf:ZONE-NAME2>                                      Disply 815
          Kex            = <rf;QsensNode2>                                      Disply 816
          dT             = <zn;Tavg> - <rf;Tfixture>                            Disply 817
          <ex.Qextract>  = <ex.UA>  * dT                                        Disply 818
          <ex.Qerror>    = <ex.UA>  * (<ex.Textract>-<rf;Tfixture>)             Disply 819
          Qua            = <rf;UA2> * <rf.RunFrac> * dT                         Disply 820
          <rf;Qua>       = <rf;Qua> + Qua                                       Disply 821
          <rf;QinfSen>   = <rf;QinfSen> + <ex.Qextract> - Qua                   Disply 822
          Kex            = <rf;QlatNode2>                                       Disply 823
          <ex.MWextract> = <ex.Mair> * (<zn;W'> - <rf;Wfixture>)                Disply 824
          <ex.Qextract>  = <ex.MWextract> * 1061.                               Disply 825
          <rf;QinfLat>   = <rf;QinfLat> + <ex.Qextract>                         Disply 826
          <ex.MWerror>   = <ex.Mair> * (<rf;Wfixture> - <ex.Wextract>)          Disply 827
          IF (<ac;DefrostFrac> .GT. 0)  THEN                                    Disply 828
            Kex            = <rf;QsensDefNode2>                                 Disply 829
            dT             = <zn;Tavg> - <rf;Tdefrost>                          Disply 830
            <ex.Qextract>  = <ex.UA>  * dT                                      Disply 831
            <ex.Qerror>    = <ex.UA>  * (<ex.Textract>-<rf;Tdefrost>)           Disply 832
            Qua            = <rf;UA2> * <ac;DefrostFrac> * dT                   Disply 833
            <rf;Qua>       = <rf;Qua> + Qua                                     Disply 834
            <rf;QinfSen>   = <rf;QinfSen> + <ex.Qextract> - Qua                 Disply 835
            Kex            = <rf;QlatDefNode2>                                  Disply 836
            <ex.MWextract> = <ex.Mair> * (<zn;W'> - <rf;Wdefrost>)              Disply 837
            <ex.Qextract>  = <ex.MWextract> * 1061.                             Disply 838
            <rf;QinfLat>   = <rf;QinfLat> + <ex.Qextract>                       Disply 839
            <ex.MWerror>   = <ex.Mair> * (<rf;Wdefrost> - <ex.Wextract>)        Disply 840
          ENDIF                                                                 Disply 841
        ENDIF                                                                   Disply 842
      ENDIF  ! Mode                                                             Disply 843
c                                                                               Disply 844
c              Sensible gain from product                                       Disply 845
      <rf;QprodSenNet> = <rf;QprodSen> - <rf;QprodLat>                          Disply 846
     &                 + <rf;StorageSen>*(<rf;Tsurface>-<rf;Tsurface''>)        Disply 847
c                                                                               Disply 848
c                                                                               Disply 849
c ============ STATISTICS - HOURLY DATA ======================================= Disply 850
      CASE (42)                                                                 Disply 851
c                                                                               Disply 852
c              Cooling coil                                                     Disply 853
      CALL AirCoil_DX(Mode, Kac)                                                Disply 854
c                                                                               Disply 855
c                                                                               Disply 856
c ============ REPORT CREATION ================================================ Disply 857
      CASE (50)                                                                 Disply 858
c                                                                               Disply 859
      Kro        = <ac;SuctionNode>                                             Disply 860
      Ks2Load    = NewStat2(Kac, <+ac;Qsupply>, 0, 1.)                          Disply 861
      Ks5LoadBin = NewStat5(Kac, <+ac;Qsupply>, 0, 1.)                          Disply 862
      Ks2Refg    = NewStat2(Kro, <+ro.Moutlet>, 1, 1.)                          Disply 863
      Ks2Elec    = NewStat2(<rf:ELEC-METER>, <+md.Elec>, 1, 1.)                 Disply 864
c                                                                               Disply 865
c              Create the type "H" report                                       Disply 866
      IF (<rf:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      Disply 867
     &  <rf;PS-H> = NewReport_H(Jrf, 134,                                       Disply 868
     &                          4, 5, 6,                                        Disply 869
     &                          Ks2Load, Ks2Refg, Ks2Elec, 0,                   Disply 870
     &                          Ks5LoadBin, 0, 0,                               Disply 871
     &                          0, 0, 0)                                        Disply 872
c                                                                               Disply 873
c              Create the type "I" reports                                      Disply 874
      IF (<rf:REPORTS> .GT. 0  .AND.  IREPRT(3,24) .GT. 0)  THEN                Disply 875
c              Defrost efficiency report                                        Disply 876
        Ks2Mfrost   = NewStat2(Kac, <+ac;Mdefrost>,    1, 1.)                   Disply 877
        Ks2Qmelt    = NewStat2(Kac, <+ac;Qmelt>,       1, 1.)                   Disply 878
        Ks2Qreqd    = NewStat2(Kac, <+ac;QdefReqd>,    1, 1.)                   Disply 879
        Ks2Qactual  = NewStat2(Kac, <+ac;Qdefroster>,  1, 1.)                   Disply 880
        Ks2TimeReqd = NewStat2(Kac, <+ac;DefTimeReqd>, 1, 1.)                   Disply 881
        Ks2TimeAct  = NewStat2(Kac, <+ac;DefTime>,     1, 1.)                   Disply 882
        <rf;PS-I1> = NewReport_I(Jrf, 142,                                      Disply 883
     &                   1, 2, 3,                                               Disply 884
     &                   Ks2Mfrost,   Ks2Qmelt,   Ks2Qreqd, Ks2Qactual,         Disply 885
     &                   Ks2TimeReqd, Ks2TimeAct, 0,        0,                  Disply 886
     &                   0,           0,          0,        0)                  Disply 887
c                                                                               Disply 888
c              load report                                                      Disply 889
        Ks2Qlit  = NewStat2(Jrf, <+rf;Qlights>,     1, 1.)                      Disply 890
        Ks2Qfan  = NewStat2(Jrf, <+rf;Qfans>,       1, 1.)                      Disply 891
        Ks2Qswt  = NewStat2(Jrf, <+rf;Qsweat>,      1, 1.)                      Disply 892
        Ks2Qua   = NewStat2(Jrf, <+rf;Qua>,         0, 1.)                      Disply 893
        Ks2Qinfs = NewStat2(Jrf, <+rf;QinfSen>,     0, 1.)                      Disply 894
        Ks2Psen  = NewStat2(Jrf, <+rf;QprodSenNet>, 0, 1.)                      Disply 895
        Ks2Plat  = NewStat2(Jrf, <+rf;QprodLat>,    0, 1.)                      Disply 896
        Ks2Dsen  = NewStat2(Jrf, <+rf;QdefSen>,     0, 1.)                      Disply 897
        Ks2Dlat  = NewStat2(Jrf, <+rf;QdefLat>,     0, 1.)                      Disply 898
c                                                                               Disply 899
        Kli      = 0                                                            Disply 900
        CALL ListNodes(Kli, 0,0,Jrf,0, 32,0)                                    Disply 901
        Ks2Qinfl = NewStat2(Kli, <+ex.Qextract>, 0, 1.)                         Disply 902
c                                                                               Disply 903
        <rf;PS-I2> = NewReport_I(Jrf, 135,                                      Disply 904
     &                   1, 2, 3,                                               Disply 905
     &                   Ks2Qua,  Ks2Qinfs, Ks2Qinfl, Ks2Qlit,                  Disply 906
     &                   Ks2Qfan, Ks2Qswt,  Ks2Psen,  Ks2Plat,                  Disply 907
     &                   Ks2Dsen, Ks2Dlat,  Ks2Load,  0)                        Disply 908
c                                                                               Disply 909
c              electric report                                                  Disply 910
        Ks2kWlit = NewStat2(Jrf, <+rf;kWlights>,  1, 1.)                        Disply 911
        Ks2kWfan = NewStat2(Jrf, <+rf;kWfans>,    1, 1.)                        Disply 912
        Ks2kWswt = NewStat2(Jrf, <+rf;kWsweat>,   1, 1.)                        Disply 913
        Ks2kWaux = NewStat2(<rf:AUX-METER>,  <+md.Elec>, 1, 1.)                 Disply 914
        Ks2kWdef = NewStat2(<ac:ELEC-METER>, <+md.Elec>, 1, 1.)                 Disply 915
c                                                                               Disply 916
        Kli = 0                                                                 Disply 917
        CALL ListNodes(Kli, 0,0,Jrf,0, 11,0)                                    Disply 918
        CALL ListAdd(Kli, <ac:ELEC-METER>)                                      Disply 919
        Ks2kWtot = NewStat2(Kli, <+md.Elec>, 1, 1.)                             Disply 920
c                                                                               Disply 921
        <rf;PS-I3> = NewReport_I(Jrf, 136,                                      Disply 922
     &                   1, 2, 3,                                               Disply 923
     &                   Ks2kWlit, Ks2kWfan, Ks2kWswt, Ks2kWdef,                Disply 924
     &                   Ks2kWaux, Ks2kWtot,        0,        0,                Disply 925
     &                          0,        0,        0,        0)                Disply 926
      ENDIF                                                                     Disply 927
c                                                                               Disply 928
c              Setpoint overload                                                Disply 929
      <rf;s10> = NewStat10(Jrf, <#ai.Treqd>,<#Xai.Tinlet>, 1.0, 1, 1)           Disply 930
c                                                                               Disply 931
c                                                                               Disply 932
c ============ REPORT ORDER =================================================== Disply 933
      CASE (52)                                                                 Disply 934
c                                                                               Disply 935
      Call Report_H(Mode, <rf;PS-H>)                                            Disply 936
      Call Report_I(Mode, <rf;PS-I1>)                                           Disply 937
      Call Report_I(Mode, <rf;PS-I2>)                                           Disply 938
      Call Report_I(Mode, <rf;PS-I3>)                                           Disply 939
c                                                                               Disply 940
c                                                                               Disply 941
c ============ REPORTS - VERIFICATION DATA ==================================== Disply 942
      CASE (54)                                                                 Disply 943
c                                                                               Disply 944
c              Output design information                                        Disply 945
      IF (<rf;PS-H> .ne. 0)  THEN                                               Disply 946
        rH = <rf;PS-H>                                                          Disply 947
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       Disply 948
        CALL GetAttachments(Jrf, 2)                                             Disply 949
        Kro = <ac;SuctionNode>                                                  Disply 950
        Kmd = <rf:ELEC-METER>                                                   Disply 951
        WRITE (IREPFL)  26,<rH;Iuniq>,1,2,22,                                   Disply 952
     &    (NameAttachments(II,1,1),II=1,8),                                     Disply 953
     &    (NameAttachments(II,1,2),II=1,8),                                     Disply 954
     &    <ac;Qair>,<ro.Moutlet>,<md.Elec>,                                     Disply 955
     &    (<rf;SurfaceUA>+<rf;SurfaceUA2>),                                     Disply 956
     &    (<rf;DesCFMinf>+<rf;DesCFMinf2>),<rf;StorageSen>                      Disply 957
        DO  Irow=2,NumRowsOfAttachments                                         Disply 958
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 Disply 959
     &      (NameAttachments(II,Irow,1),II=1,8),                                Disply 960
     &      (NameAttachments(II,Irow,2),II=1,8)                                 Disply 961
        ENDDO                                                                   Disply 962
      ENDIF                                                                     Disply 963
c                                                                               Disply 964
c                                                                               Disply 965
c ============ REPORTS - YEARLY SUMMARY (SPECIAL) ============================= Disply 966
      CASE (58)                                                                 Disply 967
c                                                                               Disply 968
c              Setpoint overload                                                Disply 969
      IF (<rf;PS-H> .ne. 0)  THEN                                               Disply 970
        rH = <rf;PS-H>                                                          Disply 971
        CALL Report_s10(<rH;Iuniq>, 7, <rf;s10>)                                Disply 972
      ENDIF                                                                     Disply 973
c                                                                               Disply 974
c                                                                               Disply 975
c ============ HOURLY REPORTS - HOURLY DATA =================================== Disply 976
      CASE (62)                                                                 Disply 977
c                                                                               Disply 978
      IF (<rf;HourRepBuf> .EQ. 0)  RETURN                                       Disply 979
c                                                                               Disply 980
      IAptr        = <rf;HourRepBuf> - 1                                        Disply 981
      AA(IAptr+1)  = <Xao.Qoutlet>                                              Disply 982
      AA(IAptr+2)  = <ac;Qsupply>                                               Disply 983
      AA(IAptr+3)  = <rf.RunFrac>                                               Disply 984
      AA(IAptr+4)  = <rf;QfixCoil>                                              Disply 985
      AA(IAptr+5)  = <rf;QfixCoil'>                                             Disply 986
      AA(IAptr+6)  = <rf;QdefSen>                                               Disply 987
      AA(IAptr+7)  = <rf;QdefLat>                                               Disply 988
      AA(IAptr+8)  = <rf;QprodSenNet>                                           Disply 989
      AA(IAptr+9)  = <rf;QprodSen>                                              Disply 990
      AA(IAptr+10) = <rf;QprodLat>                                              Disply 991
      AA(IAptr+11) = <Xai.Tinlet>                                               Disply 992
      AA(IAptr+12) = <Xai.Winlet>                                               Disply 993
      AA(IAptr+13) = <ao.Toutlet>                                               Disply 994
      AA(IAptr+14) = <ao.Woutlet>                                               Disply 995
      AA(IAptr+15) = <rf;Tfixture>                                              Disply 996
      AA(IAptr+16) = <rf;Wfixture>                                              Disply 997
      AA(IAptr+17) = <rf;dQIntLat''>                                            Disply 998
      AA(IAptr+18) = <rf;dMIntLat''>                                            Disply 999
      AA(IAptr+19) = <rf;Tdefrost>                                              Disply1000
      AA(IAptr+20) = <rf;Wdefrost>                                              Disply1001
      AA(IAptr+21) = <rf;dQIntLat'>                                             Disply1002
      AA(IAptr+22) = <rf;dMIntLat'>                                             Disply1003
      AA(IAptr+23) = <rf;Qua>                                                   Disply1004
      AA(IAptr+24) = <rf;UA>                                                    Disply1005
      AA(IAptr+25) = <rf;UA2>                                                   Disply1006
      AA(IAptr+26) = <rf;QinfSen>                                               Disply1007
      AA(IAptr+27) = <rf;QinfLat>                                               Disply1008
      AA(IAptr+28) = <rf;CFMinfil>                                              Disply1009
      AA(IAptr+29) = <rf;CFMinfil2>                                             Disply1010
      AA(IAptr+30) = <rf;Qlights>                                               Disply1011
      AA(IAptr+31) = <rf;kWlights>                                              Disply1012
      AA(IAptr+32) = <rf;Qfans>                                                 Disply1013
      AA(IAptr+33) = <rf;kWfans>                                                Disply1014
      AA(IAptr+34) = <rf;Qsweat>                                                Disply1015
      AA(IAptr+35) = <rf;kWsweat>                                               Disply1016
      AA(IAptr+36) = <rf;Tsurface>                                              Disply1017
      AA(IAptr+37) = <rf;Tsurface'>                                             Disply1018
      AA(IAptr+38) = <rf;Tsurface''>                                            Disply1019
      AA(IAptr+39) = <rf;MIntLat>                                               Disply1020
      AA(IAptr+40) = <rf;MIntLat'>                                              Disply1021
      AA(IAptr+41) = <rf;MIntLat''>                                             Disply1022
      AA(IAptr+42) = <ac;ChokeHours>                                            Disply1023
      AA(IAptr+43) = <ac;Mfrost>                                                Disply1024
      AA(IAptr+44) = <ac;Mfrost'>                                               Disply1025
      AA(IAptr+45) = <ac;Mfrost''>                                              Disply1026
      AA(IAptr+46) = <ac;Qfrost>                                                Disply1027
      AA(IAptr+47) = <ac;Qfrost'>                                               Disply1028
      AA(IAptr+48) = <ac;Qfrost''>                                              Disply1029
      AA(IAptr+49) = <ac;SST>                                                   Disply1030
      AA(IAptr+50) = <ac;SSTreqd>                                               Disply1031
      AA(IAptr+52) = <ac;Mlatent>                                               Disply1032
      AA(IAptr+53) = <ac;Hlatent>                                               Disply1033
      AA(IAptr+54) = <ac;SurfTi>                                                Disply1034
      AA(IAptr+55) = <ac;Tdry/wet>                                              Disply1035
      AA(IAptr+56) = <ac;SurfTo>                                                Disply1036
      AA(IAptr+57) = <ac;FracWet>                                               Disply1037
      AA(IAptr+58) = <ac;Hdry/wet>                                              Disply1038
      AA(IAptr+59) = <ac;FracFrosted>                                           Disply1039
c                                                                               Disply1040
c              DX coil                                                          Disply1041
      IF (<ac;SuctionNode> .GT. 0)  THEN                                        Disply1042
        Kro = <ac;SuctionNode>             ! Suction outlet                     Disply1043
        Jre = <ac;Refrigerant>             ! Refrigerant                        Disply1044
        AA(IAptr+51) = RefgT_fP(Jre, <ro.Preqd>)                                Disply1045
      ENDIF                                                                     Disply1046
c                                                                               Disply1047
c                                                                               Disply1048
c ============ DESIGN CALCULATIONS - RATED CONDITIONS ========================= Disply1049
      CASE (110)                                                                Disply1050
c                                                                               Disply1051
c              Lighting loads - canopy, shelving                                Disply1052
      CanopyKW = <rf:CANOPY-KW> + <rf:CANOPY-KW/LEN>*<rf:LINE-UP-LEN>           Disply1053
      ShelfKW  = <rf:SHELF-KW>  + <rf:SHELF-KW/LEN> *<rf:LINE-UP-LEN>           Disply1054
      ShelfKW  = ShelfKW * <rf:NUM-SHELVES>                                     Disply1055
      <rf;LightskWDes>   = CanopyKW + ShelfKW                                   Disply1056
      IF (<rf;LightskWDes> .GT. 0.)  THEN                                       Disply1057
        <rf;LightToFixtur> = <rf;LightskWDes> * BtuKW     ! fixture load        Disply1058
        <rf;LightToZone>   = (CanopyKW*<rf:CANOPY-TO-Z>   ! zone load           Disply1059
     &                     +  ShelfKW *<rf:SHELF-TO-Z>)                         Disply1060
     &                     / <rf;LightskWDes>                                   Disply1061
        <rf;LightToZone>   = <rf;LightToFixtur> * <rf;LightToZone>              Disply1062
        <rf;LightToZone2>  = (CanopyKW*<rf:CANOPY-TO-Z2>  ! zone2 load          Disply1063
     &                     +  ShelfKW *<rf:SHELF-TO-Z2>)                        Disply1064
     &                     / <rf;LightskWDes>                                   Disply1065
        <rf;LightToZone2>  = <rf;LightToFixtur> * <rf;LightToZone2>             Disply1066
        <rf;LightToFixtur> = <rf;LightToFixtur> - <rf;LightToZone>              Disply1067
     &                                          - <rf;LightToZone2>             Disply1068
      ENDIF                                                                     Disply1069
c                                                                               Disply1070
c              Evaporator fan                                                   Disply1071
      <rf;FankW>        = <rf:FAN-KW> + <rf:FAN-KW/LEN>*<rf:LINE-UP-LEN>        Disply1072
      <rf;FanToFixture> = <rf;FankW> * BtuKW                                    Disply1073
      <rf;FanToZone>    = <rf;FanToFixture> * <rf:FAN-TO-Z>                     Disply1074
      <rf;FanToZone2>   = <rf;FanToFixture> * <rf:FAN-TO-Z2>                    Disply1075
      <rf;FanToFixture> = <rf;FanToFixture> - <rf;FanToZone>                    Disply1076
     &                                      - <rf;FanToZone2>                   Disply1077
c                                                                               Disply1078
c              Anti-sweat heater                                                Disply1079
      <rf;HeaterkW>     = <rf:HEATER-KW>                                        Disply1080
     &                           + <rf:HEATER-KW/LEN>*<rf:LINE-UP-LEN>          Disply1081
      <rf;HtrToFixture> = <rf;HeaterkW> * BtuKW                                 Disply1082
      <rf;HtrToZone>    = <rf;HtrToFixture> * <rf:HEATER-TO-Z>                  Disply1083
      <rf;HtrToZone2>   = <rf;HtrToFixture> * <rf:HEATER-TO-Z2>                 Disply1084
      <rf;HtrToFixture> = <rf;HtrToFixture> - <rf;HtrToZone>                    Disply1085
     &                                      - <rf;HtrToZone2>                   Disply1086
c                                                                               Disply1087
c              Product load                                                     Disply1088
      <rf;ProductSen> = <rf:CONTENT-SENS>                                       Disply1089
     &                + <rf:CONT-SENS/LEN>*<rf:LINE-UP-LEN>                     Disply1090
      <rf;ProductLat> = <rf:CONTENT-LAT>                                        Disply1091
     &                + <rf:CONTENT-LAT/L>*<rf:LINE-UP-LEN>                     Disply1092
c                                                                               Disply1093
c              Calculate the loads, airflow, and design the coil using          Disply1094
c              the RATED conditions                                             Disply1095
c                                                                               Disply1096
c              Rated zone temperature, humidity ratio and enthalpy              Disply1097
      Tzone1 = <rf:ZONE-T>                                                      Disply1098
      Wzone1 = Wfunc(Tzone1, <rf:ZONE-RH>, BLDGP)                               Disply1099
      Hzone1 = HAir (Tzone1, Wzone1)                                            Disply1100
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN  ! secondary zone                       Disply1101
        Tzone2 = <rf:ZONE-T2>                                                   Disply1102
        Wzone2 = Wfunc(Tzone2, <rf:ZONE-RH2>, BLDGP)                            Disply1103
        Hzone2 = HAir (Tzone2, Wzone2)                                          Disply1104
      ENDIF                                                                     Disply1105
c                                                                               Disply1106
c              Rated supply temperature and airflow                             Disply1107
      Tsupply   = <rf:RATED-T>                                                  Disply1108
      SupplyCFM = <rf:SUPPLY-CFM>+<rf:SUPPLY-CFM/FT>*<rf:LINE-UP-LEN>           Disply1109
c              first guess at supply humidity                                   Disply1110
      <Xai.Winlet> = Wfunc(Tsupply, 95., BLDGP)                                 Disply1111
      <ao.Woutlet> = <Xai.Winlet>                                               Disply1112
c              solve for the design balance point between the fixture           Disply1113
c              and the cooling coil                                             Disply1114
      ModeBalance = 1                                                           Disply1115
      Call DesignBalance                                                        Disply1116
      IF (IwinReturn .eq. 1)  Return                                            Disply1117
c                                                                               Disply1118
c              Check for low airflow                                            Disply1119
      IF (SupplyCFM .gt. 0.)  THEN                                              Disply1120
        dT = <ao.Toutlet> - Tsupply                                             Disply1121
        IF (dT .gt. 15.)  THEN                                                  Disply1122
          CALL MSGSIM(-3,II,II,II,II)                                           Disply1123
          WRITE (IOUTPT, 9004) (<rf:NAME>,II=1,8),                              Disply1124
     &                          SupplyCFM, dT                                   Disply1125
        ENDIF                                                                   Disply1126
      ENDIF                                                                     Disply1127
c              Check for undersized coil                                        Disply1128
      IF (<ac:CAP> .gt. 0.  .and.  <ac:CAP>*1.05 .lt. Qreqd)  THEN              Disply1129
        CALL MSGSIM(-2,II,II,II,II)                                             Disply1130
        WRITE (IOUTPT, 9005) (<rf:NAME>,II=1,8),                                Disply1131
     &                        <ac:CAP>, Qreqd                                   Disply1132
        CALL MessageBox( NULL,                                                  Disply1133
     &   'Fixture has undersized coil'//char(10)//char(13)//                    Disply1134
     &   ' - Will override size'//char(0),                                      Disply1135
     &   'REFG-FIXTURE Errors'//char(0),                                        Disply1136
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  Disply1137
      ENDIF                                                                     Disply1138
c                                                                               Disply1139
c              Convert coil mass flow to cfm                                    Disply1140
      <rf;SupplyCFM> = <ao.Moutlet> * Vsupply / 60.                             Disply1141
c                                                                               Disply1142
c              UA product for conduction thru surfaces                          Disply1143
      <rf;SurfaceUA>  = Qcond1 / (Tzone1-<rf;Tfixture>)                         Disply1144
      IF (<rf:ZONE-NAME2> .GT. 0)                                               Disply1145
     &  <rf;SurfaceUA2> = Qcond2 / (Tzone2-<rf;Tfixture>)                       Disply1146
c              Infiltration rates                                               Disply1147
      <rf;DesCFMinf>  = Minf1 / <rf;Lbs/CFMinf>  ! cfm                          Disply1148
      <rf;DesCFMinf2> = Minf2 / <rf;Lbs/CFMinf>                                 Disply1149
c                                                                               Disply1150
c              Initialize zone nodes, sensible, latent, and fixed               Disply1151
      Kex             = <rf;QsensNode>                                          Disply1152
      <ex.Textract>   = <rf;Tfixture>                                           Disply1153
      <ex.UA>         = <rf;SurfaceUA> + Minf1*0.242                            Disply1154
      <ex.ReturnFrac> = <rf:FRAC-TO-RETUR>                                      Disply1155
      Kex             = <rf;QlatNode>                                           Disply1156
      <ex.Mair>       = Minf1                                                   Disply1157
      <ex.Wextract>   = <rf;Wfixture>                                           Disply1158
      Kex             = <rf;QfixedNode>                                         Disply1159
      <ex.Qextract>   = -(<rf;LightToZone>+<rf;FanToZone>                       Disply1160
     &                                    +<rf;HtrToZone>)                      Disply1161
c              repeat for 2nd zone, if specified                                Disply1162
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                         Disply1163
        Kex             = <rf;QsensNode2>                                       Disply1164
        <ex.Textract>   = <rf;Tfixture>                                         Disply1165
        <ex.UA>         = <rf;SurfaceUA2> + Minf2*0.242                         Disply1166
        <ex.ReturnFrac> = <rf:FRAC-TO-RETUR>                                    Disply1167
        Kex             = <rf;QlatNode2>                                        Disply1168
        <ex.Mair>       = Minf2                                                 Disply1169
        <ex.Wextract>   = <rf;Wfixture>                                         Disply1170
        Kex             = <rf;QfixedNode2>                                      Disply1171
        <ex.Qextract>   = -(<rf;LightToZone2>+<rf;FanToZone2>                   Disply1172
     &                                       +<rf;HtrToZone2>)                  Disply1173
      ENDIF                                                                     Disply1174
c                                                                               Disply1175
c              Design electrical                                                Disply1176
      Kmd       = <rf:ELEC-METER>                                               Disply1177
      <md.Elec> = <rf;LightskWDes> + <rf;FankW> + <rf;HeaterkW>                 Disply1178
c              Auxiliary power                                                  Disply1179
      IF (<rf:AUX-METER> .GT. 0.)  THEN                                         Disply1180
        Kmd       = <rf:AUX-METER>                                              Disply1181
        <md.Elec> = <rf:AUX-KW>                                                 Disply1182
      ENDIF                                                                     Disply1183
c                                                                               Disply1184
c              Fixture temperature at end of defrost                            Disply1185
      <rf;Tdefrost> = <rf;Tfixture> + <rf:DEF-DT>                               Disply1186
c                                                                               Disply1187
c                                                                               Disply1188
c ============ DESIGN CALCULATIONS - AIR SIDE ================================= Disply1189
      CASE (111)                                                                Disply1190
c                                                                               Disply1191
c              Coil loads at design conditions                                  Disply1192
c                                                                               Disply1193
c              Design zone temperature, humidity ratio and enthalpy             Disply1194
      ZP1    = <rf:ZONE-NAME>                                                   Disply1195
      ZP2    = <ZP2>                                                            Disply1196
      Tzone1 = <DESIGN-COOL-T>                                                  Disply1197
      Wzone1 = Wfunc(Tzone1, <rf:ZONE-RH>, BLDGP)                               Disply1198
      Hzone1 = HAir (Tzone1, Wzone1)                                            Disply1199
      IF (<rf:ZONE-NAME2> .GT. 0)  THEN  ! secondary zone                       Disply1200
        ZP1    = <rf:ZONE-NAME2>                                                Disply1201
        ZP2    = <ZP2>                                                          Disply1202
        Tzone2 = <DESIGN-COOL-T>                                                Disply1203
        Wzone2 = Wfunc(Tzone2, <rf:ZONE-RH2>, BLDGP)                            Disply1204
        Hzone2 = HAir (Tzone2, Wzone2)                                          Disply1205
      ENDIF                                                                     Disply1206
c                                                                               Disply1207
c              Design supply temperature and rated airflow                      Disply1208
      Tsupply   = <rf:SUPPLY-T>                                                 Disply1209
      SupplyCFM = <rf;SupplyCFM>                                                Disply1210
c              solve for the design balance point coil properties               Disply1211
      ModeBalance = 2                                                           Disply1212
      Call DesignBalance                                                        Disply1213
      IF (IwinReturn .eq. 1)  Return                                            Disply1214
c                                                                               Disply1215
c                                                                               Disply1216
c ============ DESIGN CALCULATIONS - REFRIGERANT SIDE ========================= Disply1217
      CASE (112)                                                                Disply1218
c                                                                               Disply1219
      CALL AirCoil_DX(Mode, Kac)                                                Disply1220
c                                                                               Disply1221
c                                                                               Disply1222
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== Disply1223
      CASE (119)                                                                Disply1224
c                                                                               Disply1225
      <rf;Mair> = <ao.Moutlet>                                                  Disply1226
c              Initialize contents temperature                                  Disply1227
      <rf;Tsurface>   = <rf;Tfixture>                                           Disply1228
      <rf;Tsurface''> = <rf;Tfixture>                                           Disply1229
c                                                                               Disply1230
c              Latent storage                                                   Disply1231
      <rf;MaxH2OStore> = <rf:LATENT-STORE>                                      Disply1232
     &                 + <rf:LAT-STORE/L>*<rf:LINE-UP-LEN>                      Disply1233
c                                                                               Disply1234
c              Sensible storage                                                 Disply1235
      <rf;StorageSen> = <rf:SENS-STORAGE>                                       Disply1236
     &                + <rf:SENS-STOR/LEN>*<rf:LINE-UP-LEN>                     Disply1237
c                                                                               Disply1238
      CALL AirCoil_DX(Mode, Kac)                                                Disply1239
c                                                                               Disply1240
c              Defrost and default thermal mass in fixture                      Disply1241
      IF (<rf:DEF-TYPE> .GT. 0)  THEN                                           Disply1242
        <rf;Lbs/CFMinfDef> = <rf;Lbs/CFMinf> * <rf:DEF-INF>                     Disply1243
c              Default based on loads and temperature rise during defrost       Disply1244
c              anti-sweat, defroster, product, lights, fans                     Disply1245
c ?? ignore QdefLoss; it makes the mass too big                                 Disply1246
c ??        Qdef = <rf;HtrToFixture> + <ac;QdefLoss> + <rf;ProductSen>          Disply1247
        Qdef = <rf;HtrToFixture> + <rf;ProductSen>                              Disply1248
        IF (<rf:LIGHTS-W/DEF>  .EQ. 0)  Qdef = Qdef+<rf;LightToFixtur>          Disply1249
        IF (<rf:FAN-W/DEFROST> .EQ. 0)  Qdef = Qdef+<rf;FanToFixture>           Disply1250
        IF (<rf:HTR-W/DEFROST> .EQ. 0)  Qdef = Qdef+<rf;HtrToFixture>           Disply1251
c              first zone                                                       Disply1252
        UAinf = <rf;DesCFMinf>*60.*<rf:DEF-INF>*0.242                           Disply1253
     &                            / V(<rf;Tdefrost>,<rf;Wfixture>,BLDGP)        Disply1254
        Qdef = Qdef                                                             Disply1255
     &       + (<rf;SurfaceUA>+UAinf) * (<rf:ZONE-T>-<rf;Tdefrost>)             Disply1256
c              second zone                                                      Disply1257
        IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                       Disply1258
          UAinf = <rf;DesCFMinf2>*60.*<rf:DEF-INF>*0.242                        Disply1259
     &                            / V(<rf;Tdefrost>,<rf;Wfixture>,BLDGP)        Disply1260
          Qdef = Qdef                                                           Disply1261
     &         + (<rf;SurfaceUA2>+UAinf)*(<rf:ZONE-T2>-<rf;Tdefrost>)           Disply1262
        ENDIF                                                                   Disply1263
c              sensible storage capacity                                        Disply1264
        IF (<rf;StorageSen> .EQ. 0.)  THEN                                      Disply1265
          <rf;StorageSen> = Qdef*<rf:DEF-DURATION>                              Disply1266
     &                               / (60.*<rf:DEF-DT>*<rf:SENS-DECAY>)        Disply1267
          <rf;StorageSen> = MAX(1000., <rf;StorageSen>)                         Disply1268
        ENDIF                                                                   Disply1269
      ELSE                                                                      Disply1270
c              Default capacitance based on 40% of air coil capacity            Disply1271
        IF (<rf;StorageSen> .EQ. 0.)                                            Disply1272
     &    <rf;StorageSen> = MAX(1000., <Xai.Qinlet> * 0.4)                      Disply1273
      ENDIF                                                                     Disply1274
c              Time constant used in calculating contents temperature           Disply1275
      <rf;-rSensible> = LOG(1.0 - <rf:SENS-DECAY>)                              Disply1276
c                                                                               Disply1277
c              clear coil setpoints                                             Disply1278
      <ai.Treqd>  = -88888.                                                     Disply1279
      <ai.Wreqd>  = -88888.                                                     Disply1280
c                                                                               Disply1281
c                                                                               Disply1282
c ============ ATTACHMENTS ==================================================== Disply1283
c                                                                               Disply1284
c              Initial attachments                                              Disply1285
      CASE (201)                                                                Disply1286
c                                                                               Disply1287
c              Checks on inputs                                                 Disply1288
c                - fan must run with OFF-CYCLE defrost                          Disply1289
        IF (<rf:DEF-TYPE> .eq. 3)  <rf:FAN-W/DEFROST> = 0                       Disply1290
c                                                                               Disply1291
c              Create the air coil and transfer parameters                      Disply1292
        Kac                = NewAirCoil(Jrf)                                    Disply1293
        <rf;AirCoil>       = Kac                                                Disply1294
        <ac:CAP>           = <rf:EVAP-CAP>                                      Disply1295
     &                     + <rf:EVAP-CAP/LEN> * <rf:LINE-UP-LEN>               Disply1296
        <ac:LIQUID-CKT>    = <rf:LIQUID-CKT>                                    Disply1297
        <ac:SUCTION-CKT>   = <rf:SUCTION-CKT>                                   Disply1298
        <ac:HOT-GAS-CKT>   = <rf:HOT-GAS-CKT>                                   Disply1299
        <ac:SUPPLY-FLOW>   = <rf:SUPPLY-FLOW>                                   Disply1300
        <ac:SUPPLY-DP>     = <rf:SUPPLY-DP>                                     Disply1301
        <ac:CTRL-VALVE-DT> = <rf:CTRL-VALVE-DT>                                 Disply1302
        <ac:MIN-CTRL-DP>   = <rf:MIN-CTRL-DP>                                   Disply1303
        <ac:COIL-UA>       = <rf:EVAP-UA>                                       Disply1304
        <ac:SST-SUPPLY-TD> = <rf:SST-SUPPLY-TD>                                 Disply1305
        <ac:MAX-FROST-DT>  = <rf:MAX-FROST-DT>                                  Disply1306
        <ac:AIR-RES>       = <rf:AIR-RES>                                       Disply1307
        <ac:DRY/WET-RES>   = <rf:DRY/WET-RES>                                   Disply1308
        <ac:SUP-RES>       = <rf:SUP-RES>                                       Disply1309
        <ac:SUPERHEAT-DT>  = <rf:SUPERHEAT-T>                                   Disply1310
        <ac:TEMP-CTRL>     = <rf:TEMP-CTRL>                                     Disply1311
        <ac:FAN-W/DEFROST> = <rf:FAN-W/DEFROST>                                 Disply1312
        <ac:TEMP-THROTTLE> = <rf:TEMP-THROTTLE>                                 Disply1313
        <ac:DEF-TYPE>      = <rf:DEF-TYPE>                                      Disply1314
        <ac:DEF-CAP>       = <rf:DEF-CAP>                                       Disply1315
     &                     + <rf:DEF-CAP/LEN> * <rf:LINE-UP-LEN>                Disply1316
        <ac:DEFROST-RATIO> = <rf:DEFROST-RATIO>                                 Disply1317
        <ac:DEF-EFF>       = <rf:DEF-EFF>                                       Disply1318
        <ac:DEF-INITIATE>  = <rf:DEF-INITIATE>                                  Disply1319
        <ac:DEF-SCH>       = <rf:DEF-SCH>                                       Disply1320
        <ac:MAX-FROST>     = <rf:MAX-FROST>                                     Disply1321
     &                     + <rf:MAX-FROST/LEN> * <rf:LINE-UP-LEN>              Disply1322
        <ac:MELT-T>        = <rf:MELT-T>                                        Disply1323
        <ac:DEF-DT>        = <rf:DEF-DT>                                        Disply1324
        <ac:DEF-TERMINATE> = <rf:DEF-TERMINATE>                                 Disply1325
        <ac:DEF-DURATION>  = <rf:DEF-DURATION>                                  Disply1326
        <ac:NUM-DEF/DAY>   = <rf:NUM-DEF/DAY>                                   Disply1327
        <ac:ELEC-METER>    = <rf:ELEC-METER>                                    Disply1328
        <ac:TEMP-CTRL>     = <rf:TEMP-CTRL>                                     Disply1329
        <ac;TloadAA>       = <#rf;Tavg>                                         Disply1330
        <ac;WloadAA>       = <#rf;Wavg>                                         Disply1331
        CALL AirCoil_DX(Mode, Kac)                                              Disply1332
c                                                                               Disply1333
c              Component pointers, schedules and curves                         Disply1334
        <rf:/SuctionGroup> = Jcomponent(25, <rf:/SuctionGroup>)                 Disply1335
        <rf:/RefgSystem/>  = Jcomponent(29, <rf:/RefgSystem/>)                  Disply1336
        <rf:ELEC-METER>    = Jcomponent(13, <rf:ELEC-METER>)                    Disply1337
        <rf:AUX-METER>     = Jcomponent(13, <rf:AUX-METER>)                     Disply1338
        <rf:COST-DATA>     = Jcomponent(18, <rf:COST-DATA>)                     Disply1339
        <rf:COND-SCH>      = Jsched(<rf:COND-SCH>)                              Disply1340
        <rf:COND-SCH2>     = Jsched(<rf:COND-SCH2>)                             Disply1341
        <rf:AIR-INF-SCH>   = Jsched(<rf:AIR-INF-SCH>)                           Disply1342
        <rf:AIR-INF-SCH2>  = Jsched(<rf:AIR-INF-SCH2>)                          Disply1343
        <rf:LIGHTING-SCH>  = Jsched(<rf:LIGHTING-SCH>)                          Disply1344
        <rf:HEATER-SCH>    = Jsched(<rf:HEATER-SCH>)                            Disply1345
        <rf:SENSIBLE-SCH>  = Jsched(<rf:SENSIBLE-SCH>)                          Disply1346
        <rf:LATENT-SCH>    = Jsched(<rf:LATENT-SCH>)                            Disply1347
        <rf:TEMP-SETPT-SC> = Jsched(<rf:TEMP-SETPT-SC>)                         Disply1348
        <rf:AUX-SCH>       = Jsched(<rf:AUX-SCH>)                               Disply1349
c                                                                               Disply1350
c              Second level of attachments                                      Disply1351
      CASE (202)                                                                Disply1352
        CALL AirCoil_DX(Mode, Kac)                                              Disply1353
c                                                                               Disply1354
c              Create nodes                                                     Disply1355
      CASE (203)                                                                Disply1356
c              Create the zonal attachments - pointer to zone                   Disply1357
        <rf:ZONE-NAME> = Jzone(<rf:ZONE-NAME>)                                  Disply1358
        ZP1            = <rf:ZONE-NAME>                                         Disply1359
        ZP2            = <ZP2>                                                  Disply1360
c              Total number of this fixture in the building                     Disply1361
        TotalFixtures  = <rf:MULTIPLIER> * <MULTIPLIER>                         Disply1362
c              Zone sensible, latent, radiative heat gains                      Disply1363
        <rf;QfixedNode> = NewNode(1, Jrf,0,Jrf,ZP1,                             Disply1364
     &                                          31,1,0, <rf:MULTIPLIER>)        Disply1365
        <rf;QsensNode>  = NewNode(1, Jrf,0,Jrf,ZP1,                             Disply1366
     &                                          31,2,0, <rf:MULTIPLIER>)        Disply1367
        <rf;QlatNode>   = NewNode(1, Jrf,0,Jrf,ZP1,                             Disply1368
     &                                          32,2,0, <rf:MULTIPLIER>)        Disply1369
        <rf;QradNode>   = NewNode(1, Jrf,0,Jrf,ZP1,                             Disply1370
     &                                          33,2,0, <rf:MULTIPLIER>)        Disply1371
c              Defrost nodes                                                    Disply1372
        IF (<rf:DEF-TYPE> .NE. 0)  THEN                                         Disply1373
          <rf;QsensDefNode> = NewNode(1, Jrf,0,Jrf,ZP1,                         Disply1374
     &                                          31,2,0, <rf:MULTIPLIER>)        Disply1375
          <rf;QlatDefNode>  = NewNode(1, Jrf,0,Jrf,ZP1,                         Disply1376
     &                                          32,2,0, <rf:MULTIPLIER>)        Disply1377
        ENDIF                                                                   Disply1378
c              Repeat for second zone, if specified                             Disply1379
        IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                       Disply1380
          <rf:ZONE-NAME2> = Jzone(<rf:ZONE-NAME2>)                              Disply1381
          ZP1             = <rf:ZONE-NAME2>                                     Disply1382
          ZP2             = <ZP2>                                               Disply1383
          Z2Mult          = TotalFixtures / <MULTIPLIER>                        Disply1384
          <rf;QfixedNode2> = NewNode(1, Jrf,0,Jrf,ZP1, 31,1,0, Z2Mult)          Disply1385
          <rf;QsensNode2>  = NewNode(1, Jrf,0,Jrf,ZP1, 31,2,0, Z2Mult)          Disply1386
          <rf;QlatNode2>   = NewNode(1, Jrf,0,Jrf,ZP1, 32,2,0, Z2Mult)          Disply1387
          <rf;QradNode2>   = NewNode(1, Jrf,0,Jrf,ZP1, 33,2,0, Z2Mult)          Disply1388
          IF (<rf:DEF-TYPE> .NE. 0)  THEN                                       Disply1389
            <rf;QsensDefNode2> = NewNode(1, Jrf,0,Jrf,ZP1,                      Disply1390
     &                                                 31,2,0, Z2Mult)          Disply1391
            <rf;QlatDefNode2>  = NewNode(1, Jrf,0,Jrf,ZP1,                      Disply1392
     &                                                 32,2,0, Z2Mult)          Disply1393
          ENDIF                                                                 Disply1394
        ENDIF                                                                   Disply1395
c              Coil air inlet (supply to fixture) and outlet (return)           Disply1396
        <rf;AirInletNode>  = NewNode(1, 0,Jrf,Jrf,Kac, 41,1,9, 1.)              Disply1397
        <rf;AirOutletNode> = NewNode(1, 0,Jrf,Jrf,Kac, 42,2,9, 1.)              Disply1398
c              Attach to the electric circuits                                  Disply1399
        Jme = <rf:ELEC-METER>                                                   Disply1400
        <rf:ELEC-METER> = NewNode(1, Jrf,0,Jrf,Jme,                             Disply1401
     &                                         11,2,9,TotalFixtures)            Disply1402
        IF (<rf:AUX-KW> .GT. 0.)  THEN                                          Disply1403
          Jme = <rf:AUX-METER>                                                  Disply1404
          <rf:AUX-METER> = NewNode(1, Jrf,0,Jrf,Jme,                            Disply1405
     &                                         11,2,9,TotalFixtures)            Disply1406
        ENDIF                                                                   Disply1407
c              coil subcomponent                                                Disply1408
        <ac;Multiplier> = TotalFixtures                                         Disply1409
        CALL AirCoil_DX(Mode, Kac)                                              Disply1410
c                                                                               Disply1411
c              Links, lists                                                     Disply1412
      CASE (205)                                                                Disply1413
c              System nodes, including coil                                     Disply1414
        CALL ListNodes(<rf;SystemNodes>, Jrf,0,0,0, 0,0)                        Disply1415
c              coil subcomponent                                                Disply1416
        CALL AirCoil_DX(Mode, Kac)                                              Disply1417
c                                                                               Disply1418
c              Histories                                                        Disply1419
      CASE (208)                                                                Disply1420
c              Histories of return air and fixture humidity                     Disply1421
        ListDamp = 0                                                            Disply1422
        CALL ListAddVars(ListDamp, Kao, 0)                                      Disply1423
        CALL ListAddVars(ListDamp, <#rf;Tfixture>, <#rf;Wfixture>)              Disply1424
        <rf;ReturnHsty> = NewHistory(0,0,Jrf, 0, ListDamp,                      Disply1425
     &                      0, 3, 1.2,                                          Disply1426
     &                      <#ao.Toutlet>, <sp:ERROR-T>, 1,                     Disply1427
     &                      <#ao.Woutlet>, <sp:ERROR-W>, 1,                     Disply1428
     &                      0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                     Disply1429
        ListDamp = 0                                                            Disply1430
        CALL ListAddVars(ListDamp, <#rf;Wfixture>, <#rf;dMIntLat''>)            Disply1431
        <rf;WfixtureHsty> = NewHistory(0,0,Jrf, 0, ListDamp,                    Disply1432
     &                        0, 1, 1.5,                                        Disply1433
     &                        <#rf;Wfixture>, <sp:ERROR-W>, 1,                  Disply1434
     &                        0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)           Disply1435
c              Defrost histories of return air and fixture humidity             Disply1436
        ListDamp = 0                                                            Disply1437
        CALL ListAddVars(ListDamp, Kao, 0)                                      Disply1438
        CALL ListAddVars(ListDamp, <#rf;Tdefrost>, <#rf;Wdefrost>)              Disply1439
        <rf;ReturnDefHsty> = NewHistory(0,0,Jrf, 0, ListDamp,                   Disply1440
     &                           0, 5, 1.2,                                     Disply1441
     &                           <#ao.Toutlet>, <sp:ERROR-T>, 1,                Disply1442
     &                           <#ao.Woutlet>, <sp:ERROR-W>, 1,                Disply1443
     &                           0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                Disply1444
        ListDamp = 0                                                            Disply1445
        CALL ListAddVars(ListDamp, <#rf;Wdefrost>, <#rf;dMIntLat'>)             Disply1446
        <rf;WdefrostHsty> = NewHistory(0,0,Jrf, 0, ListDamp,                    Disply1447
     &                        0, 1, 1.5,                                        Disply1448
     &                        <#rf;Wdefrost>, <sp:ERROR-W>, 1,                  Disply1449
     &                        0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)           Disply1450
c              coil subcomponent                                                Disply1451
        CALL AirCoil_DX(Mode, Kac)                                              Disply1452
c                                                                               Disply1453
c              History lists                                                    Disply1454
      CASE (209)                                                                Disply1455
c              System, including coil                                           Disply1456
        CALL ListHstys(<rf;SystemHstys>, Jrf, 0, 0)                             Disply1457
c                                                                               Disply1458
c              Dump pointers                                                    Disply1459
      CASE (210)                                                                Disply1460
        IF (<rf;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         Disply1461
        WRITE (IOUTPT, 9202)  (<rf:NAME>,II=1,8),                               Disply1462
     &    Jrf, Kac, Kai, Kao, <rf;QsensNode>, <rf;QsensDefNode>,                Disply1463
     &    <rf;QlatNode>, <rf;QlatDefNode>, <rf;QradNode>,                       Disply1464
     &    <rf;QfixedNode>                                                       Disply1465
c                                                                               Disply1466
c                                                                               Disply1467
      END SELECT  ! Mode                                                        Disply1468
c                                                                               Disply1469
      Return                                                                    Disply1470
c                                                                               Disply1471
c              Message formats                                                  Disply1472
 9004 FORMAT(14x,'Refg-Fixture: ',8A4,' has a specified'               /        Disply1473
     &14x,'airflow of',f6.0,' CFM, which results in a temperature rise'/        Disply1474
     &14x,'of',f5.1,' Verify that the fixture is not running warmer'   /        Disply1475
     &14x,'than intended, or that the fixture loads are not excessive.')        Disply1476
 9005 FORMAT(14x,'Refg-Fixture: ',8A4,' has a specified'               /        Disply1477
     &14x,'coil capacity of',f9.0,' Btuh, which is smaller than the'   /        Disply1478
     &14x,'rated load of',f9.0,' The capacity will be increased to the'/        Disply1479
     &14x,'rated load.'                                                )        Disply1480
 9101 FORMAT(14x,'Refg-Fixture failure: ',8A4)                                  Disply1481
 9102 FORMAT(14x,'The defrost mode in Refg-Fixture: ',8A4              /        Disply1482
     &       14x,'is heating the fixture to a temperature of:',F5.1,'F'/        Disply1483
     &       14x,'First occurrence: ',I2,'/',I2,'/',I2                 )        Disply1484
 9201 FORMAT(/' REFG-FIXTUREs                          Jrf       Kac',          Disply1485
     &'       Kai       Kao     Qsens  QsensDef      Qlat   QlatDef',           Disply1486
     &'      Qrad      Qfix'                                           /        Disply1487
     &1x,32('-'),10('  --------'))                                              Disply1488
 9202 FORMAT(1x,8A4,10I10)                                                      Disply1489
c                                                                               Disply1490
c                                                                               Disply1491
      CONTAINS                                                                  Disply1492
c ============== DesignBalance ================================================ Disply1493
      Subroutine DesignBalance                                                  Disply1494
c                                                                               Disply1495
c              Calculates the balance point for the fixture/coil                Disply1496
c              properties at either the RATED or DESIGN conditions              Disply1497
c                                                                               Disply1498
c              ModeBalance = 1  Rated conditions                                Disply1499
c                            2  Design conditions                               Disply1500
c                                                                               Disply1501
c              Required supply temperature                                      Disply1502
      <ai.Treqd> = Tsupply                                                      Disply1503
c              Initialize the return temperature                                Disply1504
      IF (SupplyCFM .gt. 0.)  THEN                                              Disply1505
        <ao.Toutlet> = Tsupply + 10.                 ! first guess              Disply1506
      ELSE                                                                      Disply1507
        <ao.Toutlet> = Tsupply + <rf:SUPPLY-RET-DT>  ! required T               Disply1508
      ENDIF                                                                     Disply1509
c                                                                               Disply1510
c              Iterate to solve for the coil load, supply flow,                 Disply1511
c              and return humidity                                              Disply1512
      CALL HistoryInit(<rf;ReturnHsty>)                                         Disply1513
      DO                                                                        Disply1514
c              supply enthalpy and specific volume                              Disply1515
        Hsupply = HAir(Tsupply, <Xai.Winlet>)                                   Disply1516
        Vsupply = V(Tsupply, <Xai.Winlet>, BLDGP)                               Disply1517
c                                                                               Disply1518
c              Average fixture temperature and humidity ratio                   Disply1519
        IF (<rf:SUPPLY-DIST> .EQ. 1)  THEN                                      Disply1520
c              supply air is fully mixed in the fixture                         Disply1521
          <rf;Tfixture> = <ao.Toutlet>                                          Disply1522
          <rf;Wfixture> = <ao.Woutlet>                                          Disply1523
        ELSE                                                                    Disply1524
c              supply air flows as a plug through the fixture                   Disply1525
          <rf;Tfixture> = (Tsupply + <ao.Toutlet>) * 0.5                        Disply1526
          <rf;Wfixture> = (<Xai.Winlet> + <ao.Woutlet>) * 0.5                   Disply1527
        ENDIF                                                                   Disply1528
c              fixture enthalpy                                                 Disply1529
        Hfixture = HAir(<rf;Tfixture>, <rf;Wfixture>)                           Disply1530
c                                                                               Disply1531
        IF (ModeBalance .eq. 1)  THEN                                           Disply1532
c              Conduction                                                       Disply1533
          Qcond1 = <rf:COND>  + <rf:COND/LEN>  * <rf:LINE-UP-LEN>               Disply1534
          Qcond2 = <rf:COND2> + <rf:COND/LEN2> * <rf:LINE-UP-LEN>               Disply1535
c              Infiltration losses                                              Disply1536
          <rf;Lbs/CFMinf> = 60. / V(<rf;Tfixture>,<rf;Wfixture>,BLDGP)          Disply1537
          <rf;DesCFMinf>  = <rf:INF-FLOW>                                       Disply1538
     &                    + <rf:INF-FLOW/LEN>*<rf:LINE-UP-LEN>                  Disply1539
        ELSE                                                                    Disply1540
          Qcond1 = <rf;SurfaceUA>  * (Tzone1-<rf;Tfixture>)                     Disply1541
          Qcond2 = <rf;SurfaceUA2> * (Tzone2-<rf;Tfixture>)                     Disply1542
        ENDIF                                                                   Disply1543
        IF (<rf;DesCFMinf> .gt. 0.)  THEN                                       Disply1544
c              infiltration flow specified                                      Disply1545
          Minf1 = <rf;DesCFMinf> * <rf;Lbs/CFMinf>  ! lbs/hr                    Disply1546
          Qinf1 = Minf1 * (Hzone1 - Hfixture)       ! heat gain                 Disply1547
        ELSE ! infiltration load specified                                      Disply1548
          Qinf1 = <rf:INF-LOAD> + <rf:INF-LOAD/LEN>*<rf:LINE-UP-LEN>            Disply1549
          Minf1 = Qinf1 / (Hzone1 - Hfixture)       ! lbs/hr                    Disply1550
        ENDIF                                                                   Disply1551
c              latent component of infiltration, lbs water                      Disply1552
        Mfix  = Minf1                                                           Disply1553
        MWfix = Minf1 * Wzone1                                                  Disply1554
c                                                                               Disply1555
c              Repeat for second zone if specified                              Disply1556
        IF (<rf:ZONE-NAME2> .GT. 0)  THEN                                       Disply1557
          IF (ModeBalance .eq. 1)                                               Disply1558
     &      <rf;DesCFMinf2> = <rf:INF-FLOW2>                                    Disply1559
     &                      + <rf:INF-FLOW/LEN2>*<rf:LINE-UP-LEN>               Disply1560
          IF (<rf;DesCFMinf2> .gt. 0.)  THEN                                    Disply1561
            Minf2 = <rf;DesCFMinf2> * <rf;Lbs/CFMinf>                           Disply1562
            Qinf2 = Minf2 * (Hzone2 - Hfixture)                                 Disply1563
          ELSE                                                                  Disply1564
            Qinf2 = <rf:INF-LOAD2> + <rf:INF-LOAD/LEN2>*<rf:LINE-UP-LEN>        Disply1565
            Minf2 = Qinf2 / (Hzone2 - Hfixture)                                 Disply1566
          ENDIF                                                                 Disply1567
          Mfix  = Mfix  + Minf2                                                 Disply1568
          MWfix = MWfix + Minf2 * Wzone2                                        Disply1569
        ELSE                                                                    Disply1570
          Minf2 = 0.                                                            Disply1571
          Qinf2 = 0.                                                            Disply1572
        ENDIF                                                                   Disply1573
c                                                                               Disply1574
c              Product load, latent                                             Disply1575
        MWfix = MWfix + <rf;ProductLat>                                         Disply1576
c                                                                               Disply1577
c              Air coil load                                                    Disply1578
        Qreqd = Qcond1          + Qcond2             ! conduction               Disply1579
     &        + Qinf1           + Qinf2              ! infiltration             Disply1580
     &        + <rf:SURF-RAD>   + <rf:SURF-RAD2>     ! surface rad              Disply1581
     &        + <rf:LIGHTS-RAD> + <rf:LIGHTS-RAD2>   ! lighting rad             Disply1582
     &        + <rf;LightToFixtur>                   ! internal lites           Disply1583
     &        + <rf;FanToFixture>                    ! supply fan               Disply1584
     &        + <rf;HtrToFixture>                    ! anti-sweat htr           Disply1585
     &        + <rf;ProductSen>                      ! product heat gain        Disply1586
c                                                                               Disply1587
c              Check for illegal design load                                    Disply1588
        IF (Qreqd .eq. 0.)  THEN                                                Disply1589
          CALL MSGSIM(-1,II,II,II,II)                                           Disply1590
          WRITE (IOUTPT, 9001) (<rf:NAME>,II=1,8)                               Disply1591
          CALL MessageBox( NULL,                                                Disply1592
     &     'Fixture has zero design load'//char(10)//char(13)//                 Disply1593
     &     ' - cannot design coil'//char(0),                                    Disply1594
     &     'REFG-FIXTURE Errors'//char(0),                                      Disply1595
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                Disply1596
          IwinReturn = 1                                                        Disply1597
          Exit                                                                  Disply1598
        ELSEIF (Qreqd .lt. 0.)  THEN                                            Disply1599
          CALL MSGSIM(-1,II,II,II,II)                                           Disply1600
          WRITE (IOUTPT, 9002) (<rf:NAME>,II=1,8), Qreqd, Qcond1+Qcond2,        Disply1601
     &      Qinf1+Qinf2, <rf;LightToFixtur>, <rf;FanToFixture>,                 Disply1602
     &      <rf;HtrToFixture>, <rf;ProductSen>                                  Disply1603
          CALL MessageBox( NULL,                                                Disply1604
     &     'Fixture has negative design load'//char(10)//char(13)//             Disply1605
     &     ' - cannot design coil'//char(0),                                    Disply1606
     &     'REFG-FIXTURE Errors'//char(0),                                      Disply1607
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                Disply1608
          IwinReturn = 1                                                        Disply1609
          Exit                                                                  Disply1610
        ENDIF                                                                   Disply1611
c              if coil capacity user-specified                                  Disply1612
        IF (ModeBalance .eq. 1)  THEN                                           Disply1613
          IF (<ac:CAP> .gt. 0.)  THEN                                           Disply1614
            <ao.Qoutlet> = Max(Qreqd, <ac:CAP>)                                 Disply1615
          ELSE                                                                  Disply1616
            <ao.Qoutlet> = Qreqd*<rf:SIZING-RATIO>                              Disply1617
          ENDIF                                                                 Disply1618
        ELSE                                                                    Disply1619
          <ao.Qoutlet> = Qreqd                                                  Disply1620
        ENDIF                                                                   Disply1621
c                                                                               Disply1622
c              Coil airflow rate                                                Disply1623
        IF (SupplyCFM .gt. 0.)  THEN                                            Disply1624
          <ao.Moutlet> = SupplyCFM * 60. / Vsupply                              Disply1625
c              return enthalpy and temperature                                  Disply1626
          Hreturn      = Hsupply + <ao.Qoutlet>/<ao.Moutlet>                    Disply1627
          <ao.Toutlet> = DBair(Hreturn, <ao.Woutlet>)                           Disply1628
        ELSE                           ! base on load and dH                    Disply1629
          Hreturn      = HAir(<ao.Toutlet>, <ao.Woutlet>)                       Disply1630
          <ao.Moutlet> = <ao.Qoutlet> / (Hreturn - Hsupply)                     Disply1631
        ENDIF                                                                   Disply1632
c              Coil return humidity                                             Disply1633
        Mfix  = Mfix  + <ao.Moutlet>                                            Disply1634
        MWfix = MWfix + <ao.Moutlet> * <Xai.Winlet>                             Disply1635
        <ao.Woutlet> = MWfix / Mfix                                             Disply1636
        CALL CnvgCheck(2, <rf;ReturnHsty>)                                      Disply1637
c              Get the coil supply conditions                                   Disply1638
        CALL AirCoil_DX(Mode, Kac)                                              Disply1639
        IF (iWinReturn .eq. 1)  Exit                                            Disply1640
        IF (.NOT. IterReqdHsty(<rf;ReturnHsty>)                                 Disply1641
     &                                .or.  iWinReturn .eq. 1)  Exit            Disply1642
      ENDDO  ! iteration on humidity                                            Disply1643
                                                                                Disply1644
c              Message formats                                                  Disply1645
 9001 FORMAT(14x,'Refg-Fixture: ',8A4,' has no design'                 /        Disply1646
     &14x,'cooling coil load.  The fixture must have conduction,'      /        Disply1647
     &14x,'infiltration, lighting, or other loads in order to be'      /        Disply1648
     &14x,'simulated.  If conduction or infiltration is specified,'    /        Disply1649
     &14x,'check to make sure the fixture conditions are not exactly'  /        Disply1650
     &14x,'the same as the space conditions.'                          )        Disply1651
 9002 FORMAT(14x,'Refg-Fixture: ',8A4,' has a negative'                /        Disply1652
     &14x,'cooling coil load, meaning it must provide heating rather'  /        Disply1653
     &14x,'than cooling.  Check fixture temperature and humidity vs.'  /        Disply1654
     &14x,'zone temperature and humidity.'                            //        Disply1655
     &14x,'Breakdown of loads (Btuh):'                                 /        Disply1656
     &14x,'    Total  Conduct    Infil   Lights     Fans    Sweat'              Disply1657
     &                                                   '  Product'   /        Disply1658
     &14x,7(' --------')                                               /        Disply1659
     &14x,7F9.0                                                        )        Disply1660
c                                                                               Disply1661
      End Subroutine DesignBalance                                              Disply1662
c                                                                               Disply1663
      END                                                                       Disply1664
C ##############################################################################Generl   2
C ##############################################################################Generl   3
C ##############################################################################Generl   4
C ##############################################################################Generl   5
C ##########                                                          ##########Generl   6
C ##########                     GENERAL ROUTINES                     ##########Generl   7
C ##########                                                          ##########Generl   8
C ##############################################################################Generl   9
C ##############################################################################Generl  10
C ##############################################################################Generl  11
C ##############################################################################Generl  12
      FUNCTION IA_RefgHRef(Jrs)                                                 IARfgHR  2
c                                                                               IARfgHR  3
c              Returns the pointer in AA to the enthaply of the liquid          IARfgHR  4
c              refrigerant leaving a refrigeration plant.  This enthalpy        IARfgHR  5
c              is the reference enthalpy for most of the refrigeration          IARfgHR  6
c              load calculations                                                IARfgHR  7
c                                                                               IARfgHR  8
c              Jrc  Pointer to the refrigeration system                         IARfgHR  9
c                                                                               IARfgHR 10
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               IARfgHR 15
      IF (<rs;OutletNode> .EQ. 0)  THEN                                         IARfgHR 16
        CALL MSGSIM(-1,II,II,II,II)                                             IARfgHR 17
        WRITE (IOUTPT, 9001)                                                    IARfgHR 18
        IwinReturn = 1                                                          IARfgHR 19
      ENDIF                                                                     IARfgHR 20
c                                                                               IARfgHR 21
      Kro         = <rs;OutletNode>                                             IARfgHR 22
      IA_RefgHRef = <#ro.Houtlet>                                               IARfgHR 23
c                                                                               IARfgHR 24
      RETURN                                                                    IARfgHR 25
c                                                                               IARfgHR 26
 9001 FORMAT(                                                                   IARfgHR 27
     &14x,'PROGRAMMER ERROR: IA_RefgHRef(Jrs) invoked prior to'        /        IARfgHR 28
     &14x,'establishing refg-system outlet node!'                      )        IARfgHR 29
      END                                                                       IARfgHR 30
C ##############################################################################RfgPro   2
C ##########                                                          ##########RfgPro   3
C ##########                  REFRIGERANT PROPERTIES                  ##########RfgPro   4
C ##########                                                          ##########RfgPro   5
C ##############################################################################RfgPro   6
c                                                                               RfgPro   7
c              Routines that calculate the properties of refrigerants           RfgPro   8
c                                                                               RfgPro   9
c              RefgCp_Liquid_fP   Specific heat        f(Pres)                  RfgPro  10
c              RefgCp_Liquid_fT   Specific heat        f(Temp)                  RfgPro  11
c              RefgCp_Vapor_fP    Specific heat        f(Pres)                  RfgPro  12
c              RefgCp_Vapor_fT    Specific heat        f(Temp)                  RfgPro  13
c              RefgD_fP           Liquid density       f(Pres)                  RfgPro  14
c              RefgH_Liquid_fP    Enthalpy             f(Pres)                  RfgPro  15
c              RefgH_Liquid_fT    Enthalpy             f(Temp)                  RfgPro  16
c              RefgH_Liquid_fSP   Enthalpy             f(Subcool, Pres)         RfgPro  17
c              RefgH_Liquid_fTP   Enthalpy             f(Temp, Pres)            RfgPro  18
c              RefgH_Liquid_fTS   Enthalpy             f(Temp, Subcool)         RfgPro  19
c              RefgH_Vapor_fP     Enthalpy             f(Pres)                  RfgPro  20
c              RefgH_Vapor_fSP    Enthalpy             f(Super, Pres)           RfgPro  21
c              RefgH_Vapor_fTS    Enthalpy             f(Temp, Super)           RfgPro  22
c              RefgH_Vapor_fTP    Enthalpy             f(Temp, Pres)            RfgPro  23
c              RefgP_fT           Saturated pressure   f(Temp)                  RfgPro  24
c              RefgSuper_fTH      Superheat            f(SatTemp, Enthalpy)     RfgPro  25
c              RefgT_fP           Saturated temp       f(Pres)                  RfgPro  26
c              RefgT_fPH          Temperature          f(Pres, Enthalpy)        RfgPro  27
c              RefgV_fPH          Vapor volume         f(Pres, Enthalpy)        RfgPro  28
c                                                                               RfgPro  29
      FUNCTION RefgCp_Liquid_fP(Jre, Pres)                                      RfgCpLP  2
c                                                                               RfgCpLP  3
c              Calculates the specific heat of of a refrigerant liquid          RfgCpLP  4
c              corresponding to a saturated pressure                            RfgCpLP  5
c                                                                               RfgCpLP  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgCpLP  8
c              Interpolation factor based on pressure                           RfgCpLP  9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgCpLP 10
c              saturated specific heat                                          RfgCpLP 11
      RefgCp_Liquid_fP = RefgTableValue(Jre, 7, X)                              RfgCpLP 12
c                                                                               RfgCpLP 13
      RETURN                                                                    RfgCpLP 14
      END                                                                       RfgCpLP 15
      FUNCTION RefgCp_Liquid_fT(Jre, Temp)                                      RfgCpLT  2
c                                                                               RfgCpLT  3
c              Calculates the specific heat of of a refrigerant liquid          RfgCpLT  4
c              corresponding to a saturated temperature                         RfgCpLT  5
c                                                                               RfgCpLT  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgCpLT  8
c              Interpolation factor based on pressure                           RfgCpLT  9
      X = RefgTablePosition(Jre, 1, Temp)                                       RfgCpLT 10
c              saturated specific heat                                          RfgCpLT 11
      RefgCp_Liquid_fT = RefgTableValue(Jre, 7, X)                              RfgCpLT 12
c                                                                               RfgCpLT 13
      RETURN                                                                    RfgCpLT 14
      END                                                                       RfgCpLT 15
      FUNCTION RefgCp_Vapor_fP(Jre, Pres)                                       RfgCpVP  2
c                                                                               RfgCpVP  3
c              Calculates the specific heat of of a refrigerant vapor           RfgCpVP  4
c              corresponding to a saturated pressure                            RfgCpVP  5
c                                                                               RfgCpVP  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgCpVP  8
c              Interpolation factor based on pressure                           RfgCpVP  9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgCpVP 10
c              saturated specific heat                                          RfgCpVP 11
      RefgCp_Vapor_fP = RefgTableValue(Jre, 8, X)                               RfgCpVP 12
c                                                                               RfgCpVP 13
      RETURN                                                                    RfgCpVP 14
      END                                                                       RfgCpVP 15
      FUNCTION RefgCp_Vapor_fT(Jre, Temp)                                       RfgCpVT  2
c                                                                               RfgCpVT  3
c              Calculates the specific heat of of a refrigerant vapor           RfgCpVT  4
c              corresponding to a saturated temperature                         RfgCpVT  5
c                                                                               RfgCpVT  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgCpVT  8
c              Interpolation factor based on temperature                        RfgCpVT  9
      X = RefgTablePosition(Jre, 1, Temp)                                       RfgCpVT 10
c              saturated specific heat                                          RfgCpVT 11
      RefgCp_Vapor_fT = RefgTableValue(Jre, 8, X)                               RfgCpVT 12
c                                                                               RfgCpVT 13
      RETURN                                                                    RfgCpVT 14
      END                                                                       RfgCpVT 15
      FUNCTION RefgD_fP(Jre, Pres)                                              RfgDP    2
c                                                                               RfgDP    3
c              Calculates the density of a saturated refrigerant liquid         RfgDP    4
c              for a given saturated pressure                                   RfgDP    5
c                                                                               RfgDP    6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgDP    8
c              Interpolation factor based on pressure                           RfgDP    9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgDP   10
c              saturated density                                                RfgDP   11
      RefgD_fP = RefgTableValue(Jre, 3, X)                                      RfgDP   12
c                                                                               RfgDP   13
      RETURN                                                                    RfgDP   14
      END                                                                       RfgDP   15
      FUNCTION RefgH_fTP(Jre, Temp, Pres, Mode)                                 RfgHfTP  2
c                                                                               RfgHfTP  3
c              Calculates the enthalpy corresponding to a temperature           RfgHfTP  4
c              and pressure                                                     RfgHfTP  5
c                                                                               RfgHfTP  6
c              Mode 1  Approaching this condition from a liquid                 RfgHfTP  7
c                   2  Approaching this condition from a gas                    RfgHfTP  8
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHfTP 10
c              Interpolation factor based on pressure                           RfgHfTP 11
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHfTP 12
                                                                                RfgHfTP 13
c              Saturated temperature and pressure                               RfgHfTP 14
      Tsatur = RefgTableValue(Jre, 1, X)                                        RfgHfTP 15
c                                                                               RfgHfTP 16
      IF (Temp .LT. Tsatur)  THEN                                               RfgHfTP 17
c              subcooled liquid                                                 RfgHfTP 18
        Hsatur    = RefgTableValue(Jre, 5, X)                                   RfgHfTP 19
        Cp        = RefgTableValue(Jre, 7, X)                                   RfgHfTP 20
        dTsubcool = Tsatur - Temp                                               RfgHfTP 21
        RefgH_fTP = Hsatur - Cp*dTsubcool                                       RfgHfTP 22
      ELSEIF (Temp .GT. Tsatur)  THEN                                           RfgHfTP 23
c              superheated gas                                                  RfgHfTP 24
        Hsatur    = RefgTableValue(Jre, 6, X)                                   RfgHfTP 25
        Cp        = RefgTableValue(Jre, 8, X)                                   RfgHfTP 26
        dTsuper   = Temp - Tsatur                                               RfgHfTP 27
        RefgH_fTP = Hsatur + Cp*dTsuper                                         RfgHfTP 28
      ELSE                                                                      RfgHfTP 29
c              at saturation - see where started from                           RfgHfTP 30
        IF (Mode .EQ. 1)  THEN                                                  RfgHfTP 31
c              started as subcooled liquid                                      RfgHfTP 32
          RefgH_fTP = RefgTableValue(Jre, 5, X)                                 RfgHfTP 33
        ELSE                                                                    RfgHfTP 34
          RefgH_fTP = RefgTableValue(Jre, 6, X)                                 RfgHfTP 35
        ENDIF                                                                   RfgHfTP 36
      ENDIF                                                                     RfgHfTP 37
c                                                                               RfgHfTP 38
      RETURN                                                                    RfgHfTP 39
      END                                                                       RfgHfTP 40
      FUNCTION RefgH_Liquid_fP(Jre, Pres)                                       RfgHLP   2
c                                                                               RfgHLP   3
c              Calculates the enthalpy of a saturated liquid refrigerant        RfgHLP   4
c              given the pressure                                               RfgHLP   5
c                                                                               RfgHLP   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHLP   8
c              Interpolation factor based on pressure                           RfgHLP   9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHLP  10
c              saturated enthalpy at this pressure                              RfgHLP  11
      RefgH_Liquid_fP = RefgTableValue(Jre, 5, X)                               RfgHLP  12
c                                                                               RfgHLP  13
      RETURN                                                                    RfgHLP  14
      END                                                                       RfgHLP  15
      FUNCTION RefgH_Liquid_fT(Jre, Temp)                                       RfgHLT   2
c                                                                               RfgHLT   3
c              Calculates the enthalpy of a saturated liquid refrigerant        RfgHLT   4
c              given the temperature                                            RfgHLT   5
c                                                                               RfgHLT   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHLT   8
c              Interpolation factor based on temperature                        RfgHLT   9
      X = RefgTablePosition(Jre, 1, Temp)                                       RfgHLT  10
c              saturated enthalpy at this pressure                              RfgHLT  11
      RefgH_Liquid_fT = RefgTableValue(Jre, 5, X)                               RfgHLT  12
c                                                                               RfgHLT  13
      RETURN                                                                    RfgHLT  14
      END                                                                       RfgHLT  15
      FUNCTION RefgH_Liquid_fSP(Jre, dTsubcool, Pres)                           RfgHLSP  2
c                                                                               RfgHLSP  3
c              Calculates the enthalpy of a liquid refrigerant given the        RfgHLSP  4
c              subcooling and pressure                                          RfgHLSP  5
c                                                                               RfgHLSP  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHLSP  8
c              Interpolation factor based on pressure                           RfgHLSP  9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHLSP 10
c              saturated enthalpy and specific heat at this pressure            RfgHLSP 11
      Hsatur = RefgTableValue(Jre, 5, X)                                        RfgHLSP 12
      Cp     = RefgTableValue(Jre, 7, X)                                        RfgHLSP 13
c                                                                               RfgHLSP 14
c              corrected enthalpy                                               RfgHLSP 15
      RefgH_Liquid_fSP = Hsatur - Cp*dTsubcool                                  RfgHLSP 16
c                                                                               RfgHLSP 17
      RETURN                                                                    RfgHLSP 18
      END                                                                       RfgHLSP 19
      FUNCTION RefgH_Liquid_fTP(Jre, Temp, Pres)                                RfgHLTP  2
c                                                                               RfgHLTP  3
c              Calculates the enthalpy of a liquid refrigerant given the        RfgHLTP  4
c              temperature and pressure                                         RfgHLTP  5
c                                                                               RfgHLTP  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHLTP  8
c              Interpolation factor based on pressure                           RfgHLTP  9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHLTP 10
c              saturated temperature, enthalpy, and specific heat               RfgHLTP 11
c              at this pressure                                                 RfgHLTP 12
      Tsatur = RefgTableValue(Jre, 1, X)                                        RfgHLTP 13
      Hsatur = RefgTableValue(Jre, 5, X)                                        RfgHLTP 14
      Cp     = RefgTableValue(Jre, 7, X)                                        RfgHLTP 15
c                                                                               RfgHLTP 16
c              degrees of subcooling                                            RfgHLTP 17
      dTsubcool = MAX(0., Tsatur - Temp)                                        RfgHLTP 18
c              corrected enthalpy                                               RfgHLTP 19
      RefgH_Liquid_fTP = Hsatur - Cp*dTsubcool                                  RfgHLTP 20
c                                                                               RfgHLTP 21
      RETURN                                                                    RfgHLTP 22
      END                                                                       RfgHLTP 23
      FUNCTION RefgH_Liquid_fTS(Jre, Temp, dTsubcool)                           RfgHLTS  2
c                                                                               RfgHLTS  3
c              Calculates the enthalpy of a liquid refrigerant given the        RfgHLTS  4
c              saturated temperature and degrees of subcooling                  RfgHLTS  5
c                                                                               RfgHLTS  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHLTS  8
c              Interpolation factor based on temperature                        RfgHLTS  9
      X = RefgTablePosition(Jre, 1, Temp)                                       RfgHLTS 10
c              saturated enthalpy, and specific heat                            RfgHLTS 11
c              at this temperature                                              RfgHLTS 12
      Hsatur = RefgTableValue(Jre, 5, X)                                        RfgHLTS 13
      Cp     = RefgTableValue(Jre, 7, X)                                        RfgHLTS 14
c                                                                               RfgHLTS 15
c              corrected enthalpy                                               RfgHLTS 16
      RefgH_Liquid_fTS = Hsatur - Cp*dTsubcool                                  RfgHLTS 17
c                                                                               RfgHLTS 18
      RETURN                                                                    RfgHLTS 19
      END                                                                       RfgHLTS 20
      FUNCTION RefgH_Vapor_fP(Jre, Pres)                                        RfgHVP   2
c                                                                               RfgHVP   3
c              Calculates the enthalpy of a saturated vapor refrigerant         RfgHVP   4
c              given the pressure                                               RfgHVP   5
c                                                                               RfgHVP   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHVP   8
c              Interpolation factor based on pressure                           RfgHVP   9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHVP  10
c              saturated enthalpy at this pressure                              RfgHVP  11
      RefgH_Vapor_fP = RefgTableValue(Jre, 6, X)                                RfgHVP  12
c                                                                               RfgHVP  13
      RETURN                                                                    RfgHVP  14
      END                                                                       RfgHVP  15
      FUNCTION RefgH_Vapor_fSP(Jre, Tsuper, Pres)                               RfgHVSP  2
c                                                                               RfgHVSP  3
c              Calculates the enthalpy of a refrigerant vapor given the         RfgHVSP  4
c              superheat and pressure                                           RfgHVSP  5
c                                                                               RfgHVSP  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHVSP  8
c              Interpolation factor based on pressure                           RfgHVSP  9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHVSP 10
c                                                                               RfgHVSP 11
c              saturated enthalpy and specific heat at this pressure            RfgHVSP 12
      Hsatur = RefgTableValue(Jre, 6, X)                                        RfgHVSP 13
      Cp     = RefgTableValue(Jre, 8, X)                                        RfgHVSP 14
c                                                                               RfgHVSP 15
c              corrected enthalpy                                               RfgHVSP 16
      RefgH_Vapor_fSP = Hsatur + Cp*Tsuper                                      RfgHVSP 17
c                                                                               RfgHVSP 18
      RETURN                                                                    RfgHVSP 19
      END                                                                       RfgHVSP 20
      FUNCTION RefgH_Vapor_fT(Jre, Temp)                                        RfgHVT   2
c                                                                               RfgHVT   3
c              Calculates the enthalpy of a saturated vapor refrigerant         RfgHVT   4
c              given the temperature                                            RfgHVT   5
c                                                                               RfgHVT   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHVT   8
c              Interpolation factor based on temperature                        RfgHVT   9
      X = RefgTablePosition(Jre, 1, Temp)                                       RfgHVT  10
c              saturated enthalpy at this temperature                           RfgHVT  11
      RefgH_Vapor_fT = RefgTableValue(Jre, 6, X)                                RfgHVT  12
c                                                                               RfgHVT  13
      RETURN                                                                    RfgHVT  14
      END                                                                       RfgHVT  15
      FUNCTION RefgH_Vapor_fTP(Jre, Temp, Pres)                                 RfgHVTP  2
c                                                                               RfgHVTP  3
c              Calculates the enthalpy of a refrigerant vapor given the         RfgHVTP  4
c              temperature and pressure                                         RfgHVTP  5
c                                                                               RfgHVTP  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHVTP  8
c              Interpolation factor based on pressure                           RfgHVTP  9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgHVTP 10
c                                                                               RfgHVTP 11
c              Saturated temperature, enthalpy, and specific heat               RfgHVTP 12
c              at this pressure                                                 RfgHVTP 13
      Tsatur = RefgTableValue(Jre, 1, X)                                        RfgHVTP 14
      Hsatur = RefgTableValue(Jre, 6, X)                                        RfgHVTP 15
      Cp     = RefgTableValue(Jre, 8, X)                                        RfgHVTP 16
c                                                                               RfgHVTP 17
c              degrees of superheat                                             RfgHVTP 18
      dTsuper = MAX(0., Temp - Tsatur)                                          RfgHVTP 19
c              corrected enthalpy                                               RfgHVTP 20
      RefgH_Vapor_fTP = Hsatur + Cp*dTsuper                                     RfgHVTP 21
c                                                                               RfgHVTP 22
      RETURN                                                                    RfgHVTP 23
      END                                                                       RfgHVTP 24
      FUNCTION RefgH_Vapor_fTS(Jre, Tsatur, Tsuper)                             RfgHVTS  2
c                                                                               RfgHVTS  3
c              Calculates the enthalpy of a refrigerant vapor given the         RfgHVTS  4
c              saturated temperature and superheat                              RfgHVTS  5
c                                                                               RfgHVTS  6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgHVTS  8
c              Interpolation factor based on saturated temperature              RfgHVTS  9
      X = RefgTablePosition(Jre, 1, Tsatur)                                     RfgHVTS 10
c                                                                               RfgHVTS 11
c              saturated enthalpy and specific heat                             RfgHVTS 12
      Hsatur = RefgTableValue(Jre, 6, X)                                        RfgHVTS 13
      Cp     = RefgTableValue(Jre, 8, X)                                        RfgHVTS 14
c                                                                               RfgHVTS 15
c              corrected enthalpy                                               RfgHVTS 16
      RefgH_Vapor_fTS = Hsatur + Cp*Tsuper                                      RfgHVTS 17
c                                                                               RfgHVTS 18
      RETURN                                                                    RfgHVTS 19
      END                                                                       RfgHVTS 20
      FUNCTION RefgP_fT(Jre, Temp)                                              RfgPT    2
c                                                                               RfgPT    3
c              Calculates the pressure corresponding to a saturated             RfgPT    4
c              temperature                                                      RfgPT    5
c                                                                               RfgPT    6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgPT    8
c              Interpolation factor based on temperature                        RfgPT    9
      X = RefgTablePosition(Jre, 1, Temp)                                       RfgPT   10
c                                                                               RfgPT   11
c              Saturated pressure                                               RfgPT   12
      RefgP_fT = RefgTableValue(Jre, 2, X)                                      RfgPT   13
c                                                                               RfgPT   14
      RETURN                                                                    RfgPT   15
      END                                                                       RfgPT   16
      FUNCTION RefgSuper_fPH(Jre, Psatur, Enthalpy)                             RfgSPH   2
c                                                                               RfgSPH   3
c              Calculates the superheat of a refrigerant vapor given the        RfgSPH   4
c              saturated pressure and enthalpy                                  RfgSPH   5
c                                                                               RfgSPH   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgSPH   8
c              Interpolation factor based on saturated pressure                 RfgSPH   9
      X = RefgTablePosition(Jre, 2, Psatur)                                     RfgSPH  10
c                                                                               RfgSPH  11
c              Saturated enthalpy and specific heat                             RfgSPH  12
      Hsatur = RefgTableValue(Jre, 6, X)                                        RfgSPH  13
      Cp     = RefgTableValue(Jre, 8, X)                                        RfgSPH  14
c                                                                               RfgSPH  15
      RefgSuper_fPH = (Enthalpy-Hsatur) / Cp                                    RfgSPH  16
c                                                                               RfgSPH  17
      RETURN                                                                    RfgSPH  18
      END                                                                       RfgSPH  19
      FUNCTION RefgSuper_fTH(Jre, Tsatur, Enthalpy)                             RfgSTH   2
c                                                                               RfgSTH   3
c              Calculates the superheat of a refrigerant vapor given the        RfgSTH   4
c              saturated temperature and enthalpy                               RfgSTH   5
c                                                                               RfgSTH   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgSTH   8
c              Interpolation factor based on saturated temperature              RfgSTH   9
      X = RefgTablePosition(Jre, 1, Tsatur)                                     RfgSTH  10
c                                                                               RfgSTH  11
c              Saturated enthalpy and specific heat                             RfgSTH  12
      Hsatur = RefgTableValue(Jre, 6, X)                                        RfgSTH  13
      Cp     = RefgTableValue(Jre, 8, X)                                        RfgSTH  14
c                                                                               RfgSTH  15
      RefgSuper_fTH = (Enthalpy-Hsatur) / Cp                                    RfgSTH  16
c                                                                               RfgSTH  17
      RETURN                                                                    RfgSTH  18
      END                                                                       RfgSTH  19
      FUNCTION RefgT_Liquid_fH(Jre, Enthalpy)                                   RfgTLH   2
c                                                                               RfgTLH   3
c              Calculates the saturated temperature corresponding to an         RfgTLH   4
c              enthalpy                                                         RfgTLH   5
c                                                                               RfgTLH   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgTLH   8
c              Interpolation factor based on enthalpy                           RfgTLH   9
      X = RefgTablePosition(Jre, 5, Enthalpy)                                   RfgTLH  10
c                                                                               RfgTLH  11
c              Saturated temperature                                            RfgTLH  12
      RefgT_Liquid_fH = RefgTableValue(Jre, 1, X)                               RfgTLH  13
c                                                                               RfgTLH  14
      RETURN                                                                    RfgTLH  15
      END                                                                       RfgTLH  16
      FUNCTION RefgT_fP(Jre, Pres)                                              RfgTP    2
c                                                                               RfgTP    3
c              Calculates the saturated temperature corresponding to a          RfgTP    4
c              pressure                                                         RfgTP    5
c                                                                               RfgTP    6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgTP    8
c              Interpolation factor based on pressure                           RfgTP    9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgTP   10
c                                                                               RfgTP   11
c              Saturated pressure                                               RfgTP   12
      RefgT_fP = RefgTableValue(Jre, 1, X)                                      RfgTP   13
c                                                                               RfgTP   14
      RETURN                                                                    RfgTP   15
      END                                                                       RfgTP   16
      FUNCTION RefgT_fPH(Jre, Pres, Enthalpy)                                   RfgTPH   2
c                                                                               RfgTPH   3
c              Calculates the temperature corresponding to a pressure           RfgTPH   4
c              and enthalpy                                                     RfgTPH   5
c                                                                               RfgTPH   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgTPH   8
c              Interpolation factor based on pressure                           RfgTPH   9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgTPH  10
c                                                                               RfgTPH  11
c              Based on pressure and enthalpy, determine whether the            RfgTPH  12
c              refrigerant is liquid, vapor, or a mixture                       RfgTPH  13
c              Saturated temperature                                            RfgTPH  14
      Tsatur = RefgTableValue(Jre, 1, X)                                        RfgTPH  15
c              Enthalpy of saturated vapor                                      RfgTPH  16
      Hvapor = RefgTableValue(Jre, 6, X)                                        RfgTPH  17
c                                                                               RfgTPH  18
      IF (Enthalpy .GE. Hvapor)  THEN                                           RfgTPH  19
c              refrigerant is a superheated vapor                               RfgTPH  20
        Cp        = RefgTableValue(Jre, 8, X)                                   RfgTPH  21
        RefgT_fPH = Tsatur + (Enthalpy-Hvapor)/Cp                               RfgTPH  22
      ELSE                                                                      RfgTPH  23
        Hliquid = RefgTableValue(Jre, 5, X)                                     RfgTPH  24
        IF (Enthalpy .LE. Hliquid)  THEN                                        RfgTPH  25
c              refrigerant is a subcooled liquid                                RfgTPH  26
          Cp        = RefgTableValue(Jre, 7, X)                                 RfgTPH  27
          RefgT_fPH = Tsatur + (Enthalpy-Hliquid)/Cp                            RfgTPH  28
        ELSE                                                                    RfgTPH  29
c              refrigerant is a mixture of liquid and vapor                     RfgTPH  30
          RefgT_fPH = Tsatur                                                    RfgTPH  31
        ENDIF                                                                   RfgTPH  32
      ENDIF                                                                     RfgTPH  33
c                                                                               RfgTPH  34
      RETURN                                                                    RfgTPH  35
      END                                                                       RfgTPH  36
      SUBROUTINE RefgT_Limits(Jre, MinVal, MaxVal)                              RfgTLim  2
c                                                                               RfgTLim  3
c              Returns the limits of a refrigerant property                     RfgTLim  4
c                                                                               RfgTLim  5
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               RfgTLim  8
      REAL    MinVal, MaxVal                                                    RfgTLim  9
c                                                                               RfgTLim 10
      MinVal = RefgTableValue(Jre, 1, 1.)                                       RfgTLim 11
      MaxVal = RefgTableValue(Jre, 1, FLOAT(<re;NumEntries>))                   RfgTLim 12
c                                                                               RfgTLim 13
      IF (MinVal .GT. MaxVal)  THEN                                             RfgTLim 14
        x = MinVal                                                              RfgTLim 15
        MinVal = MaxVal                                                         RfgTLim 16
        MaxVal = x                                                              RfgTLim 17
      ENDIF                                                                     RfgTLim 18
c                                                                               RfgTLim 19
      RETURN                                                                    RfgTLim 20
      END                                                                       RfgTLim 21
      FUNCTION RefgV_fPH(Jre, Pres, Enthalpy)                                   RfgVTP   2
c                                                                               RfgVTP   3
c              Calculates the volume of a refrigerant gas                       RfgVTP   4
c              corresponding to a given pressure and enthalpy                   RfgVTP   5
c                                                                               RfgVTP   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
c                                                                               RfgVTP   8
c              Interpolation factor based on pressure                           RfgVTP   9
      X = RefgTablePosition(Jre, 2, Pres)                                       RfgVTP  10
c                                                                               RfgVTP  11
c              Based on pressure and enthalpy, determine whether the            RfgVTP  12
c              refrigerant is liquid, vapor, or a mixture                       RfgVTP  13
c                                                                               RfgVTP  14
c              Saturated vapor enthalpy                                         RfgVTP  15
      Hvapor = RefgTableValue(Jre, 6, X)                                        RfgVTP  16
c                                                                               RfgVTP  17
      IF (Enthalpy .GE. Hvapor)  THEN                                           RfgVTP  18
c              Refrigerant is a superheated vapor                               RfgVTP  19
c              saturated temperature, volume, specific heat, superheat          RfgVTP  20
        Tsatur    = RefgTableValue(Jre, 1, X)                                   RfgVTP  21
        Vsatur    = RefgTableValue(Jre, 4, X)                                   RfgVTP  22
        Cp        = RefgTableValue(Jre, 8, X)                                   RfgVTP  23
        dTsuper   = (Enthalpy-Hvapor) / Cp                                      RfgVTP  24
        Tsuper    = Tsatur + dTsuper                                            RfgVTP  25
c              adjusted volume assuming ideal gas laws                          RfgVTP  26
        RefgV_fPH = Vsatur * (Tsuper+460.)/(Tsatur+460.)                        RfgVTP  27
      ELSE                                                                      RfgVTP  28
        Hliquid = RefgTableValue(Jre, 5, X)                                     RfgVTP  29
        IF (Enthalpy .LE. Hliquid)  THEN                                        RfgVTP  30
c              refrigerant is a liquid - get density and invert                 RfgVTP  31
          RefgV_fPH = 1.0 / RefgTableValue(Jre, 3, X)                           RfgVTP  32
        ELSE                                                                    RfgVTP  33
c              refrigerant is a mixture of liquid and vapor                     RfgVTP  34
          Vsatur    = RefgTableValue(Jre, 4, X)                                 RfgVTP  35
          Dsatur    = RefgTableValue(Jre, 3, X)                                 RfgVTP  36
c              fraction of mixture that is vapor                                RfgVTP  37
          Fraction  = (Enthalpy-Hliquid) / (Hvapor-Hliquid)                     RfgVTP  38
          RefgV_fPH = Fraction*Vsatur + (1.-Fraction)/Dsatur                    RfgVTP  39
        ENDIF                                                                   RfgVTP  40
      ENDIF                                                                     RfgVTP  41
c                                                                               RfgVTP  42
      RETURN                                                                    RfgVTP  43
      END                                                                       RfgVTP  44
C ##############################################################################RefgT    2
C ##########                                                          ##########RefgT    3
C ##########                  TABLE LOOKUP ROUTINES                   ##########RefgT    4
C ##########                                                          ##########RefgT    5
C ##############################################################################RefgT    6
c                                                                               RefgT    7
c              Routines that process table lookup requests                      RefgT    8
c                                                                               RefgT    9
c              RefgTablePosition   Interpolation factor f(Row, Value)           RefgT   10
c              RefgTableSetUp      Sets up a table                              RefgT   11
c              RefgTableValue      Returns a value      f(Row, Interpolation)   RefgT   12
c                                                                               RefgT   13
      FUNCTION RefgTablePosition(Jre, R, Value)                                 RTblP    2
c                                                                               RTblP    3
c              Returns the relative position of a value in a table.             RTblP    4
c                                                                               RTblP    5
c              Jre    Pointer to the refrigerant                                RTblP    6
c              R      The variable row in which the value resides.              RTblP    7
c              Value  The value contained somewhere in the row                  RTblP    8
c                                                                               RTblP    9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               RTblP   15
      INTEGER R                                                                 RTblP   16
c                                                                               RTblP   17
c              Initialize the variable index at the low end of the range        RTblP   18
c              to the beginning row index                                       RTblP   19
      I1 = 1 + (R-1)*40                                                         RTblP   20
c              initialize the variable index at the high end of the range       RTblP   21
c              to the ending row index                                          RTblP   22
      I2 = I1 + <re;NumEntries> - 1                                             RTblP   23
c                                                                               RTblP   24
c              Variables may be entered in either an ascending or               RTblP   25
c              descending order                                                 RTblP   26
c              RowType = 0  Not well behaved - can't solve                      RTblP   27
c                        1  Values are ascending                                RTblP   28
c                        2  Values are descending                               RTblP   29
      IF (<re;RowType> .EQ. 1)  THEN                                            RTblP   30
c              Ascending order - check to see if Value is in the                RTblP   31
c              table range                                                      RTblP   32
        IF (Value .LT. <re:VARIABLES1>)  THEN                                   RTblP   33
          Call OutOfRange                                                       RTblP   34
          RefgTablePosition = 1.0                                               RTblP   35
          RETURN                                                                RTblP   36
        ELSEIF (Value .GT. <re:VARIABLES2>)  THEN                               RTblP   37
          Call OutOfRange                                                       RTblP   38
          RefgTablePosition = FLOAT(<re;NumEntries>)                            RTblP   39
          RETURN                                                                RTblP   40
        ENDIF                                                                   RTblP   41
c              Now start searching.  Start in the middle of the table           RTblP   42
c              and use successive approximations to guess the new search        RTblP   43
c              position                                                         RTblP   44
        DO                                                                      RTblP   45
c              new search position                                              RTblP   46
          I = (I1 + I2) / 2                                                     RTblP   47
c              see where to go                                                  RTblP   48
          IF (Value .LT. <re:VARIABLES>)  THEN                                  RTblP   49
            I2 = I                                                              RTblP   50
          ELSE                                                                  RTblP   51
            I1 = I                                                              RTblP   52
          ENDIF                                                                 RTblP   53
c              stop searching if range narrowed to 1                            RTblP   54
          IF (I2-I1 .EQ. 1)  EXIT                                               RTblP   55
        ENDDO                                                                   RTblP   56
      ELSEIF (<re;RowType> .EQ. 2)  THEN                                        RTblP   57
c              Descending order - check to see if Value is in the               RTblP   58
c              table range                                                      RTblP   59
        IF (Value .GT. <re:VARIABLES1>)  THEN                                   RTblP   60
          Call OutOfRange                                                       RTblP   61
          RefgTablePosition = 1.0                                               RTblP   62
          RETURN                                                                RTblP   63
        ELSEIF (Value .LT. <re:VARIABLES2>)  THEN                               RTblP   64
          Call OutOfRange                                                       RTblP   65
          RefgTablePosition = FLOAT(<re;NumEntries>)                            RTblP   66
          RETURN                                                                RTblP   67
        ENDIF                                                                   RTblP   68
c              Now start searching.                                             RTblP   69
        DO                                                                      RTblP   70
c              new search position                                              RTblP   71
          I = (I1 + I2) / 2                                                     RTblP   72
c              see where to go                                                  RTblP   73
          IF (Value .LT. <re:VARIABLES>)  THEN                                  RTblP   74
            I1 = I                                                              RTblP   75
          ELSE                                                                  RTblP   76
            I2 = I                                                              RTblP   77
          ENDIF                                                                 RTblP   78
c              stop searching if range narrowed to 1                            RTblP   79
          IF (I2-I1 .EQ. 1)  EXIT                                               RTblP   80
        ENDDO                                                                   RTblP   81
      ELSE                                                                      RTblP   82
c              This table row is not well behaved, and cannot be used           RTblP   83
c              in a search                                                      RTblP   84
        CALL MSGSIM(-1,II,II,II,II)                                             RTblP   85
        WRITE (IOUTPT,9101)  (<re:NAME>,II=1,8), R                              RTblP   86
        CALL MessageBox( NULL,                                                  RTblP   87
     &  'Refrigerant row not all ascending or descending'//char(0),             RTblP   88
     &  'REFRIGERANT Errors'//char(0),                                          RTblP   89
     &  MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                    RTblP   90
        IwinReturn = 1                                                          RTblP   91
        RETURN                                                                  RTblP   92
      ENDIF                                                                     RTblP   93
c                                                                               RTblP   94
c             calculate the absolute variable position                          RTblP   95
      RefgTablePosition = (Value-<re:VARIABLES1>)                               RTblP   96
     &          /((<re:VARIABLES2>-<re:VARIABLES1>) * FLOAT(I2-I1))             RTblP   97
     &          + FLOAT(I1)                                                     RTblP   98
c             convert to relative row position                                  RTblP   99
      RefgTablePosition = RefgTablePosition - FLOAT((R-1) * 40)                 RTblP  100
c                                                                               RTblP  101
c                                                                               RTblP  102
      RETURN                                                                    RTblP  103
c                                                                               RTblP  104
c              message formats                                                  RTblP  105
 9101 FORMAT(                                                                   RTblP  106
     &14x,'Table: ',8A4,' has a row that is not'                       /        RTblP  107
     &14x,'well behaved and cannot be used to lookup other values'     /        RTblP  108
     &14x,'(not continuously ascending or descending). Row: ',I2       )        RTblP  109
c                                                                               RTblP  110
c                                                                               RTblP  111
      CONTAINS                                                                  RTblP  112
c ============== OutOfRange =================================================== RTblP  113
      Subroutine OutOfRange                                                     RTblP  114
c                                                                               RTblP  115
      IF (<re:RangeError> .eq. 0)  THEN                                         RTblP  116
        <re:RangeError> = 1                                                     RTblP  117
        CALL MSGSIM(-2,II,II,II,II)                                             RTblP  118
        WRITE (IOUTPT,9100)  (<re:NAME>,II=1,8), R, Value,                      RTblP  119
     &                        IMO, IDAY, IHR                                    RTblP  120
      ENDIF                                                                     RTblP  121
                                                                                RTblP  122
 9100 FORMAT(                                                                   RTblP  123
     &14x,'Table: ',8A4,' has a lookup value out'                      /        RTblP  124
     &14x,'of range.  Row/Value: ',I2,F10.2,' First time: ',I2,'/',I2,          RTblP  125
     &     '/',I2                                                      )        RTblP  126
c                                                                               RTblP  127
      End Subroutine OutOfRange                                                 RTblP  128
c                                                                               RTblP  129
      END                                                                       RTblP  130
      SUBROUTINE RefgTableSetup                                                 RTblS    2
c                                                                               RTblS    3
c              Sets up all tables                                               RTblS    4
c                                                                               RTblS    5
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /PTRPLT/ Ipm,Ipl,Ich,Ibl,Idw,Itw,Ifr,Ign,Itk,Isp,                 /PTRPLT/ 2
     &                 Iec,Ilm,Ime,Ipq,Ifl,Isp4,Imm,Imc,Igl,Ire,                /PTRPLT/ 3
     &                 Irf,Irc,Isc,Icp,Isg,Ids,Icd,Ifc,Irs,Isp1,                /PTRPLT/ 4
     &                 Npm,Npl,Nch,Nbl,Ndw,Ntw,Nfr,Ngn,Ntk,Nspx,                /PTRPLT/ 5
     &                 Nec,Nlm,Nme,Npq,Nfl,Nsp4,Nmm,Nmc,Ngl,Nre,                /PTRPLT/ 6
     &                 Nrf,Nrc,Nsc,Ncp,Nsg,Nds,Ncd,Nfc,Nrs,Nsp1,                /PTRPLT/ 7
     &                 Lpm,Lpl,Lch,Lbl,Ldw,Ltw,Lfr,Lgn,Ltk,Lsp,                 /PTRPLT/ 8
     &                 Lec,Llm,Lme,Lpq,Lfl,Lsp4,Lmm,Lmc,Lgl,Lre,                /PTRPLT/ 9
     &                 Lrf,Lrc,Lsc,Lcp,Lsg,Lds,Lcd,Lfc,Lrs,Lsp1,                /PTRPLT/10
     &                 Ihx,Iac,Ifb,kpr, NumElecMeters,                          /PTRPLT/11
     &                 xPTRPLT                                                  /PTRPLT/12
c                                                                               RTblS    9
      INTEGER R, C                                                              RTblS   10
c                                                                               RTblS   11
c              Process all tables                                               RTblS   12
      Jre = Ire                                                                 RTblS   13
      DO WHILE (Jre .GT. 0)                                                     RTblS   14
c              find the number of table entries                                 RTblS   15
        NumEntries = 0                                                          RTblS   16
        DO I=1,40                                                               RTblS   17
          IF (<re:VARIABLES> .EQ. -66666.)  THEN                                RTblS   18
            NumEntries = I - 1                                                  RTblS   19
            EXIT                                                                RTblS   20
          ENDIF                                                                 RTblS   21
        ENDDO  ! I                                                              RTblS   22
        IF (NumEntries .EQ. 0)  NumEntries = 40                                 RTblS   23
        <re;NumEntries> = NumEntries                                            RTblS   24
c                                                                               RTblS   25
c              For each table variable, determine whether values                RTblS   26
c              are ascending or descending.                                     RTblS   27
c              RowType = 0  Not well behaved                                    RTblS   28
c                        1  Ascending                                           RTblS   29
c                        2  Descending                                          RTblS   30
c                                                                               RTblS   31
        DO  R=1,12                                                              RTblS   32
          Irow = (R-1)*40                                                       RTblS   33
          I1   = Irow + 1                                                       RTblS   34
          I2   = I1 + NumEntries - 1                                            RTblS   35
          IF (<re:VARIABLES1> .EQ. -66666.)  EXIT                               RTblS   36
          IF (<re:VARIABLES1> .LT. <re:VARIABLES2>)  THEN                       RTblS   37
c              Row appears to be ascending                                      RTblS   38
            <re;RowType> = 1                                                    RTblS   39
c              check to make sure well-behaved                                  RTblS   40
            DO  Ivalue=2,NumEntries                                             RTblS   41
              I2 = Irow + Ivalue                                                RTblS   42
              I1 = I2-1                                                         RTblS   43
              IF (<re:VARIABLES1> .GE. <re:VARIABLES2>)  THEN                   RTblS   44
                <re;RowType> = 0                                                RTblS   45
                EXIT                                                            RTblS   46
              ENDIF                                                             RTblS   47
            ENDDO                                                               RTblS   48
          ELSE                                                                  RTblS   49
c              Row appears to be descending                                     RTblS   50
            <re;RowType> = 2                                                    RTblS   51
c              check to make sure well-behaved                                  RTblS   52
            DO  Ivalue=2,NumEntries                                             RTblS   53
              I2 = Irow + Ivalue                                                RTblS   54
              I1 = I2-1                                                         RTblS   55
              IF (<re:VARIABLES1> .LE. <re:VARIABLES2>)  THEN                   RTblS   56
                <re;RowType> = 0                                                RTblS   57
                EXIT                                                            RTblS   58
              ENDIF                                                             RTblS   59
            ENDDO                                                               RTblS   60
          ENDIF                                                                 RTblS   61
        ENDDO  ! R                                                              RTblS   62
c                                                                               RTblS   63
c              Minimum and maximum temperature and pressure                     RTblS   64
        C = 1                                                                   RTblS   65
        <re;Tmin> = <re:SATURATED-T>                                            RTblS   66
        <re;Pmin> = <re:SATURATED-P>                                            RTblS   67
        C = NumEntries                                                          RTblS   68
        <re;Tmax> = <re:SATURATED-T>                                            RTblS   69
        <re;Pmax> = <re:SATURATED-P>                                            RTblS   70
c                                                                               RTblS   71
        Jre = <re;Next>                                                         RTblS   72
      ENDDO  ! Jre .gt. 0                                                       RTblS   73
c                                                                               RTblS   74
      RETURN                                                                    RTblS   75
      END                                                                       RTblS   76
      FUNCTION RefgTableValue(Jre, R, Position)                                 RTblV    2
c                                                                               RTblV    3
c              Returns a value in a table.                                      RTblV    4
c                                                                               RTblV    5
c              Jre       Pointer to the refrigerant                             RTblV    6
c              R         The variable row in which the value resides.           RTblV    7
c              Position  The position of the value in the row                   RTblV    8
c                                                                               RTblV    9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               RTblV   12
      INTEGER R                                                                 RTblV   13
c                                                                               RTblV   14
c              Set the variable indexes on both sides of the variable           RTblV   15
      I  = Int(Position)                                                        RTblV   16
      I1 = (R-1)*40 + I                                                         RTblV   17
      I2 = I1 + 1                                                               RTblV   18
c              interpolation ratio                                              RTblV   19
      Ratio = Position - FLOAT(I)                                               RTblV   20
c              interpolate to get the value                                     RTblV   21
      RefgTableValue = <re:VARIABLES2> * Ratio                                  RTblV   22
     &               + <re:VARIABLES1> * (1.-Ratio)                             RTblV   23
c                                                                               RTblV   24
c ??                                                                            RTblV   25
      dummy = RefgTableValue                                                    RTblV   26
c                                                                               RTblV   27
      RETURN                                                                    RTblV   28
      END                                                                       RTblV   29
C ##############################################################################Equip    2
C ##############################################################################Equip    3
C ##############################################################################Equip    4
C ##############################################################################Equip    5
C ##############################################################################Equip    6
C ##############################################################################Equip    7
C ##############################################################################Equip    8
C ##########                                                          ##########Equip    9
C ##########                                                          ##########Equip   10
C ##########             REFRIGERATION EQUIPMENT ROUTINES             ##########Equip   11
C ##########                                                          ##########Equip   12
C ##########                                                          ##########Equip   13
C ##############################################################################Equip   14
C ##############################################################################Equip   15
C ##############################################################################Equip   16
C ##############################################################################Equip   17
C ##############################################################################Equip   18
C ##############################################################################Equip   19
C ##############################################################################Equip   20
c                                                                               Equip   21
c    Refrigeration equipment component simulation routines:                     Equip   22
c                                                                               Equip   23
c    CompressorAlgs                  Refrigerant compressors                    Equip   24
c       Compressor_HermeticRecip     Hermetic reciprocating compressor          Equip   25
c                                                                               Equip   26
c    CondenserAlgs                   Refrigerant condensers                     Equip   27
c       Condenser_AirCooled          Air-cooled condenser  (single circuit)     Equip   28
c       Condenser_Evaporative        Evaporative condenser (single circuit)     Equip   29
c                                                                               Equip   30
c    DesuperheaterAlgs               Refrigerant desuperheaters                 Equip   31
c       Desuperheater_Detach         Detaches a desuperheater                   Equip   32
c       Desuperheater_Injection      Liquid injection desuperheater             Equip   33
c                                                                               Equip   34
c    SubcoolerAlgs                   Refrigerant subcoolers                     Equip   35
c       Subcooler_Mechanical         Mechanical subcooler                       Equip   36
c                                                                               Equip   37
c                                                                               Equip   38
C ##############################################################################CompA    2
C ##############################################################################CompA    3
C ##############################################################################CompA    4
C ##############################################################################CompA    5
C ##########                                                          ##########CompA    6
C ##########                   COMPRESSOR ROUTINES                    ##########CompA    7
C ##########                                                          ##########CompA    8
C ##############################################################################CompA    9
C ##############################################################################CompA   10
C ##############################################################################CompA   11
C ##############################################################################CompA   12
c                                                                               CompA   13
      SUBROUTINE CompressorAlgs(Mode, Knx)                                      CompA   14
c                                                                               CompA   15
c              Selects the correct compressor simulation algorithm              CompA   16
c                                                                               CompA   17
c              Knx  Pointer to the component or one of its nodes                CompA   18
c                                                                               CompA   19
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               CompA   22
      DATA IdNode /4H$Kno/                                                      /IdNode/ 2
c                                                                               CompA   24
c              Knx may point either to the component or to one of the           CompA   25
c              component's nodes                                                CompA   26
      IF (<nx;Ident> .EQ. IdNode)  THEN                                         CompA   27
        Jna = <nx;Component>                                                    CompA   28
      ELSE                                                                      CompA   29
        Jna = Knx                                                               CompA   30
      ENDIF                                                                     CompA   31
c                                                                               CompA   32
      SELECT CASE (<na:ALGORITHM>)                                              CompA   33
c                                                                               CompA   34
      CASE (1)  ! Semi-hermetic reciprocating, or similar                       CompA   35
        Call Compressor_HermeticRecip(Mode, Jna)                                CompA   36
      CASE (2)  ! Variable-speed centrifugal                                    CompA   37
        Call Compressor_Centrifugal(Mode, Jna)                                  CompA   38
      END SELECT                                                                CompA   39
c                                                                               CompA   40
      RETURN                                                                    CompA   41
      END                                                                       CompA   42
      SUBROUTINE Compressor_Centrifugal(Mode, Jcp)                              CompC    2
c                                                                               CompC    3
c              Simulates a variable-speed centrifugal compressor.               CompC    4
c                                                                               CompC    5
c              Mode = 0-9  Attachment calculations                              CompC    6
c                      10  Design                                               CompC    7
c                      21  Hourly capacity                                      CompC    8
c                      32  Hourly initialization                                CompC    9
c                      33  Hourly performance within a bin                      CompC   10
c                      39  End of hour reconciliation                           CompC   11
c                                                                               CompC   12
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               CompC   21
      INTEGER Xri, Xro, rH                                                      CompC   22
      REAL    Mcap                                                              CompC   23
c                                                                               CompC   24
c              Compressor inlet node, and inlet and outlet nodes                CompC   25
c              of the attached suction group and discharge                      CompC   26
      Kri = <cp;SuctionNode>             ! refrigerant inlet                    CompC   27
      Xri = <ri;Xnode>                   ! node'd inlet                         CompC   28
      Kro = <cp;DischargeNode>           ! refrigerant outlet                   CompC   29
      Xro = <ro;Xnode>                   ! node'd outlet                        CompC   30
      Kcs = <cp;CtrlNode>                ! control block                        CompC   31
      Jre = <cp;Refrigerant>             ! refrigerant                          CompC   32
c                                                                               CompC   33
      SELECT CASE (Mode)                                                        CompC   34
c                                                                               CompC   35
c                                                                               CompC   36
c ============ HOURLY INITIALIZATION ========================================== CompC   37
      CASE (10)                                                                 CompC   38
c                                                                               CompC   39
c                                                                               CompC   40
c ============ HOURLY OPERATING CAPACITY ====================================== CompC   41
      CASE (21)                                                                 CompC   42
c                                                                               CompC   43
c              Inlet superheat                                                  CompC   44
      HinletMin = RefgH_Vapor_fT(Jre, <Xri.Tsetpt>)                             CompC   45
      IF (HinletMin .LT. <Xri.Hinlet>)  THEN                                    CompC   46
        dTsuper = RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>)                CompC   47
      ELSE                                                                      CompC   48
        dTsuper = 0.                                                            CompC   49
      ENDIF                                                                     CompC   50
c              saturated discharge temperature                                  CompC   51
      SDT = RefgT_fP(Jre, <Xro.Poutlet>)                                        CompC   52
c                                                                               CompC   53
c              Capacity at suction group condition                              CompC   54
      Mcap = <cp;NormalCap>                                                     CompC   55
     &     * Curve(Jcp, <cp:CAP-FSST&SDT>, <Xri.Tsetpt>, SDT)                   CompC   56
     &     * Curve(Jcp, <cp:CAP-FSUPERHEA>, dTsuper, dTsuper)                   CompC   57
c                                                                               CompC   58
c              Adjust operating capacity for compressor control mechanism       CompC   59
      SELECT CASE (<cp:CAPACITY-CTRL>)                                          CompC   60
      CASE (0)  ! No capacity control                                           CompC   61
        <ri.MaxMrefg> = Mcap                                                    CompC   62
                                                                                CompC   63
      CASE (1)  ! Internal temperature setpoint                                 CompC   64
        CtrlSignal = (<Xri.Tsetpt>-<cp:INT-SETPT-T>) * <cp;1/Throttle>          CompC   65
     &             + 0.5                                                        CompC   66
        CtrlSignal = MIN(1., MAX(0., CtrlSignal))                               CompC   67
        <ri.MaxMrefg> = Mcap                                                    CompC   68
     &                * (<cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal)          CompC   69
                                                                                CompC   70
      CASE (2)  ! External control signal                                       CompC   71
        IF (<cs.KnxModulate> .eq. 0 .or. <cs.KnxModulate> .eq. Kri) THEN        CompC   72
c              this compressor can modulate                                     CompC   73
          CtrlSignal = (<cs.CtrlSignal>-<cp:MIN-SIGNAL>)*<cp;1/Throttle>        CompC   74
          CtrlSignal = MIN(1., MAX(0., CtrlSignal))                             CompC   75
          <ri.MaxMrefg> = Mcap                                                  CompC   76
     &                  * (<cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal)        CompC   77
        ELSE  ! not allowed to modulate                                         CompC   78
          <ri.MaxMrefg> = Mcap                                                  CompC   79
        ENDIF                                                                   CompC   80
      END SELECT  ! cp:CAPACITY-CTRL                                            CompC   81
                                                                                CompC   82
      IF (<ri.MaxMrefg> .eq. 0.)  Return                                        CompC   83
                                                                                CompC   84
c              PLR at control signal                                            CompC   85
      PLR = <ri.MaxMrefg> / Mcap                                                CompC   86
c              Adjust for minimum possible operating ratio                      CompC   87
      IF (<cp:MIN-CAP-FSST&> .ne. 0) THEN                                       CompC   88
        PLRmin = Curve(Jcp, <cp:MIN-CAP-FSST&>, <Xri.Tsetpt>, SDT)              CompC   89
      ELSE                                                                      CompC   90
        PLRmin = 0.                                                             CompC   91
      ENDIF                                                                     CompC   92
                                                                                CompC   93
c              Limit by max power, if specified                                 CompC   94
      IF (<cp:MAX-PWR> .gt. 0.  .and.  PLR .gt. PLRmin) THEN                    CompC   95
        Jcv = <cp:PWR-FSST&SDT>                                                 CompC   96
        IF (<cv:TYPE> .eq. 21)  THEN  ! power curve yields COP                  CompC   97
          Qrfg      = Mcap * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))                CompC   98
          COP       = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                        CompC   99
          CompKWmax = <cp;NormalKW> * Qrfg/COP                                  CompC  100
        ELSE  ! power curve yields kW                                           CompC  101
          CompKWmax = <cp;NormalKW>                                             CompC  102
     &              * Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                        CompC  103
        ENDIF                                                                   CompC  104
        dTcomp = Dim(SDT, <Xri.Tsetpt>)                                         CompC  105
        fSuper = Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, x)                     CompC  106
        CompKW = CompKWmax * fSuper                                             CompC  107
     &                     * Curve(Jcp, <cp:PWR-FPLR>, PLR, dTcomp)             CompC  108
        IF (CompKW .gt. <cp:MAX-PWR>) THEN                                      CompC  109
          fPLRdT = <cp:MAX-PWR> / (CompKWmax * fSuper)                          CompC  110
          Call CurveInvert(Jcp,<cp:PWR-FPLR>,1,PLR,dTcomp,fPLRdT, Error)        CompC  111
        ENDIF                                                                   CompC  112
      ENDIF                                                                     CompC  113
                                                                                CompC  114
c              Maximum output with control constraints                          CompC  115
      <ri.MaxMrefg> = Mcap * Max(PLR, PLRmin)                                   CompC  116
c                                                                               CompC  117
c                                                                               CompC  118
c ============ HOURLY SIMULATION - INITIALIZE BIN TOTALS ====================== CompC  119
      CASE (32)                                                                 CompC  120
c                                                                               CompC  121
      <ro.RunFrac>  = 0.                                                        CompC  122
      <cp;PLR>      = 0.                                                        CompC  123
      <cp;CompKW>   = 0.                                                        CompC  124
      <ri.Minlet>   = 0.                                                        CompC  125
c                                                                               CompC  126
c                                                                               CompC  127
c ============ HOURLY SIMULATION - PERFORMANCE WITHIN A BIN =================== CompC  128
      CASE (33)                                                                 CompC  129
c                                                                               CompC  130
c              Inlet superheat                                                  CompC  131
      HinletMin = RefgH_Vapor_fT(Jre, <Xri.Tsetpt>)                             CompC  132
      IF (HinletMin .LT. <Xri.Hinlet>)  THEN                                    CompC  133
        dTsuper = RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>)                CompC  134
      ELSE                                                                      CompC  135
        dTsuper = 0.                                                            CompC  136
      ENDIF                                                                     CompC  137
c              saturated discharge temperature                                  CompC  138
      SDT = RefgT_fP(Jre, <Xro.Poutlet>)                                        CompC  139
c                                                                               CompC  140
c              Capacity at suction group condition                              CompC  141
      Mcap = <cp;NormalCap>                                                     CompC  142
     &     * Curve(Jcp, <cp:CAP-FSST&SDT>, <Xri.Tsetpt>, SDT)                   CompC  143
     &     * Curve(Jcp, <cp:CAP-FSUPERHEA>, dTsuper, dTsuper)                   CompC  144
                                                                                CompC  145
c              Adjust operating capacity for compressor control mechanism       CompC  146
      SELECT CASE (<cp:CAPACITY-CTRL>)                                          CompC  147
      CASE (0)  ! No capacity control                                           CompC  148
        PLR = 1.0                                                               CompC  149
      CASE (1)  ! Internal temperature setpoint                                 CompC  150
        CtrlSignal = (<Xri.Tsetpt>-<cp:INT-SETPT-T>) * <cp;1/Throttle>          CompC  151
     &             + 0.5                                                        CompC  152
        CtrlSignal = MIN(1., MAX(0., CtrlSignal))                               CompC  153
        PLR        = <cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal               CompC  154
c                                                                               CompC  155
      CASE (2)  ! External control signal                                       CompC  156
        IF (<cs.KnxModulate> .eq. 0 .or. <cs.KnxModulate> .eq. Kri) THEN        CompC  157
c              this compressor can modulate                                     CompC  158
          CtrlSignal = (<cs.CtrlSignal>-<cp:MIN-SIGNAL>)*<cp;1/Throttle>        CompC  159
          CtrlSignal = MIN(1., MAX(0., CtrlSignal))                             CompC  160
          PLR        = <cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal             CompC  161
        ELSE  ! not allowed to modulate                                         CompC  162
          PLR        = 1.0                                                      CompC  163
        ENDIF                                                                   CompC  164
      END SELECT  ! cp:CAPACITY-CTRL                                            CompC  165
c              Adjust for minimum possible operating ratio                      CompC  166
      IF (<cp:MIN-CAP-FSST&> .ne. 0) THEN                                       CompC  167
        PLRmin = Curve(Jcp, <cp:MIN-CAP-FSST&>, <Xri.Tsetpt>, SDT)              CompC  168
        PLR    = Max(PLR, PLRmin)                                               CompC  169
      ELSE                                                                      CompC  170
        PLRmin = 0.                                                             CompC  171
      ENDIF                                                                     CompC  172
                                                                                CompC  173
c              Compressor power consumption                                     CompC  174
      Jcv = <cp:PWR-FSST&SDT>                                                   CompC  175
      IF (<cv:TYPE> .eq. 21)  THEN  ! power curve yields COP                    CompC  176
        Qrfg      = Mcap * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))                  CompC  177
        COP       = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                          CompC  178
        CompKWmax = <cp;NormalKW> * Qrfg/COP                                    CompC  179
      ELSE  ! power curve yields kW                                             CompC  180
        CompKWmax = <cp;NormalKW>                                               CompC  181
     &            * Curve(Jcp, <cp:PWR-FSST&SDT>, <Xri.Tsetpt>, SDT)            CompC  182
      ENDIF                                                                     CompC  183
      dTcomp = Dim(SDT, <Xri.Tsetpt>)                                           CompC  184
      fSuper = Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, xx)                      CompC  185
      CompKW = CompKWmax * fSuper                                               CompC  186
     &                   * Curve(Jcp, <cp:PWR-FPLR>, PLR, dTcomp)               CompC  187
c              Limit by max power, if specified                                 CompC  188
      IF (<cp:MAX-PWR> .gt. 0.  .and.  PLR .gt. PLRmin                          CompC  189
     &                          .and.  CompKW .gt. <cp:MAX-PWR>) THEN           CompC  190
        fPLRdT = <cp:MAX-PWR> / (CompKWmax * fSuper)                            CompC  191
        Call CurveInvert(Jcp,<cp:PWR-FPLR>,1,PLR,dTcomp,fPLRdT, Error)          CompC  192
        IF (PLR .gt. PLRmin) THEN                                               CompC  193
          CompKW = <cp:MAX-PWR>                                                 CompC  194
        ELSE                                                                    CompC  195
          CompKW = CompKWmax * fSuper                                           CompC  196
     &                       * Curve(Jcp, <cp:PWR-FPLR>, PLRmin, dTcomp)        CompC  197
        ENDIF                                                                   CompC  198
      ENDIF                                                                     CompC  199
                                                                                CompC  200
c              Weight by the fraction of hour this bin is active, and           CompC  201
c              sum across all bins                                              CompC  202
      <ro.RunFrac> = <ro.RunFrac> + <cs.RunFrac>                                CompC  203
      <cp;CompKW>  = <cp;CompKW>  + <cs.RunFrac> * CompKW                       CompC  204
      <cp;PLR>     = <cp;PLR>     + <cs.RunFrac> * PLR                          CompC  205
      <ri.Minlet>  = <ri.Minlet>  + <cs.RunFrac> * PLR * Mcap                   CompC  206
c                                                                               CompC  207
c                                                                               CompC  208
c ============ HOURLY SIMULATION - END OF HOUR RECONCILIATION ================= CompC  209
      CASE (38:39)                                                              CompC  210
c                                                                               CompC  211
c              Adjust inlet mass flow rate and power so that refrigerant        CompC  212
c              is conserved                                                     CompC  213
      <ri.Minlet> = <ri.Minlet> * <cs.Adjustment>                               CompC  214
      <cp;CompKW> = <cp;CompKW> * <cs.Adjustment>                               CompC  215
      <cp;PLR>    = <cp;PLR>    * <cs.Adjustment>                               CompC  216
      <ri.Qinlet> = <ri.Minlet> * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))           CompC  217
c                                                                               CompC  218
c              Outlet conditions                                                CompC  219
      <ro.Qoutlet> = <ri.Qinlet> + <cp;CompKW>*BtuKW                            CompC  220
      <ro.Moutlet> = <ri.Minlet>                                                CompC  221
      <ro.Mreqd>   = <ri.Minlet>                                                CompC  222
      IF (<ro.Moutlet> .GT. 0.)                                                 CompC  223
     &  <ro.Houtlet> = <Xri.Hinlet> + (<cp;CompKW>*BtuKW/<ro.Moutlet>)          CompC  224
c              Required outlet pressure                                         CompC  225
      IF (<cp:MIN-DP> .gt. 0.)  <ro.Preqd> = <Xri.Pinlet> + <cp:MIN-DP>         CompC  226
                                                                                CompC  227
c              Power consumption                                                CompC  228
      Kmd       = <cp:ELEC-METER>                                               CompC  229
      <md.Elec> = <cp;CompKW>                                                   CompC  230
c                                                                               CompC  231
c             Auxiliary power                                                   CompC  232
      IF (<cp:AUX-KW> .GT. 0.)  THEN                                            CompC  233
        Kmd = <cp:AUX-METER>                                                    CompC  234
        SELECT CASE (<cp:AUX-MODE>)                                             CompC  235
          CASE (1)  ! Always                                                    CompC  236
            <md.Elec> = <cp:AUX-KW>                                             CompC  237
          CASE (2)  ! When on                                                   CompC  238
            <md.Elec> = <cp:AUX-KW> * <ro.RunFrac>                              CompC  239
          CASE (3)  ! When off                                                  CompC  240
            <md.Elec> = <cp:AUX-KW> * (1.0 - <ro.RunFrac>)                      CompC  241
          CASE (4)  ! Scheduled                                                 CompC  242
            <md.Elec> = <cp:AUX-KW> * SchVal(<cp:AUX-SCH>)                      CompC  243
        END SELECT                                                              CompC  244
      ENDIF                                                                     CompC  245
c                                                                               CompC  246
c              Check for convergence and clear local iteration flags            CompC  247
      IF (Mode .EQ. 38)  THEN                                                   CompC  248
        CALL CnvgCheck(1, <cp;DischargeHsty>)  ! Loads to Plant                 CompC  249
      ELSE                                                                      CompC  250
        CALL CnvgCheck(0, <cp;DischargeHsty>)                                   CompC  251
      ENDIF                                                                     CompC  252
c                                                                               CompC  253
c                                                                               CompC  254
c ============ REPORT CREATION ================================================ CompC  255
      CASE (50)                                                                 CompC  256
c                                                                               CompC  257
c              statistics blocks                                                CompC  258
      Ks2Load    = NewStat2(Kri, <+ri.Qinlet>, 0, 1.)                           CompC  259
      Ks2Flow    = NewStat2(Kri, <+ri.Minlet>, 0, 1.)                           CompC  260
      Ks2Elec    = NewStat2(<cp:ELEC-METER>, <+md.Elec>, 0, 1.)                 CompC  261
      Kli        = 0                                                            CompC  262
      CALL ListNodes(Kli, 0,0,Jcp,0, 11,2)                                      CompC  263
      Ks2ElecT   = NewStat2(Kli,   <+md.Elec>, 0, 1.)                           CompC  264
      Ks5FlowBin = NewStat5(Kri, <+ri.Minlet>, 0, 1.)                           CompC  265
      Ks5ElecBin = NewStat5(Kli,   <+md.Elec>, 0, 1.)                           CompC  266
c                                                                               CompC  267
c              Create the type "H" report                                       CompC  268
      IF (<cp:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      CompC  269
     &  <cp;PS-H> = NewReport_H(Jcp, 131,                                       CompC  270
     &                          4, 5, 6,                                        CompC  271
     &                          Ks2Load, Ks2Flow, Ks2Elec, Ks2ElecT,            CompC  272
     &                          Ks5FlowBin, Ks5Elecbin, 0,                      CompC  273
     &                          0, 0, 0)                                        CompC  274
c                                                                               CompC  275
c                                                                               CompC  276
c ============ REPORT ORDER =================================================== CompC  277
      CASE (52)                                                                 CompC  278
c                                                                               CompC  279
      Call Report_H(Mode, <cp;PS-H>)                                            CompC  280
c                                                                               CompC  281
c                                                                               CompC  282
c ============ REPORTS - VERIFICATION DATA ==================================== CompC  283
      CASE (54)                                                                 CompC  284
c                                                                               CompC  285
c              Output design information                                        CompC  286
      IF (<cp;PS-H> .ne. 0)  THEN                                               CompC  287
        rH  = <cp;PS-H>                                                         CompC  288
        Kmd = <cp:ELEC-METER>                                                   CompC  289
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       CompC  290
        CALL GetAttachments(Jcp, 2)                                             CompC  291
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   CompC  292
     &    (NameAttachments(II,1,1),II=1,8),                                     CompC  293
     &    (NameAttachments(II,1,2),II=1,8),                                     CompC  294
     &    <cp;Capacity>,<md.Elec>,<Xri.Tsetpt>,                                 CompC  295
     &    RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>),                       CompC  296
     &    RefgT_fP(Jre, <Xro.Poutlet>)                                          CompC  297
        DO  Irow=2,NumRowsOfAttachments                                         CompC  298
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 CompC  299
     &      (NameAttachments(II,Irow,1),II=1,8),                                CompC  300
     &      (NameAttachments(II,Irow,2),II=1,8)                                 CompC  301
        ENDDO                                                                   CompC  302
      ENDIF                                                                     CompC  303
c                                                                               CompC  304
c                                                                               CompC  305
c ============ HOURLY REPORTS - HOURLY DATA =================================== CompC  306
      CASE (62)                                                                 CompC  307
c                                                                               CompC  308
c              Hourly-report variables                                          CompC  309
      IF (<cp;HourRepBuf> .EQ. 0)  RETURN                                       CompC  310
c                                                                               CompC  311
c              get suction group inlet node for average conditions              CompC  312
      Jsg = <cp:SUCTION-GROUP>                                                  CompC  313
      Krx = <sg;SuctionNode>                                                    CompC  314
c                                                                               CompC  315
      IAptr        = <cp;HourRepBuf> - 1                                        CompC  316
      AA(IAptr+1)  = <ri.Qinlet>                                                CompC  317
      AA(IAptr+2)  = <ri.Minlet>                                                CompC  318
      Kmd          = <cp:ELEC-METER>                                            CompC  319
      AA(IAptr+3)  = <md.Elec>                                                  CompC  320
      Kmd          = <cp:AUX-METER>                                             CompC  321
      IF (Kmd .GT. 0)  AA(IAptr+4)  = <md.Elec>                                 CompC  322
      AA(IAptr+5)  = <ro.RunFrac>                                               CompC  323
      AA(IAptr+6)  = RefgT_fP(Jre, <rx.Prefg>)                                  CompC  324
      AA(IAptr+7)  = RefgSuper_fPH(Jre, <rx.Prefg>, <rx.Hrefg>)                 CompC  325
      AA(IAptr+8)  = <rx.Prefg>                                                 CompC  326
      AA(IAptr+9)  = <rx.Hrefg>                                                 CompC  327
      AA(IAptr+10) = <ro.Qoutlet>                                               CompC  328
      AA(IAptr+11) = RefgT_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                CompC  329
      AA(IAptr+12) = RefgT_fP(Jre, <Xro.Poutlet>)                               CompC  330
      AA(IAptr+13) = <ro.Houtlet>                                               CompC  331
      IF (<ro.RunFrac> .GT. 0.)  THEN                                           CompC  332
        AA(IAptr+14) = <cp;PLR> / <ro.RunFrac>                                  CompC  333
      ELSE                                                                      CompC  334
        AA(IAptr+14) = 0.                                                       CompC  335
      ENDIF                                                                     CompC  336
c                                                                               CompC  337
c                                                                               CompC  338
c ============ DESIGN CALCULATIONS - INITIALIZATION =========================== CompC  339
      CASE (110)                                                                CompC  340
c                                                                               CompC  341
c              set minimum allowable discharge pressure                         CompC  342
      <ro.Preqd> = -88888.                                                      CompC  343
                                                                                CompC  344
c              Check for valid RATED-SST & RATED-SDT                            CompC  345
      IF (<cp:CAPACITY> .gt. 0.  .or.  <cp:POWER-RATIO> .gt. 0.  .or.           CompC  346
     &    <cp:POWER> .gt. 0.  .or.  <cp:COEF-OF-PERFO> .gt. 0.) THEN            CompC  347
        IF (<cp:RATED-SST> .ge. <cp:RATED-SDT>) THEN                            CompC  348
          Call MSGSIM(-1,II,II,II,II)                                           CompC  349
          Write (IOUTPT, 9010) (<cp:NAME>,II=1,8),                              CompC  350
     &                          <cp:RATED-SST>, <cp:RATED-SDT>                  CompC  351
          Call MessageBox( NULL,                                                CompC  352
     &      'Compressor RATED-SST > RATED-SDT'//char(0),                        CompC  353
     &      'COMPRESSOR Errors'//char(0),                                       CompC  354
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompC  355
          IwinReturn = 1                                                        CompC  356
          Return                                                                CompC  357
        ENDIF                                                                   CompC  358
      ELSE                                                                      CompC  359
        <cp:RATED-SST> = UNFILD                                                 CompC  360
        <cp:RATED-SDT> = UNFILD                                                 CompC  361
      ENDIF                                                                     CompC  362
                                                                                CompC  363
c              Set up the control                                               CompC  364
      SELECT CASE (<cp:CAPACITY-CTRL>)                                          CompC  365
        CASE (0)  ! No capacity control                                         CompC  366
c                                                                               CompC  367
        CASE (1)  ! Internal temperature setpoint                               CompC  368
          <cp;1/Throttle> = 1.0 / <cp:INT-THROTTLE>                             CompC  369
          <cp;CapRange>   = 1.0 - <cp:MIN-CAPACITY>                             CompC  370
c                                                                               CompC  371
        CASE (2)  ! External control signal                                     CompC  372
          IF (<cp:MIN-SIGNAL> .GE. <cp:MAX-SIGNAL>)  THEN                       CompC  373
            CALL MSGSIM(-1,II,II,II,II)                                         CompC  374
            WRITE (IOUTPT, 9005)  (<cp:NAME>,II=1,8)                            CompC  375
            CALL MessageBox( NULL,                                              CompC  376
     &        'Compressor Ctrl signals inverted'//char(0),                      CompC  377
     &        'COMPRESSOR Errors'//char(0),                                     CompC  378
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              CompC  379
            IwinReturn = 1                                                      CompC  380
          ELSE                                                                  CompC  381
            <cp;1/Throttle> = 1./(<cp:MAX-SIGNAL>-<cp:MIN-SIGNAL>)              CompC  382
            <cp;CapRange>   = 1.0 - <cp:MIN-CAPACITY>                           CompC  383
          ENDIF                                                                 CompC  384
      END SELECT  ! cp:CAPACITY-CTRL                                            CompC  385
c                                                                               CompC  386
c                                                                               CompC  387
c ============ DESIGN CALCULATIONS ============================================ CompC  388
      CASE (111)                                                                CompC  389
c                                                                               CompC  390
c              Outlet pressure - If not yet set by downstream, it is            CompC  391
c              probably because compressors are staged. Estimate assuming       CompC  392
c              a downstream condensing temperature of 100F                      CompC  393
      IF (<Xro.Poutlet> .NE. -88888.)  THEN                                     CompC  394
        Poutlet = <Xro.Poutlet>                                                 CompC  395
      ELSE                                                                      CompC  396
        Poutlet = RefgP_fT(Jre, 100.)                                           CompC  397
      ENDIF                                                                     CompC  398
c              Saturated discharge temperature                                  CompC  399
      SDT = RefgT_fP(Jre, Poutlet)                                              CompC  400
c                                                                               CompC  401
c              Inlet superheat                                                  CompC  402
      HinletMin = RefgH_Vapor_fT(Jre, <Xri.Tsetpt>)                             CompC  403
      IF (HinletMin .LT. <Xri.Hinlet>)  THEN                                    CompC  404
        dTsuper = RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>)                CompC  405
      ELSE                                                                      CompC  406
        dTsuper = 0.                                                            CompC  407
      ENDIF                                                                     CompC  408
c                                                                               CompC  409
c              Capacity factors at design and rated conditions                  CompC  410
      Cap_fDesign = Curve(Jcp,<cp:CAP-FSST&SDT>,<Xri.Tsetpt>,SDT)               CompC  411
     &            * Curve(Jcp,<cp:CAP-FSUPERHEA>,dTsuper,x)                     CompC  412
      IF (Cap_fDesign .le. 0.)  THEN                                            CompC  413
        CALL MSGSIM(-1,II,II,II,II)                                             CompC  414
        WRITE (IOUTPT, 9006)  (<cp:NAME>,II=1,8)                                CompC  415
        CALL MessageBox( NULL,                                                  CompC  416
     &    'Compressor capacity curve invalid'//char(0),                         CompC  417
     &    'COMPRESSOR Errors'//char(0),                                         CompC  418
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompC  419
        IwinReturn = 1                                                          CompC  420
        Return                                                                  CompC  421
      ENDIF                                                                     CompC  422
      IF (<cp:RATED-SST> .ne. UNFILD)  THEN                                     CompC  423
        Cap_fRated  = Curve(Jcp,<cp:CAP-FSST&SDT>, <cp:RATED-SST>,              CompC  424
     &                                             <cp:RATED-SDT>)              CompC  425
     &              * Curve(Jcp,<cp:CAP-FSUPERHEA>,<cp:RATED-SUPERHT>,x)        CompC  426
        IF (Cap_fRated .le. 0.)  THEN                                           CompC  427
          CALL MSGSIM(-1,II,II,II,II)                                           CompC  428
          WRITE (IOUTPT, 9007)  (<cp:NAME>,II=1,8)                              CompC  429
          CALL MessageBox( NULL,                                                CompC  430
     &      'Compressor capacity curve invalid'//char(0),                       CompC  431
     &      'COMPRESSOR Errors'//char(0),                                       CompC  432
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompC  433
          IwinReturn = 1                                                        CompC  434
          Return                                                                CompC  435
        ENDIF                                                                   CompC  436
      ENDIF                                                                     CompC  437
c                                                                               CompC  438
c              Capacity, lbs/hr                                                 CompC  439
      Jcv         = <cp:CAP-FSST&SDT>                                           CompC  440
      iCapCrvType = <cv:TYPE>          ! 7=ratio, 14=lbs/hr                     CompC  441
      IF (<cp:CAPACITY> .GT. 0.)  THEN                                          CompC  442
c              user specified capacity at rated conditions                      CompC  443
        <cp;NormalCap> = <cp:CAPACITY> / Cap_fRated                             CompC  444
        <ri.Minlet>    = <cp;NormalCap> * Cap_fDesign                           CompC  445
      ELSEIF (<cp:CAP-RATIO> .GT. 0.)  THEN                                     CompC  446
        <ri.Minlet>    = <Xri.Minlet> * <cp:CAP-RATIO>                          CompC  447
        <cp;NormalCap> = <ri.Minlet> / Cap_fDesign                              CompC  448
      ELSEIF (<cv:TYPE> .EQ. 7)  THEN  ! ratio-fT&T                             CompC  449
c              normalized curve - size equally                                  CompC  450
        Kli = <Xri;Xnode>                                                       CompC  451
        IF (Kli .EQ. Kri)  THEN  ! only one compressor                          CompC  452
          <ri.Minlet> = <Xri.Minlet>                                            CompC  453
        ELSE  ! this compressor is one in a list                                CompC  454
          <ri.Minlet> = <Xri.Minlet> / FLOAT(<li;NumItems>)                     CompC  455
        ENDIF                                                                   CompC  456
        <cp;NormalCap> = <ri.Minlet> / Cap_fDesign                              CompC  457
      ELSE                                                                      CompC  458
c              capacity curve outputs lbs/hr directly                           CompC  459
        <cp;NormalCap> = 1.                                                     CompC  460
        <ri.Minlet>    = Cap_fDesign                                            CompC  461
      ENDIF  ! cp:CAPACITY                                                      CompC  462
c              check for bogus capacity                                         CompC  463
      IF (<cp;NormalCap> .lt. 0.  .or.  <ri.Minlet> .lt. 0.)  THEN              CompC  464
        CALL MSGSIM(-1,II,II,II,II)                                             CompC  465
        WRITE (IOUTPT, 9006)  (<cp:NAME>,II=1,8)                                CompC  466
        CALL MessageBox( NULL,                                                  CompC  467
     &    'Compressor capacity curve invalid'//char(0),                         CompC  468
     &    'COMPRESSOR Errors'//char(0),                                         CompC  469
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompC  470
        IwinReturn = 1                                                          CompC  471
        Return                                                                  CompC  472
      ENDIF                                                                     CompC  473
c              design capacity and load                                         CompC  474
      <cp;Capacity> = <ri.Minlet>                                               CompC  475
      <ri.Qinlet>   = <ri.Minlet> * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))         CompC  476
c              rated capacity and load (may not be specified/required)          CompC  477
      IF (<cp:RATED-SST> .ne. UNFILD) THEN                                      CompC  478
        CapRated = <cp;NormalCap> * Cap_fRated                                  CompC  479
        Hsuction = RefgH_Vapor_fTS(Jre, <cp:RATED-SST>,                         CompC  480
     &                                  <cp:RATED-SUPERHT>)                     CompC  481
        Hcond    = RefgH_Liquid_fT(Jre, <cp:RATED-SDT>)                         CompC  482
        Qrated   = CapRated * (Hsuction-Hcond)                                  CompC  483
      ENDIF                                                                     CompC  484
c                                                                               CompC  485
c              Power factors at design and rated conditions                     CompC  486
      Jcv = <cp:PWR-FSST&SDT>                                                   CompC  487
      IF (<cv:TYPE> .eq. 21)  THEN                                              CompC  488
c              power curve yields COP                                           CompC  489
        COP         = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                        CompC  490
        dTcomp      = Dim(SDT, <Xri.Tsetpt>)                                    CompC  491
        Pwr_fDesign = <ri.Qinlet>/COP * kWBtu                                   CompC  492
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., dTcomp)                     CompC  493
     &              * Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, x)                CompC  494
        IF (Pwr_fDesign .le. 0.)  THEN                                          CompC  495
          CALL MSGSIM(-1,II,II,II,II)                                           CompC  496
          WRITE (IOUTPT, 9008)  (<cp:NAME>,II=1,8)                              CompC  497
          CALL MessageBox( NULL,                                                CompC  498
     &      'Compressor power curve invalid'//char(0),                          CompC  499
     &      'COMPRESSOR Errors'//char(0),                                       CompC  500
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompC  501
          IwinReturn = 1                                                        CompC  502
          Return                                                                CompC  503
        ENDIF                                                                   CompC  504
        IF (<cp:RATED-SST> .ne. UNFILD)  THEN                                   CompC  505
          COP        = Curve(Jcp, Jcv, <cp:RATED-SST>, <cp:RATED-SDT>)          CompC  506
          dTcomp     = Dim(<cp:RATED-SDT>, <cp:RATED-SST>)                      CompC  507
          Pwr_fRated = Qrated/COP * kWBtu                                       CompC  508
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., dTcomp)                     CompC  509
     &              * Curve(Jcp,<cp:PWR-FSUPERHEA>,<cp:RATED-SUPERHT>,x)        CompC  510
          IF (Pwr_fRated .le. 0.)  THEN                                         CompC  511
            CALL MSGSIM(-1,II,II,II,II)                                         CompC  512
            WRITE (IOUTPT, 9009)  (<cp:NAME>,II=1,8)                            CompC  513
            CALL MessageBox( NULL,                                              CompC  514
     &        'Compressor power curve invalid'//char(0),                        CompC  515
     &        'COMPRESSOR Errors'//char(0),                                     CompC  516
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              CompC  517
            IwinReturn = 1                                                      CompC  518
            Return                                                              CompC  519
          ENDIF                                                                 CompC  520
        ENDIF                                                                   CompC  521
      ELSE                                                                      CompC  522
c              power curve yields kW                                            CompC  523
        dTcomp      = Dim(SDT, <Xri.Tsetpt>)                                    CompC  524
        Pwr_fDesign = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                        CompC  525
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., dTcomp)                     CompC  526
     &              * Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, x)                CompC  527
        IF (Pwr_fDesign .le. 0.)  THEN                                          CompC  528
          CALL MSGSIM(-1,II,II,II,II)                                           CompC  529
          WRITE (IOUTPT, 9008)  (<cp:NAME>,II=1,8)                              CompC  530
          CALL MessageBox( NULL,                                                CompC  531
     &      'Compressor power curve invalid'//char(0),                          CompC  532
     &      'COMPRESSOR Errors'//char(0),                                       CompC  533
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompC  534
          IwinReturn = 1                                                        CompC  535
          Return                                                                CompC  536
        ENDIF                                                                   CompC  537
        IF (<cp:RATED-SST> .ne. UNFILD)  THEN                                   CompC  538
          dTcomp     = Dim(<cp:RATED-SDT>, <cp:RATED-SST>)                      CompC  539
          Pwr_fRated = Curve(Jcp, Jcv, <cp:RATED-SST>, <cp:RATED-SDT>)          CompC  540
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., dTcomp)                     CompC  541
     &              * Curve(Jcp,<cp:PWR-FSUPERHEA>,<cp:RATED-SUPERHT>,x)        CompC  542
          IF (Pwr_fRated .le. 0.)  THEN                                         CompC  543
            CALL MSGSIM(-1,II,II,II,II)                                         CompC  544
            WRITE (IOUTPT, 9009)  (<cp:NAME>,II=1,8)                            CompC  545
            CALL MessageBox( NULL,                                              CompC  546
     &        'Compressor power curve invalid'//char(0),                        CompC  547
     &        'COMPRESSOR Errors'//char(0),                                     CompC  548
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              CompC  549
            IwinReturn = 1                                                      CompC  550
            Return                                                              CompC  551
          ENDIF                                                                 CompC  552
        ENDIF                                                                   CompC  553
      ENDIF                                                                     CompC  554
      IF (<cp:POWER> .GT. 0.)  THEN                                             CompC  555
c              user specified power at rated conditions                         CompC  556
        <cp;NormalKW> = <cp:POWER> / Pwr_fRated                                 CompC  557
      ELSEIF (<cp:POWER-RATIO> .GT. 0.)  THEN                                   CompC  558
c              user specified kW/lb at rated conditions                         CompC  559
        <cp;NormalKW> = CapRated * <cp:POWER-RATIO> / Pwr_fRated                CompC  560
      ELSEIF (<cp:COEF-OF-PERFO> .GT. 0.)  THEN                                 CompC  561
c              user specified the COP at rated conditions                       CompC  562
        <cp;NormalKW> = Qrated/<cp:COEF-OF-PERFO> * kWBtu / Pwr_fRated          CompC  563
      ELSEIF (<cv:TYPE> .eq. 15  .and.  iCapCrvType .eq. 14)   THEN             CompC  564
c              Capacity and power curves output lbs/hr and kW directly          CompC  565
        IF (<cp:CAPACITY> .GT. 0.)  THEN                                        CompC  566
c              user has specified rated capacity; adjust power for              CompC  567
c              rated capacity vs. curve capacity                                CompC  568
          <cp;NormalKW> = <cp:CAPACITY> / Cap_fRated                            CompC  569
        ELSEIF (<cp:CAP-RATIO> .GT. 0.)  THEN                                   CompC  570
c              user has specified design capacity; adjust power for             CompC  571
c              design capacity vs. curve capacity                               CompC  572
          <cp;NormalKW> = <cp;Capacity> / Cap_fDesign                           CompC  573
        ELSE                                                                    CompC  574
c              use capacity lb/hr and power kW curves directly                  CompC  575
          <cp;NormalKW> = 1.                                                    CompC  576
        ENDIF                                                                   CompC  577
      ELSE                                                                      CompC  578
        <cp;NormalKW> = 1.                                                      CompC  579
      ENDIF  ! cp:CAPACITY                                                      CompC  580
      <cp;kW> = <cp;NormalKW> * Pwr_fDesign                                     CompC  581
c              check for bogus power                                            CompC  582
      IF (<cp;kW> .lt. 0.)  THEN                                                CompC  583
        CALL MSGSIM(-1,II,II,II,II)                                             CompC  584
        WRITE (IOUTPT, 9007)  (<cp:NAME>,II=1,8)                                CompC  585
        CALL MessageBox( NULL,                                                  CompC  586
     &    'Compressor capacity curve invalid'//char(0),                         CompC  587
     &    'COMPRESSOR Errors'//char(0),                                         CompC  588
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompC  589
        IwinReturn = 1                                                          CompC  590
        Return                                                                  CompC  591
      ENDIF                                                                     CompC  592
      Kmd          = <cp:ELEC-METER>                                            CompC  593
      <md.Elec>    = <cp;kW>                                                    CompC  594
      <ro.Houtlet> = <Xri.Hinlet> + (<cp;kW> * BtuKW / <ri.Minlet>)             CompC  595
      <ro.Moutlet> = <ri.Minlet>                                                CompC  596
      <ro.Mreqd>   = <ri.Minlet>                                                CompC  597
c                                                                               CompC  598
c              for COP include kW/Btu conversion factor for hourly calc         CompC  599
      IF (<cv:TYPE> .eq. 21)                                                    CompC  600
     &  <cp;NormalKW> = <cp;NormalKW> * kWBtu                                   CompC  601
c                                                                               CompC  602
c              Auxiliary power                                                  CompC  603
      IF (<cp:AUX-METER> .GT. 0.)  THEN                                         CompC  604
        Kmd       = <cp:AUX-METER>                                              CompC  605
        <md.Elec> = <cp:AUX-KW>                                                 CompC  606
      ENDIF                                                                     CompC  607
c                                                                               CompC  608
c                                                                               CompC  609
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== CompC  610
      CASE (119)                                                                CompC  611
                                                                                CompC  612
c              Check if SST & SDT are reasonable                                CompC  613
      SDT = RefgT_fP(Jre, <Xro.Poutlet>)                                        CompC  614
      IF (<Xri.Tsetpt> .gt. SDT-5.) THEN                                        CompC  615
        CALL MSGSIM(-2,II,II,II,II)                                             CompC  616
        WRITE (IOUTPT, 9011)  (<cp:NAME>,II=1,8), <Xri.Tsetpt>, SDT             CompC  617
        CALL MessageBox( NULL,                                                  CompC  618
     &    'Compressor SST & SDT unreasonable'//char(0),                         CompC  619
     &    'COMPRESSOR Errors'//char(0),                                         CompC  620
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompC  621
      ENDIF                                                                     CompC  622
                                                                                CompC  623
c              Check if COP is reasonable; ideal COP                            CompC  624
      COPideal = (<Xri.Tsetpt>+460.) / (SDT-<Xri.Tsetpt>)                       CompC  625
      Kmd = <cp:ELEC-METER>                                                     CompC  626
      IF (<md.Elec> .NE. 0.)  THEN                                              CompC  627
        COP = <ri.Qinlet> / (<md.Elec> * BtuKW)                                 CompC  628
        IF (COP .LT. COPideal*0.2 .or.  COP .gt. COPideal) THEN                 CompC  629
          CALL MSGSIM(-2,II,II,II,II)                                           CompC  630
          WRITE (IOUTPT, 9002)  (<cp:NAME>,II=1,8), COP, COPideal,              CompC  631
     &                           <Xri.Tsetpt>, SDT                              CompC  632
          CALL MessageBox( NULL,                                                CompC  633
     &      'Compressor COP unreasonable'//char(0),                             CompC  634
     &      'COMPRESSOR Errors'//char(0),                                       CompC  635
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompC  636
        ELSEIF (COP .LT. COPideal*0.25 .OR. COP .GT. COPideal*0.75) THEN        CompC  637
          CALL MSGSIM(-3,II,II,II,II)                                           CompC  638
          WRITE (IOUTPT, 9003)  (<cp:NAME>,II=1,8), COP, COPideal               CompC  639
c         CALL MessageBox( NULL,                                                CompC  640
c    &      'Compressor COP unreasonable'//char(0),                             CompC  641
c    &      'COMPRESSOR Errors'//char(0),                                       CompC  642
c    &      MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                         CompC  643
        ENDIF                                                                   CompC  644
      ELSE                                                                      CompC  645
        CALL MSGSIM(-2,II,II,II,II)                                             CompC  646
        WRITE (IOUTPT, 9004)  (<cp:NAME>,II=1,8)                                CompC  647
c       CALL MessageBox( NULL,                                                  CompC  648
c    &    'No compressor power'//char(0),                                       CompC  649
c    &    'COMPRESSOR Errors'//char(0),                                         CompC  650
c    &    MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                           CompC  651
      ENDIF                                                                     CompC  652
c                                                                               CompC  653
      <ri;DesMinlet> = <ri.Minlet>                                              CompC  654
c                                                                               CompC  655
c                                                                               CompC  656
c                                                                               CompC  657
c ============ ATTACHMENTS ==================================================== CompC  658
c                                                                               CompC  659
c              Initial attachments                                              CompC  660
      CASE (201)                                                                CompC  661
c              Component pointers, schedules, and curves                        CompC  662
        <cp:SUCTION-GROUP>  = Jcomponent(25, <cp:SUCTION-GROUP>)                CompC  663
        <cp:DISCHARGE-CKT>  = Jcomponent(22, <cp:DISCHARGE-CKT>)                CompC  664
        <cp:/RefgSystem/>   = Jcomponent(29, <cp:/RefgSystem/>)                 CompC  665
        <cp:ELEC-METER>     = Jcomponent(13, <cp:ELEC-METER>)                   CompC  666
        <cp:AUX-METER>      = Jcomponent(13, <cp:AUX-METER>)                    CompC  667
        <cp:COST-DATA>      = Jcomponent(18, <cp:COST-DATA>)                    CompC  668
        <cp:AUX-SCH>        = Jsched(<cp:AUX-SCH>)                              CompC  669
        <cp:CAP-FSST&SDT>   = Jcurve(<cp:CAP-FSST&SDT>)                         CompC  670
        <cp:CAP-FSUPERHEA>  = Jcurve(<cp:CAP-FSUPERHEA>)                        CompC  671
        <cp:MIN-CAP-FSST&>  = Jcurve(<cp:MIN-CAP-FSST&>)                        CompC  672
        <cp:PWR-FSST&SDT>   = Jcurve(<cp:PWR-FSST&SDT>)                         CompC  673
        <cp:PWR-FSUPERHEA>  = Jcurve(<cp:PWR-FSUPERHEA>)                        CompC  674
        <cp:PWR-FPLR>       = Jcurve(<cp:PWR-FPLR>)                             CompC  675
c                                                                               CompC  676
c              Create nodes                                                     CompC  677
      CASE (203)                                                                CompC  678
        Jrs = <cp:/RefgSystem/>                                                 CompC  679
        Jsg = <cp:SUCTION-GROUP>                                                CompC  680
c              Check for cross connections                                      CompC  681
        CALL RefgX(Jcp, <sg:DISCHARGE-CKT>,                                     CompC  682
     &                             <cp:DISCHARGE-CKT>,0)                        CompC  683
c              Suction and discharge attachmants                                CompC  684
        <cp;SuctionNode>  = NewNode(1, 0,Jsg,Jcp,Jsg, 62,1,Jsg, 1.)             CompC  685
        Jrc = <cp:DISCHARGE-CKT>                                                CompC  686
        I   = 60 + <rc:TYPE>                                                    CompC  687
        <cp;DischargeNode> = NewNode(1, Jrs,Jsg,Jcp,Jrc, I,2,Jsg, 1.)           CompC  688
c              Electric and auxiliary meters                                    CompC  689
        IF (<cp:ELEC-METER> .GT. 0)  THEN                                       CompC  690
          Jme = <cp:ELEC-METER>                                                 CompC  691
          <cp:ELEC-METER> = NewNode(1, Jrs,Jsg,Jcp,Jme, 11,2,Jsg, 1.)           CompC  692
        ENDIF                                                                   CompC  693
        IF (<cp:AUX-METER> .GT. 0)  THEN                                        CompC  694
          Jme = <cp:AUX-METER>                                                  CompC  695
          <cp:AUX-METER> = NewNode(1, Jrs,Jsg,Jcp,Jme, 11,2,Jsg, 1.)            CompC  696
        ENDIF                                                                   CompC  697
c                                                                               CompC  698
c              Links, lists                                                     CompC  699
      CASE (205)                                                                CompC  700
c              Get refrigerant pointer from refg plant                          CompC  701
        Jrs              = <cp:/RefgSystem/>                                    CompC  702
        <cp;Refrigerant> = <rs:REFRIGERANT>                                     CompC  703
c              Get pointer to reference enthalpy from liquid trunk              CompC  704
        <cp;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     CompC  705
c                                                                               CompC  706
c              Find the suction group's control block                           CompC  707
        <cp;CtrlNode> = LocateNode(0,0,<cp:SUCTION-GROUP>,0, 21,1)              CompC  708
c                                                                               CompC  709
c              Detach this component                                            CompC  710
      CASE (207)                                                                CompC  711
c              Component will not be used - eliminate all reference             CompC  712
c ??? DetachNode and DetachFromList not debugged yet                            CompC  713
        CALL DetachFromList(0, Jcp)                                             CompC  714
        CALL DetachNode(<cp;SuctionNode>)                                       CompC  715
        CALL DetachNode(<cp;DischargeNode>)                                     CompC  716
        CALL DetachNode(<cp:ELEC-METER>)                                        CompC  717
        CALL DetachNode(<cp:AUX-METER>)                                         CompC  718
        Jnext     = <cp;Next>                                                   CompC  719
        Jprevious = <cp;Previous>                                               CompC  720
        Jdetach   = Jcp                                                         CompC  721
        IF (Jnext .GT. 0)  THEN                                                 CompC  722
          IF (Jprevious .GT. 0)  THEN                                           CompC  723
c              cut this component out of the chain                              CompC  724
            Jcp           = Jprevious                                           CompC  725
            <cp;Next>     = Jnext                                               CompC  726
            Jcp           = Jnext                                               CompC  727
            <cp;Previous> = Jprevious                                           CompC  728
          ELSE                                                                  CompC  729
c              this component at beginning of chain                             CompC  730
            Icp           = Jnext                                               CompC  731
            Jcp           = Jnext                                               CompC  732
            <cp;Previous> = 0                                                   CompC  733
          ENDIF                                                                 CompC  734
        ELSEIF (Jprevious .GT. 0)  THEN                                         CompC  735
c              this block at end of chain                                       CompC  736
          Jcp       = Jprevious                                                 CompC  737
          <cp;Next> = 0                                                         CompC  738
        ELSE                                                                    CompC  739
c              this is the only component                                       CompC  740
          Icp = 0                                                               CompC  741
        ENDIF                                                                   CompC  742
        Ncp = Ncp - 1                                                           CompC  743
        Jcp = Jdetach                                                           CompC  744
c                                                                               CompC  745
c              Histories                                                        CompC  746
      CASE (208)                                                                CompC  747
        Jrs = <cp:/RefgSystem/>                                                 CompC  748
        Jsg = <cp:SUCTION-GROUP>                                                CompC  749
c              List of compressor kW and discharge Xnodes                       CompC  750
        Kli = 0                                                                 CompC  751
        CALL ListAdd(Kli, <cp:ELEC-METER>  )                                    CompC  752
        CALL ListAdd(Kli, <cp:AUX-METER>   )                                    CompC  753
        CALL ListAdd(Kli, <cp;DischargeNode>)                                   CompC  754
        KliX = Kli                                                              CompC  755
        CALL ListXNodes(Kli, KliX)                                              CompC  756
        <cp;DischargeHsty> = NewHistory(Jrs,Jsg,Jcp, KliX, Kro,                 CompC  757
     &                         0, 0, 1.5,                                       CompC  758
     &                         <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,               CompC  759
     &                         <#ro.Houtlet>,    <sp:ERROR-H>, 1,               CompC  760
     &                         0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                  CompC  761
c                                                                               CompC  762
c              Dump pointers                                                    CompC  763
      CASE (210)                                                                CompC  764
        IF (<cp;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         CompC  765
        WRITE (IOUTPT, 9202)  (<cp:NAME>,II=1,8),                               CompC  766
     &    Jcp, Kri, Kro, Kcs, <cp:ELEC-METER>, <cp:AUX-METER>                   CompC  767
c                                                                               CompC  768
c                                                                               CompC  769
      END SELECT  ! Mode                                                        CompC  770
c                                                                               CompC  771
      RETURN                                                                    CompC  772
c                                                                               CompC  773
c              Message formats                                                  CompC  774
 9001 FORMAT(                                                                   CompC  775
     &14x,'Compressor: ',8A4,' has no matching'                        /        CompC  776
     &14x,'performance data for the refrigerant in the attached'       /        CompC  777
     &14x,'suction circuit.  Performance will default to the first set'/        CompC  778
     &14x,'of refrigerant data. '                                      )        CompC  779
 9002 FORMAT(                                                                   CompC  780
     &14x,'Compressor: ',8A4,' has an unrealistic'                     /        CompC  781
     &14x,'coefficient of performance (COP) of:',F15.3,'; the ideal'   /        CompC  782
     &14x,'COP is:'F8.3,' when SST&SDT=',2F6.1,'. Check flow vs. power'/        CompC  783
     &14x,'input for consistency, and/or the design SST & SDT.'        )        CompC  784
 9003 FORMAT(                                                                   CompC  785
     &14x,'Compressor: ',8A4,' has a design'                           /        CompC  786
     &14x,'coefficient of performance (COP) of:',F15.3,'; the ideal'   /        CompC  787
     &14x,'COP is:'F7.3,'. Check flow vs. power input for consistency.')        CompC  788
 9004 FORMAT(                                                                   CompC  789
     &14x,'Compressor: ',8A4,' will consume no power.'                 )        CompC  790
 9005 FORMAT(                                                                   CompC  791
     &14x,'Compressor: ',8A4,' must have a'                            /        CompC  792
     &14x,'MAX-CTRL-SIGNAL greater than the MIN-CTRL-SIGNAL.'          )        CompC  793
 9006 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompC  794
     &14x,'for the capacity curve at design conditions. Check curve'   /        CompC  795
     &14x,'coefficients and/or other input.'                           )        CompC  796
 9007 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompC  797
     &14x,'for the capacity curve at rated conditions. Check curve'    /        CompC  798
     &14x,'coefficients and/or other input.'                           )        CompC  799
 9008 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompC  800
     &14x,'for the power curve at design conditions. Check curve'      /        CompC  801
     &14x,'coefficients and/or other input.'                           )        CompC  802
 9009 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompC  803
     &14x,'for the power curve at rated conditions. Check curve'       /        CompC  804
     &14x,'coefficients and/or other input.'                           )        CompC  805
 9010 Format(14x,'Compressor: ',8A4,' must have a'                     /        CompC  806
     &14x,'RATED-SST lower than the RATED-SDT.  SST/SDT= ',2F6.1       )        CompC  807
 9011 Format(14x,'Compressor: ',8A4,' has a design SST'                /        CompC  808
     &14x,'less than 5F colder than the SDT.  SST/SDT= ',2F6.1         )        CompC  809
 9201 FORMAT(/' COMPRESSORs                            Jcp       Kri',          CompC  810
     &'       Kro      Ctrl      Elec       Aux'                       /        CompC  811
     &1x,32('-'),6('  --------'))                                               CompC  812
 9202 FORMAT(1x,8A4,6I10)                                                       CompC  813
      END                                                                       CompC  814
      SUBROUTINE Compressor_HermeticRecip(Mode, Jcp)                            CompH    2
c                                                                               CompH    3
c              Simulates a hermetic or semi-hermetic reciprocating              CompH    4
c              compressor.                                                      CompH    5
c                                                                               CompH    6
c              Mode = 0-9  Attachment calculations                              CompH    7
c                      10  Design                                               CompH    8
c                      21  Hourly capacity                                      CompH    9
c                      32  Hourly initialization                                CompH   10
c                      33  Hourly performance within a bin                      CompH   11
c                      39  End of hour reconciliation                           CompH   12
c                                                                               CompH   13
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               CompH   22
      INTEGER Xri, Xro, rH                                                      CompH   23
      REAL    Mcap                                                              CompH   24
c                                                                               CompH   25
c              Compressor inlet node, and inlet and outlet nodes                CompH   26
c              of the attached suction group and discharge                      CompH   27
      Kri = <cp;SuctionNode>             ! refrigerant inlet                    CompH   28
      Xri = <ri;Xnode>                   ! node'd inlet                         CompH   29
      Kro = <cp;DischargeNode>           ! refrigerant outlet                   CompH   30
      Xro = <ro;Xnode>                   ! node'd outlet                        CompH   31
      Kcs = <cp;CtrlNode>                ! control block                        CompH   32
      Jre = <cp;Refrigerant>             ! refrigerant                          CompH   33
c                                                                               CompH   34
      SELECT CASE (Mode)                                                        CompH   35
c                                                                               CompH   36
c                                                                               CompH   37
c ============ HOURLY INITIALIZATION ========================================== CompH   38
      CASE (10)                                                                 CompH   39
c                                                                               CompH   40
c                                                                               CompH   41
c ============ HOURLY OPERATING CAPACITY ====================================== CompH   42
      CASE (21)                                                                 CompH   43
c                                                                               CompH   44
c              Inlet superheat                                                  CompH   45
      HinletMin = RefgH_Vapor_fT(Jre, <Xri.Tsetpt>)                             CompH   46
      IF (HinletMin .LT. <Xri.Hinlet>)  THEN                                    CompH   47
        dTsuper = RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>)                CompH   48
      ELSE                                                                      CompH   49
        dTsuper = 0.                                                            CompH   50
      ENDIF                                                                     CompH   51
c              saturated discharge temperature                                  CompH   52
      SDT = RefgT_fP(Jre, <Xro.Poutlet>)                                        CompH   53
c                                                                               CompH   54
c              Capacity at suction group condition                              CompH   55
      <ri.MaxMrefg> = <cp;NormalCap>                                            CompH   56
     &              * Curve(Jcp, <cp:CAP-FSST&SDT>, <Xri.Tsetpt>, SDT)          CompH   57
     &              * Curve(Jcp, <cp:CAP-FSUPERHEA>, dTsuper, dTsuper)          CompH   58
c                                                                               CompH   59
c              Adjust operating capacity for compressor control mechanism       CompH   60
      SELECT CASE (<cp:CAPACITY-CTRL>)                                          CompH   61
      CASE (0)  ! No capacity control                                           CompH   62
c                                                                               CompH   63
      CASE (1)  ! Internal temperature setpoint                                 CompH   64
        CtrlSignal = (<Xri.Tsetpt>-<cp:INT-SETPT-T>) * <cp;1/Throttle>          CompH   65
     &             + 0.5                                                        CompH   66
        CtrlSignal = MIN(1., MAX(0., CtrlSignal))                               CompH   67
        <ri.MaxMrefg> = <ri.MaxMrefg>                                           CompH   68
     &                * (<cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal)          CompH   69
c                                                                               CompH   70
      CASE (2)  ! External control signal                                       CompH   71
        IF (<cs.KnxModulate> .eq. 0 .or. <cs.KnxModulate> .eq. Kri) THEN        CompH   72
c              this compressor can modulate                                     CompH   73
          CtrlSignal = (<cs.CtrlSignal>-<cp:MIN-SIGNAL>)*<cp;1/Throttle>        CompH   74
          CtrlSignal = MIN(1., MAX(0., CtrlSignal))                             CompH   75
          <ri.MaxMrefg> = <ri.MaxMrefg>                                         CompH   76
     &                  * (<cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal)        CompH   77
        ENDIF                                                                   CompH   78
      END SELECT  ! cp:CAPACITY-CTRL                                            CompH   79
c                                                                               CompH   80
c                                                                               CompH   81
c ============ HOURLY SIMULATION - INITIALIZE BIN TOTALS ====================== CompH   82
      CASE (32)                                                                 CompH   83
c                                                                               CompH   84
      <ro.RunFrac>  = 0.                                                        CompH   85
      <cp;PLR>      = 0.                                                        CompH   86
      <cp;CompKW>   = 0.                                                        CompH   87
      <ri.Minlet>   = 0.                                                        CompH   88
c                                                                               CompH   89
c                                                                               CompH   90
c ============ HOURLY SIMULATION - PERFORMANCE WITHIN A BIN =================== CompH   91
      CASE (33)                                                                 CompH   92
c                                                                               CompH   93
c              Inlet superheat                                                  CompH   94
      HinletMin = RefgH_Vapor_fT(Jre, <Xri.Tsetpt>)                             CompH   95
      IF (HinletMin .LT. <Xri.Hinlet>)  THEN                                    CompH   96
        dTsuper = RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>)                CompH   97
      ELSE                                                                      CompH   98
        dTsuper = 0.                                                            CompH   99
      ENDIF                                                                     CompH  100
c              saturated discharge temperature                                  CompH  101
      SDT = RefgT_fP(Jre, <Xro.Poutlet>)                                        CompH  102
c                                                                               CompH  103
c              Capacity at suction group condition                              CompH  104
      Mcap = <cp;NormalCap>                                                     CompH  105
     &     * Curve(Jcp, <cp:CAP-FSST&SDT>, <Xri.Tsetpt>, SDT)                   CompH  106
     &     * Curve(Jcp, <cp:CAP-FSUPERHEA>, dTsuper, dTsuper)                   CompH  107
c                                                                               CompH  108
c              Adjust operating capacity for compressor control mechanism       CompH  109
      SELECT CASE (<cp:CAPACITY-CTRL>)                                          CompH  110
      CASE (0)  ! No capacity control                                           CompH  111
        PLR = 1.0                                                               CompH  112
      CASE (1)  ! Internal temperature setpoint                                 CompH  113
        CtrlSignal = (<Xri.Tsetpt>-<cp:INT-SETPT-T>) * <cp;1/Throttle>          CompH  114
     &             + 0.5                                                        CompH  115
        CtrlSignal = MIN(1., MAX(0., CtrlSignal))                               CompH  116
        PLR = <cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal                      CompH  117
c                                                                               CompH  118
      CASE (2)  ! External control signal                                       CompH  119
        IF (<cs.KnxModulate> .eq. 0 .or. <cs.KnxModulate> .eq. Kri) THEN        CompH  120
c              this compressor can modulate                                     CompH  121
          CtrlSignal = (<cs.CtrlSignal>-<cp:MIN-SIGNAL>)*<cp;1/Throttle>        CompH  122
          CtrlSignal = MIN(1., MAX(0., CtrlSignal))                             CompH  123
          PLR        = <cp:MIN-CAPACITY> + <cp;CapRange>*CtrlSignal             CompH  124
        ELSE  ! not allowed to modulate                                         CompH  125
          PLR        = 1.0                                                      CompH  126
        ENDIF                                                                   CompH  127
      END SELECT  ! cp:CAPACITY-CTRL                                            CompH  128
c              Refrigerant moved by compressor                                  CompH  129
      <ri.Minlet> = <ri.Minlet> + Mcap*PLR*<cs.RunFrac>                         CompH  130
c                                                                               CompH  131
c              Compressor power consumption                                     CompH  132
      Jcv = <cp:PWR-FSST&SDT>                                                   CompH  133
      IF (<cv:TYPE> .eq. 21)  THEN                                              CompH  134
c              power curve yields COP                                           CompH  135
        Qrfg   = Mcap * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))                     CompH  136
        COP    = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                             CompH  137
        CompKW = <cp;NormalKW> * Qrfg/COP                                       CompH  138
     &         * Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, x)                     CompH  139
     &         * Curve(Jcp, <cp:PWR-FPLR>, PLR, PLR)                            CompH  140
     &         * <cs.RunFrac>                                                   CompH  141
      ELSE                                                                      CompH  142
c              power curve yields kW                                            CompH  143
        CompKW = <cp;NormalKW>                                                  CompH  144
     &         * Curve(Jcp, <cp:PWR-FSST&SDT>, <Xri.Tsetpt>, SDT)               CompH  145
     &         * Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, dTsuper)               CompH  146
     &         * Curve(Jcp, <cp:PWR-FPLR>, PLR, PLR)                            CompH  147
     &         * <cs.RunFrac>                                                   CompH  148
      ENDIF                                                                     CompH  149
      <cp;CompKW> = <cp;CompKW> + CompKW                                        CompH  150
                                                                                CompH  151
c                                                                               CompH  152
c              Weight by the fraction of hour this bin is active, and           CompH  153
c              sum across all bins                                              CompH  154
      <ro.RunFrac> = <ro.RunFrac> + <cs.RunFrac>                                CompH  155
      <cp;PLR>     = <cp;PLR>     + <cs.RunFrac> * PLR                          CompH  156
c                                                                               CompH  157
c                                                                               CompH  158
c ============ HOURLY SIMULATION - END OF HOUR RECONCILIATION ================= CompH  159
      CASE (38:39)                                                              CompH  160
c                                                                               CompH  161
c              Adjust inlet mass flow rate and power so that refrigerant        CompH  162
c              is conserved                                                     CompH  163
      <ri.Minlet> = <ri.Minlet> * <cs.Adjustment>                               CompH  164
      <cp;CompKW> = <cp;CompKW> * <cs.Adjustment>                               CompH  165
      <cp;PLR>    = <cp;PLR>    * <cs.Adjustment>                               CompH  166
      <ri.Qinlet> = <ri.Minlet> * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))           CompH  167
c                                                                               CompH  168
c              Outlet conditions                                                CompH  169
      <ro.Qoutlet> = <ri.Qinlet> + <cp;CompKW>*BtuKW                            CompH  170
      <ro.Moutlet> = <ri.Minlet>                                                CompH  171
      <ro.Mreqd>   = <ri.Minlet>                                                CompH  172
      IF (<ro.Moutlet> .GT. 0.)                                                 CompH  173
     &  <ro.Houtlet> = <Xri.Hinlet> + (<cp;CompKW>*BtuKW/<ro.Moutlet>)          CompH  174
c                                                                               CompH  175
c              Power consumption                                                CompH  176
      Kmd       = <cp:ELEC-METER>                                               CompH  177
      <md.Elec> = <cp;CompKW>                                                   CompH  178
c                                                                               CompH  179
c             Auxiliary power                                                   CompH  180
      IF (<cp:AUX-KW> .GT. 0.)  THEN                                            CompH  181
        Kmd = <cp:AUX-METER>                                                    CompH  182
        SELECT CASE (<cp:AUX-MODE>)                                             CompH  183
          CASE (1)  ! Always                                                    CompH  184
            <md.Elec> = <cp:AUX-KW>                                             CompH  185
          CASE (2)  ! When on                                                   CompH  186
            <md.Elec> = <cp:AUX-KW> * <ro.RunFrac>                              CompH  187
          CASE (3)  ! When off                                                  CompH  188
            <md.Elec> = <cp:AUX-KW> * (1.0 - <ro.RunFrac>)                      CompH  189
          CASE (4)  ! Scheduled                                                 CompH  190
            <md.Elec> = <cp:AUX-KW> * SchVal(<cp:AUX-SCH>)                      CompH  191
        END SELECT                                                              CompH  192
      ENDIF                                                                     CompH  193
c                                                                               CompH  194
c              Check for convergence and clear local iteration flags            CompH  195
      IF (Mode .EQ. 38)  THEN                                                   CompH  196
        CALL CnvgCheck(1, <cp;DischargeHsty>)  ! Loads to Plant                 CompH  197
      ELSE                                                                      CompH  198
        CALL CnvgCheck(0, <cp;DischargeHsty>)                                   CompH  199
      ENDIF                                                                     CompH  200
c                                                                               CompH  201
c                                                                               CompH  202
c ============ REPORT CREATION ================================================ CompH  203
      CASE (50)                                                                 CompH  204
c                                                                               CompH  205
c              statistics blocks                                                CompH  206
      Ks2Load    = NewStat2(Kri, <+ri.Qinlet>, 0, 1.)                           CompH  207
      Ks2Flow    = NewStat2(Kri, <+ri.Minlet>, 0, 1.)                           CompH  208
      Ks2Elec    = NewStat2(<cp:ELEC-METER>, <+md.Elec>, 0, 1.)                 CompH  209
      Kli        = 0                                                            CompH  210
      CALL ListNodes(Kli, 0,0,Jcp,0, 11,2)                                      CompH  211
      Ks2ElecT   = NewStat2(Kli,   <+md.Elec>, 0, 1.)                           CompH  212
      Ks5FlowBin = NewStat5(Kri, <+ri.Minlet>, 0, 1.)                           CompH  213
      Ks5ElecBin = NewStat5(Kli,   <+md.Elec>, 0, 1.)                           CompH  214
c                                                                               CompH  215
c              Create the type "H" report                                       CompH  216
      IF (<cp:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      CompH  217
     &  <cp;PS-H> = NewReport_H(Jcp, 131,                                       CompH  218
     &                          4, 5, 6,                                        CompH  219
     &                          Ks2Load, Ks2Flow, Ks2Elec, Ks2ElecT,            CompH  220
     &                          Ks5FlowBin, Ks5Elecbin, 0,                      CompH  221
     &                          0, 0, 0)                                        CompH  222
c                                                                               CompH  223
c                                                                               CompH  224
c ============ REPORT ORDER =================================================== CompH  225
      CASE (52)                                                                 CompH  226
c                                                                               CompH  227
      Call Report_H(Mode, <cp;PS-H>)                                            CompH  228
c                                                                               CompH  229
c                                                                               CompH  230
c ============ REPORTS - VERIFICATION DATA ==================================== CompH  231
      CASE (54)                                                                 CompH  232
c                                                                               CompH  233
c              Output design information                                        CompH  234
      IF (<cp;PS-H> .ne. 0)  THEN                                               CompH  235
        rH  = <cp;PS-H>                                                         CompH  236
        Kmd = <cp:ELEC-METER>                                                   CompH  237
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       CompH  238
        CALL GetAttachments(Jcp, 2)                                             CompH  239
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   CompH  240
     &    (NameAttachments(II,1,1),II=1,8),                                     CompH  241
     &    (NameAttachments(II,1,2),II=1,8),                                     CompH  242
     &    <cp;Capacity>,<md.Elec>,<Xri.Tsetpt>,                                 CompH  243
     &    RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>),                       CompH  244
     &    RefgT_fP(Jre, <Xro.Poutlet>)                                          CompH  245
        DO  Irow=2,NumRowsOfAttachments                                         CompH  246
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 CompH  247
     &      (NameAttachments(II,Irow,1),II=1,8),                                CompH  248
     &      (NameAttachments(II,Irow,2),II=1,8)                                 CompH  249
        ENDDO                                                                   CompH  250
      ENDIF                                                                     CompH  251
c                                                                               CompH  252
c                                                                               CompH  253
c ============ HOURLY REPORTS - HOURLY DATA =================================== CompH  254
      CASE (62)                                                                 CompH  255
c                                                                               CompH  256
c              Hourly-report variables                                          CompH  257
      IF (<cp;HourRepBuf> .EQ. 0)  RETURN                                       CompH  258
c                                                                               CompH  259
c              get suction group inlet node for average conditions              CompH  260
      Jsg = <cp:SUCTION-GROUP>                                                  CompH  261
      Krx = <sg;SuctionNode>                                                    CompH  262
c                                                                               CompH  263
      IAptr        = <cp;HourRepBuf> - 1                                        CompH  264
      AA(IAptr+1)  = <ri.Qinlet>                                                CompH  265
      AA(IAptr+2)  = <ri.Minlet>                                                CompH  266
      Kmd          = <cp:ELEC-METER>                                            CompH  267
      AA(IAptr+3)  = <md.Elec>                                                  CompH  268
      Kmd          = <cp:AUX-METER>                                             CompH  269
      IF (Kmd .GT. 0)  AA(IAptr+4)  = <md.Elec>                                 CompH  270
      AA(IAptr+5)  = <ro.RunFrac>                                               CompH  271
      AA(IAptr+6)  = RefgT_fP(Jre, <rx.Prefg>)                                  CompH  272
      AA(IAptr+7)  = RefgSuper_fPH(Jre, <rx.Prefg>, <rx.Hrefg>)                 CompH  273
      AA(IAptr+8)  = <rx.Prefg>                                                 CompH  274
      AA(IAptr+9)  = <rx.Hrefg>                                                 CompH  275
      AA(IAptr+10) = <ro.Qoutlet>                                               CompH  276
      AA(IAptr+11) = RefgT_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                CompH  277
      AA(IAptr+12) = RefgT_fP(Jre, <Xro.Poutlet>)                               CompH  278
      AA(IAptr+13) = <ro.Houtlet>                                               CompH  279
      IF (<ro.RunFrac> .GT. 0.)  THEN                                           CompH  280
        AA(IAptr+14) = <cp;PLR> / <ro.RunFrac>                                  CompH  281
      ELSE                                                                      CompH  282
        AA(IAptr+14) = 0.                                                       CompH  283
      ENDIF                                                                     CompH  284
c                                                                               CompH  285
c                                                                               CompH  286
c ============ DESIGN CALCULATIONS - INITIALIZATION =========================== CompH  287
      CASE (110)                                                                CompH  288
c                                                                               CompH  289
c              set minimum allowable discharge pressure                         CompH  290
      <ro.Preqd> = -88888.                                                      CompH  291
                                                                                CompH  292
c              Check for valid RATED-SST & RATED-SDT                            CompH  293
      IF (<cp:CAPACITY> .gt. 0.  .or.  <cp:POWER-RATIO> .gt. 0.  .or.           CompH  294
     &    <cp:POWER> .gt. 0.  .or.  <cp:COEF-OF-PERFO> .gt. 0.) THEN            CompH  295
        IF (<cp:RATED-SST> .ge. <cp:RATED-SDT>) THEN                            CompH  296
          Call MSGSIM(-1,II,II,II,II)                                           CompH  297
          Write (IOUTPT, 9010) (<cp:NAME>,II=1,8),                              CompH  298
     &                          <cp:RATED-SST>, <cp:RATED-SDT>                  CompH  299
          Call MessageBox( NULL,                                                CompH  300
     &      'Compressor RATED-SST > RATED-SDT'//char(0),                        CompH  301
     &      'COMPRESSOR Errors'//char(0),                                       CompH  302
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompH  303
          IwinReturn = 1                                                        CompH  304
          Return                                                                CompH  305
        ENDIF                                                                   CompH  306
      ELSE                                                                      CompH  307
        <cp:RATED-SST> = UNFILD                                                 CompH  308
        <cp:RATED-SDT> = UNFILD                                                 CompH  309
      ENDIF                                                                     CompH  310
c              Set up the control                                               CompH  311
      SELECT CASE (<cp:CAPACITY-CTRL>)                                          CompH  312
        CASE (0)  ! No capacity control                                         CompH  313
c                                                                               CompH  314
        CASE (1)  ! Internal temperature setpoint                               CompH  315
          <cp;1/Throttle> = 1.0 / <cp:INT-THROTTLE>                             CompH  316
          <cp;CapRange>   = 1.0 - <cp:MIN-CAPACITY>                             CompH  317
c                                                                               CompH  318
        CASE (2)  ! External control signal                                     CompH  319
          IF (<cp:MIN-SIGNAL> .GE. <cp:MAX-SIGNAL>)  THEN                       CompH  320
            CALL MSGSIM(-1,II,II,II,II)                                         CompH  321
            WRITE (IOUTPT, 9005)  (<cp:NAME>,II=1,8)                            CompH  322
            CALL MessageBox( NULL,                                              CompH  323
     &        'Compressor Ctrl signals inverted'//char(0),                      CompH  324
     &        'COMPRESSOR Errors'//char(0),                                     CompH  325
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              CompH  326
            IwinReturn = 1                                                      CompH  327
          ELSE                                                                  CompH  328
            <cp;1/Throttle> = 1./(<cp:MAX-SIGNAL>-<cp:MIN-SIGNAL>)              CompH  329
            <cp;CapRange>   = 1.0 - <cp:MIN-CAPACITY>                           CompH  330
          ENDIF                                                                 CompH  331
      END SELECT  ! cp:CAPACITY-CTRL                                            CompH  332
c                                                                               CompH  333
c                                                                               CompH  334
c ============ DESIGN CALCULATIONS ============================================ CompH  335
      CASE (111)                                                                CompH  336
c                                                                               CompH  337
c              Outlet pressure - If not yet set by downstream, it is            CompH  338
c              probably because compressors are staged. Estimate assuming       CompH  339
c              a downstream condensing temperature of 100F                      CompH  340
      IF (<Xro.Poutlet> .NE. -88888.)  THEN                                     CompH  341
        Poutlet = <Xro.Poutlet>                                                 CompH  342
      ELSE                                                                      CompH  343
        Poutlet = RefgP_fT(Jre, 100.)                                           CompH  344
      ENDIF                                                                     CompH  345
c              Saturated discharge temperature                                  CompH  346
      SDT = RefgT_fP(Jre, Poutlet)                                              CompH  347
c                                                                               CompH  348
c              Inlet superheat                                                  CompH  349
      HinletMin = RefgH_Vapor_fT(Jre, <Xri.Tsetpt>)                             CompH  350
      IF (HinletMin .LT. <Xri.Hinlet>)  THEN                                    CompH  351
        dTsuper = RefgSuper_fTH(Jre, <Xri.Tsetpt>, <Xri.Hinlet>)                CompH  352
      ELSE                                                                      CompH  353
        dTsuper = 0.                                                            CompH  354
      ENDIF                                                                     CompH  355
c                                                                               CompH  356
c              Capacity factors at design and rated conditions                  CompH  357
      Cap_fDesign = Curve(Jcp,<cp:CAP-FSST&SDT>,<Xri.Tsetpt>,SDT)               CompH  358
     &            * Curve(Jcp,<cp:CAP-FSUPERHEA>,dTsuper,x)                     CompH  359
      IF (Cap_fDesign .le. 0.)  THEN                                            CompH  360
        CALL MSGSIM(-1,II,II,II,II)                                             CompH  361
        WRITE (IOUTPT, 9006)  (<cp:NAME>,II=1,8)                                CompH  362
        CALL MessageBox( NULL,                                                  CompH  363
     &    'Compressor capacity curve invalid'//char(0),                         CompH  364
     &    'COMPRESSOR Errors'//char(0),                                         CompH  365
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompH  366
        IwinReturn = 1                                                          CompH  367
        Return                                                                  CompH  368
      ENDIF                                                                     CompH  369
      IF (<cp:RATED-SST> .ne. UNFILD)  THEN                                     CompH  370
        Cap_fRated  = Curve(Jcp,<cp:CAP-FSST&SDT>, <cp:RATED-SST>,              CompH  371
     &                                             <cp:RATED-SDT>)              CompH  372
     &              * Curve(Jcp,<cp:CAP-FSUPERHEA>,<cp:RATED-SUPERHT>,x)        CompH  373
        IF (Cap_fRated .le. 0.)  THEN                                           CompH  374
          CALL MSGSIM(-1,II,II,II,II)                                           CompH  375
          WRITE (IOUTPT, 9007)  (<cp:NAME>,II=1,8)                              CompH  376
          CALL MessageBox( NULL,                                                CompH  377
     &      'Compressor capacity curve invalid'//char(0),                       CompH  378
     &      'COMPRESSOR Errors'//char(0),                                       CompH  379
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompH  380
          IwinReturn = 1                                                        CompH  381
          Return                                                                CompH  382
        ENDIF                                                                   CompH  383
      ENDIF                                                                     CompH  384
c                                                                               CompH  385
c              Capacity, lbs/hr                                                 CompH  386
      Jcv         = <cp:CAP-FSST&SDT>                                           CompH  387
      iCapCrvType = <cv:TYPE>          ! 7=ratio, 14=lbs/hr                     CompH  388
      IF (<cp:CAPACITY> .GT. 0.)  THEN                                          CompH  389
c              user specified capacity at rated conditions                      CompH  390
        <cp;NormalCap> = <cp:CAPACITY> / Cap_fRated                             CompH  391
        <ri.Minlet>    = <cp;NormalCap> * Cap_fDesign                           CompH  392
      ELSEIF (<cp:CAP-RATIO> .GT. 0.)  THEN                                     CompH  393
        <ri.Minlet>    = <Xri.Minlet> * <cp:CAP-RATIO>                          CompH  394
        <cp;NormalCap> = <ri.Minlet> / Cap_fDesign                              CompH  395
      ELSEIF (<cv:TYPE> .EQ. 7)  THEN  ! ratio-fT&T                             CompH  396
c              normalized curve - size equally                                  CompH  397
        Kli = <Xri;Xnode>                                                       CompH  398
        IF (Kli .EQ. Kri)  THEN  ! only one compressor                          CompH  399
          <ri.Minlet> = <Xri.Minlet>                                            CompH  400
        ELSE  ! this compressor is one in a list                                CompH  401
          <ri.Minlet> = <Xri.Minlet> / FLOAT(<li;NumItems>)                     CompH  402
        ENDIF                                                                   CompH  403
        <cp;NormalCap> = <ri.Minlet> / Cap_fDesign                              CompH  404
      ELSE                                                                      CompH  405
c              capacity curve outputs lbs/hr directly                           CompH  406
        <cp;NormalCap> = 1.                                                     CompH  407
        <ri.Minlet>    = Cap_fDesign                                            CompH  408
      ENDIF  ! cp:CAPACITY                                                      CompH  409
c              check for bogus capacity                                         CompH  410
      IF (<cp;NormalCap> .lt. 0.  .or.  <ri.Minlet> .lt. 0.)  THEN              CompH  411
        CALL MSGSIM(-1,II,II,II,II)                                             CompH  412
        WRITE (IOUTPT, 9006)  (<cp:NAME>,II=1,8)                                CompH  413
        CALL MessageBox( NULL,                                                  CompH  414
     &    'Compressor capacity curve invalid'//char(0),                         CompH  415
     &    'COMPRESSOR Errors'//char(0),                                         CompH  416
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompH  417
        IwinReturn = 1                                                          CompH  418
        Return                                                                  CompH  419
      ENDIF                                                                     CompH  420
c              design capacity and load                                         CompH  421
      <cp;Capacity> = <ri.Minlet>                                               CompH  422
      <ri.Qinlet>   = <ri.Minlet> * (<Xri.Hinlet>-AA(<cp;RefgHrefPtr>))         CompH  423
c              rated capacity and load (may not be specified/required)          CompH  424
      IF (<cp:RATED-SST> .ne. UNFILD) THEN                                      CompH  425
        CapRated = <cp;NormalCap> * Cap_fRated                                  CompH  426
        Hsuction = RefgH_Vapor_fTS(Jre, <cp:RATED-SST>,                         CompH  427
     &                                  <cp:RATED-SUPERHT>)                     CompH  428
        Hcond    = RefgH_Liquid_fT(Jre, <cp:RATED-SDT>)                         CompH  429
        Qrated   = CapRated * (Hsuction-Hcond)                                  CompH  430
      ENDIF                                                                     CompH  431
c                                                                               CompH  432
c              Power factors at design and rated conditions                     CompH  433
      Jcv = <cp:PWR-FSST&SDT>                                                   CompH  434
      IF (<cv:TYPE> .eq. 21)  THEN                                              CompH  435
c              power curve yields COP                                           CompH  436
        COP         = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                        CompH  437
        Pwr_fDesign = <ri.Qinlet>/COP * kWBtu                                   CompH  438
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., x)                          CompH  439
     &              * Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, x)                CompH  440
        IF (Pwr_fDesign .le. 0.)  THEN                                          CompH  441
          CALL MSGSIM(-1,II,II,II,II)                                           CompH  442
          WRITE (IOUTPT, 9008)  (<cp:NAME>,II=1,8)                              CompH  443
          CALL MessageBox( NULL,                                                CompH  444
     &      'Compressor power curve invalid'//char(0),                          CompH  445
     &      'COMPRESSOR Errors'//char(0),                                       CompH  446
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompH  447
          IwinReturn = 1                                                        CompH  448
          Return                                                                CompH  449
        ENDIF                                                                   CompH  450
        IF (<cp:RATED-SST> .ne. UNFILD) THEN                                    CompH  451
          COP        = Curve(Jcp, Jcv, <cp:RATED-SST>, <cp:RATED-SDT>)          CompH  452
          Pwr_fRated = Qrated/COP * kWBtu                                       CompH  453
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., x)                          CompH  454
     &              * Curve(Jcp,<cp:PWR-FSUPERHEA>,<cp:RATED-SUPERHT>,x)        CompH  455
          IF (Pwr_fRated .le. 0.)  THEN                                         CompH  456
            CALL MSGSIM(-1,II,II,II,II)                                         CompH  457
            WRITE (IOUTPT, 9009)  (<cp:NAME>,II=1,8)                            CompH  458
            CALL MessageBox( NULL,                                              CompH  459
     &        'Compressor power curve invalid'//char(0),                        CompH  460
     &        'COMPRESSOR Errors'//char(0),                                     CompH  461
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              CompH  462
            IwinReturn = 1                                                      CompH  463
            Return                                                              CompH  464
          ENDIF                                                                 CompH  465
        ENDIF                                                                   CompH  466
      ELSE                                                                      CompH  467
c              power curve yields kW                                            CompH  468
        Pwr_fDesign = Curve(Jcp, Jcv, <Xri.Tsetpt>, SDT)                        CompH  469
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., x)                          CompH  470
     &              * Curve(Jcp, <cp:PWR-FSUPERHEA>, dTsuper, x)                CompH  471
        IF (Pwr_fDesign .le. 0.)  THEN                                          CompH  472
          CALL MSGSIM(-1,II,II,II,II)                                           CompH  473
          WRITE (IOUTPT, 9008)  (<cp:NAME>,II=1,8)                              CompH  474
          CALL MessageBox( NULL,                                                CompH  475
     &      'Compressor power curve invalid'//char(0),                          CompH  476
     &      'COMPRESSOR Errors'//char(0),                                       CompH  477
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompH  478
          IwinReturn = 1                                                        CompH  479
          Return                                                                CompH  480
        ENDIF                                                                   CompH  481
        IF (<cp:RATED-SST> .ne. UNFILD)  THEN                                   CompH  482
          Pwr_fRated = Curve(Jcp, Jcv, <cp:RATED-SST>, <cp:RATED-SDT>)          CompH  483
     &              * Curve(Jcp, <cp:PWR-FPLR>, 1., x)                          CompH  484
     &              * Curve(Jcp,<cp:PWR-FSUPERHEA>,<cp:RATED-SUPERHT>,x)        CompH  485
          IF (Pwr_fRated .le. 0.)  THEN                                         CompH  486
            CALL MSGSIM(-1,II,II,II,II)                                         CompH  487
            WRITE (IOUTPT, 9009)  (<cp:NAME>,II=1,8)                            CompH  488
            CALL MessageBox( NULL,                                              CompH  489
     &        'Compressor power curve invalid'//char(0),                        CompH  490
     &        'COMPRESSOR Errors'//char(0),                                     CompH  491
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              CompH  492
            IwinReturn = 1                                                      CompH  493
            Return                                                              CompH  494
          ENDIF                                                                 CompH  495
        ENDIF                                                                   CompH  496
      ENDIF                                                                     CompH  497
      IF (<cp:POWER> .GT. 0.)  THEN                                             CompH  498
c              user specified power at rated conditions                         CompH  499
        <cp;NormalKW> = <cp:POWER> / Pwr_fRated                                 CompH  500
      ELSEIF (<cp:POWER-RATIO> .GT. 0.)  THEN                                   CompH  501
c              user specified kW/lb at rated conditions                         CompH  502
        <cp;NormalKW> = CapRated * <cp:POWER-RATIO> / Pwr_fRated                CompH  503
      ELSEIF (<cp:COEF-OF-PERFO> .GT. 0.)  THEN                                 CompH  504
c              user specified the COP at rated conditions                       CompH  505
        <cp;NormalKW> = Qrated/<cp:COEF-OF-PERFO> * kWBtu / Pwr_fRated          CompH  506
      ELSEIF (<cv:TYPE> .eq. 15  .and.  iCapCrvType .eq. 14)   THEN             CompH  507
c              Capacity and power curves output lbs/hr and kW directly          CompH  508
        IF (<cp:CAPACITY> .GT. 0.)  THEN                                        CompH  509
c              user has specified rated capacity; adjust power for              CompH  510
c              rated capacity vs. curve capacity                                CompH  511
          <cp;NormalKW> = <cp:CAPACITY> / Cap_fRated                            CompH  512
        ELSEIF (<cp:CAP-RATIO> .GT. 0.)  THEN                                   CompH  513
c              user has specified design capacity; adjust power for             CompH  514
c              design capacity vs. curve capacity                               CompH  515
          <cp;NormalKW> = <cp;Capacity> / Cap_fDesign                           CompH  516
        ELSE                                                                    CompH  517
c              use capacity lb/hr and power kW curves directly                  CompH  518
          <cp;NormalKW> = 1.                                                    CompH  519
        ENDIF                                                                   CompH  520
      ELSE                                                                      CompH  521
        <cp;NormalKW> = 1.                                                      CompH  522
      ENDIF  ! cp:CAPACITY                                                      CompH  523
      <cp;kW> = <cp;NormalKW> * Pwr_fDesign                                     CompH  524
c              check for bogus power                                            CompH  525
      IF (<cp;kW> .lt. 0.)  THEN                                                CompH  526
        CALL MSGSIM(-1,II,II,II,II)                                             CompH  527
        WRITE (IOUTPT, 9007)  (<cp:NAME>,II=1,8)                                CompH  528
        CALL MessageBox( NULL,                                                  CompH  529
     &    'Compressor capacity curve invalid'//char(0),                         CompH  530
     &    'COMPRESSOR Errors'//char(0),                                         CompH  531
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompH  532
        IwinReturn = 1                                                          CompH  533
        Return                                                                  CompH  534
      ENDIF                                                                     CompH  535
      Kmd          = <cp:ELEC-METER>                                            CompH  536
      <md.Elec>    = <cp;kW>                                                    CompH  537
      <ro.Houtlet> = <Xri.Hinlet> + (<cp;kW> * BtuKW / <ri.Minlet>)             CompH  538
      <ro.Moutlet> = <ri.Minlet>                                                CompH  539
      <ro.Mreqd>   = <ri.Minlet>                                                CompH  540
c                                                                               CompH  541
c              for COP include kW/Btu conversion factor for hourly calc         CompH  542
      IF (<cv:TYPE> .eq. 21)                                                    CompH  543
     &  <cp;NormalKW> = <cp;NormalKW> * kWBtu                                   CompH  544
c                                                                               CompH  545
c              Auxiliary power                                                  CompH  546
      IF (<cp:AUX-METER> .GT. 0.)  THEN                                         CompH  547
        Kmd       = <cp:AUX-METER>                                              CompH  548
        <md.Elec> = <cp:AUX-KW>                                                 CompH  549
      ENDIF                                                                     CompH  550
c                                                                               CompH  551
c                                                                               CompH  552
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== CompH  553
      CASE (119)                                                                CompH  554
                                                                                CompH  555
c              Check if SST & SDT are reasonable                                CompH  556
      SDT = RefgT_fP(Jre, <Xro.Poutlet>)                                        CompH  557
      IF (<Xri.Tsetpt> .gt. SDT-5.) THEN                                        CompH  558
        CALL MSGSIM(-2,II,II,II,II)                                             CompH  559
        WRITE (IOUTPT, 9011)  (<cp:NAME>,II=1,8), <Xri.Tsetpt>, SDT             CompH  560
        CALL MessageBox( NULL,                                                  CompH  561
     &    'Compressor SST & SDT unreasonable'//char(0),                         CompH  562
     &    'COMPRESSOR Errors'//char(0),                                         CompH  563
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  CompH  564
      ENDIF                                                                     CompH  565
                                                                                CompH  566
c              Check if COP is reasonable; ideal COP                            CompH  567
      COPideal = (<Xri.Tsetpt>+460.) / (SDT-<Xri.Tsetpt>)                       CompH  568
      Kmd = <cp:ELEC-METER>                                                     CompH  569
      IF (<md.Elec> .NE. 0.)  THEN                                              CompH  570
        COP = <ri.Qinlet> / (<md.Elec> * BtuKW)                                 CompH  571
        IF (COP .LT. COPideal*0.2 .or.  COP .gt. COPideal) THEN                 CompH  572
          CALL MSGSIM(-2,II,II,II,II)                                           CompH  573
          WRITE (IOUTPT, 9002)  (<cp:NAME>,II=1,8), COP, COPideal,              CompH  574
     &                           <Xri.Tsetpt>, SDT                              CompH  575
          CALL MessageBox( NULL,                                                CompH  576
     &      'Compressor COP unreasonable'//char(0),                             CompH  577
     &      'COMPRESSOR Errors'//char(0),                                       CompH  578
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CompH  579
        ELSEIF (COP .LT. COPideal*0.25 .OR. COP .GT. COPideal*0.75) THEN        CompH  580
          CALL MSGSIM(-3,II,II,II,II)                                           CompH  581
          WRITE (IOUTPT, 9003)  (<cp:NAME>,II=1,8), COP, COPideal               CompH  582
c         CALL MessageBox( NULL,                                                CompH  583
c    &      'Compressor COP unreasonable'//char(0),                             CompH  584
c    &      'COMPRESSOR Errors'//char(0),                                       CompH  585
c    &      MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                         CompH  586
        ENDIF                                                                   CompH  587
      ELSE                                                                      CompH  588
        CALL MSGSIM(-2,II,II,II,II)                                             CompH  589
        WRITE (IOUTPT, 9004)  (<cp:NAME>,II=1,8)                                CompH  590
c       CALL MessageBox( NULL,                                                  CompH  591
c    &    'No compressor power'//char(0),                                       CompH  592
c    &    'COMPRESSOR Errors'//char(0),                                         CompH  593
c    &    MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                           CompH  594
      ENDIF                                                                     CompH  595
c                                                                               CompH  596
      <ri;DesMinlet> = <ri.Minlet>                                              CompH  597
c                                                                               CompH  598
c                                                                               CompH  599
c                                                                               CompH  600
c ============ ATTACHMENTS ==================================================== CompH  601
c                                                                               CompH  602
c              Initial attachments                                              CompH  603
      CASE (201)                                                                CompH  604
c              Component pointers, schedules, and curves                        CompH  605
        <cp:SUCTION-GROUP>  = Jcomponent(25, <cp:SUCTION-GROUP>)                CompH  606
        <cp:DISCHARGE-CKT>  = Jcomponent(22, <cp:DISCHARGE-CKT>)                CompH  607
        <cp:/RefgSystem/>   = Jcomponent(29, <cp:/RefgSystem/>)                 CompH  608
        <cp:ELEC-METER>     = Jcomponent(13, <cp:ELEC-METER>)                   CompH  609
        <cp:AUX-METER>      = Jcomponent(13, <cp:AUX-METER>)                    CompH  610
        <cp:COST-DATA>      = Jcomponent(18, <cp:COST-DATA>)                    CompH  611
        <cp:AUX-SCH>        = Jsched(<cp:AUX-SCH>)                              CompH  612
        <cp:CAP-FSST&SDT>   = Jcurve(<cp:CAP-FSST&SDT>)                         CompH  613
        <cp:CAP-FSUPERHEA>  = Jcurve(<cp:CAP-FSUPERHEA>)                        CompH  614
        <cp:PWR-FSST&SDT>   = Jcurve(<cp:PWR-FSST&SDT>)                         CompH  615
        <cp:PWR-FSUPERHEA>  = Jcurve(<cp:PWR-FSUPERHEA>)                        CompH  616
        <cp:PWR-FPLR>       = Jcurve(<cp:PWR-FPLR>)                             CompH  617
c                                                                               CompH  618
c              Create nodes                                                     CompH  619
      CASE (203)                                                                CompH  620
        Jrs = <cp:/RefgSystem/>                                                 CompH  621
        Jsg = <cp:SUCTION-GROUP>                                                CompH  622
c              Check for cross connections                                      CompH  623
        CALL RefgX(Jcp, <sg:DISCHARGE-CKT>,                                     CompH  624
     &                             <cp:DISCHARGE-CKT>,0)                        CompH  625
c              Suction and discharge attachmants                                CompH  626
        <cp;SuctionNode>  = NewNode(1, 0,Jsg,Jcp,Jsg, 62,1,Jsg, 1.)             CompH  627
        Jrc = <cp:DISCHARGE-CKT>                                                CompH  628
        I   = 60 + <rc:TYPE>                                                    CompH  629
        <cp;DischargeNode> = NewNode(1, Jrs,Jsg,Jcp,Jrc, I,2,Jsg, 1.)           CompH  630
c              Electric and auxiliary meters                                    CompH  631
        IF (<cp:ELEC-METER> .GT. 0)  THEN                                       CompH  632
          Jme = <cp:ELEC-METER>                                                 CompH  633
          <cp:ELEC-METER> = NewNode(1, Jrs,Jsg,Jcp,Jme, 11,2,Jsg, 1.)           CompH  634
        ENDIF                                                                   CompH  635
        IF (<cp:AUX-METER> .GT. 0)  THEN                                        CompH  636
          Jme = <cp:AUX-METER>                                                  CompH  637
          <cp:AUX-METER> = NewNode(1, Jrs,Jsg,Jcp,Jme, 11,2,Jsg, 1.)            CompH  638
        ENDIF                                                                   CompH  639
c                                                                               CompH  640
c              Links, lists                                                     CompH  641
      CASE (205)                                                                CompH  642
c              Get refrigerant pointer from refg plant                          CompH  643
        Jrs              = <cp:/RefgSystem/>                                    CompH  644
        <cp;Refrigerant> = <rs:REFRIGERANT>                                     CompH  645
c              Get pointer to reference enthalpy from liquid trunk              CompH  646
        <cp;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     CompH  647
c                                                                               CompH  648
c              Find the suction group's control block                           CompH  649
        <cp;CtrlNode> = LocateNode(0,0,<cp:SUCTION-GROUP>,0, 21,1)              CompH  650
c                                                                               CompH  651
c              Detach this component                                            CompH  652
      CASE (207)                                                                CompH  653
c              Component will not be used - eliminate all reference             CompH  654
c ??? DetachNode and DetachFromList not debugged yet                            CompH  655
        CALL DetachFromList(0, Jcp)                                             CompH  656
        CALL DetachNode(<cp;SuctionNode>)                                       CompH  657
        CALL DetachNode(<cp;DischargeNode>)                                     CompH  658
        CALL DetachNode(<cp:ELEC-METER>)                                        CompH  659
        CALL DetachNode(<cp:AUX-METER>)                                         CompH  660
        Jnext     = <cp;Next>                                                   CompH  661
        Jprevious = <cp;Previous>                                               CompH  662
        Jdetach   = Jcp                                                         CompH  663
        IF (Jnext .GT. 0)  THEN                                                 CompH  664
          IF (Jprevious .GT. 0)  THEN                                           CompH  665
c              cut this component out of the chain                              CompH  666
            Jcp           = Jprevious                                           CompH  667
            <cp;Next>     = Jnext                                               CompH  668
            Jcp           = Jnext                                               CompH  669
            <cp;Previous> = Jprevious                                           CompH  670
          ELSE                                                                  CompH  671
c              this component at beginning of chain                             CompH  672
            Icp           = Jnext                                               CompH  673
            Jcp           = Jnext                                               CompH  674
            <cp;Previous> = 0                                                   CompH  675
          ENDIF                                                                 CompH  676
        ELSEIF (Jprevious .GT. 0)  THEN                                         CompH  677
c              this block at end of chain                                       CompH  678
          Jcp       = Jprevious                                                 CompH  679
          <cp;Next> = 0                                                         CompH  680
        ELSE                                                                    CompH  681
c              this is the only component                                       CompH  682
          Icp = 0                                                               CompH  683
        ENDIF                                                                   CompH  684
        Ncp = Ncp - 1                                                           CompH  685
        Jcp = Jdetach                                                           CompH  686
c                                                                               CompH  687
c              Histories                                                        CompH  688
      CASE (208)                                                                CompH  689
        Jrs = <cp:/RefgSystem/>                                                 CompH  690
        Jsg = <cp:SUCTION-GROUP>                                                CompH  691
c              List of compressor kW and discharge Xnodes                       CompH  692
        Kli = 0                                                                 CompH  693
        CALL ListAdd(Kli, <cp:ELEC-METER>  )                                    CompH  694
        CALL ListAdd(Kli, <cp:AUX-METER>   )                                    CompH  695
        CALL ListAdd(Kli, <cp;DischargeNode>)                                   CompH  696
        KliX = Kli                                                              CompH  697
        CALL ListXNodes(Kli, KliX)                                              CompH  698
        <cp;DischargeHsty> = NewHistory(Jrs,Jsg,Jcp, KliX, Kro,                 CompH  699
     &                         0, 0, 1.5,                                       CompH  700
     &                         <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,               CompH  701
     &                         <#ro.Houtlet>,    <sp:ERROR-H>, 1,               CompH  702
     &                         0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                  CompH  703
c                                                                               CompH  704
c              Dump pointers                                                    CompH  705
      CASE (210)                                                                CompH  706
        IF (<cp;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         CompH  707
        WRITE (IOUTPT, 9202)  (<cp:NAME>,II=1,8),                               CompH  708
     &    Jcp, Kri, Kro, Kcs, <cp:ELEC-METER>, <cp:AUX-METER>                   CompH  709
c                                                                               CompH  710
c                                                                               CompH  711
      END SELECT  ! Mode                                                        CompH  712
c                                                                               CompH  713
      RETURN                                                                    CompH  714
c                                                                               CompH  715
c              Message formats                                                  CompH  716
 9001 FORMAT(                                                                   CompH  717
     &14x,'Compressor: ',8A4,' has no matching'                        /        CompH  718
     &14x,'performance data for the refrigerant in the attached'       /        CompH  719
     &14x,'suction circuit.  Performance will default to the first set'/        CompH  720
     &14x,'of refrigerant data. '                                      )        CompH  721
 9002 FORMAT(                                                                   CompH  722
     &14x,'Compressor: ',8A4,' has an unrealistic'                     /        CompH  723
     &14x,'coefficient of performance (COP) of:',F15.3,'; the ideal'   /        CompH  724
     &14x,'COP is:'F8.3,' when SST&SDT=',2F6.1,'. Check flow vs. power'/        CompH  725
     &14x,'input for consistency, and/or the design SST & SDT.'        )        CompH  726
 9003 FORMAT(                                                                   CompH  727
     &14x,'Compressor: ',8A4,' has a design'                           /        CompH  728
     &14x,'coefficient of performance (COP) of:',F15.3,'; the ideal'   /        CompH  729
     &14x,'COP is:'F7.3,'. Check flow vs. power input for consistency.')        CompH  730
 9004 FORMAT(                                                                   CompH  731
     &14x,'Compressor: ',8A4,' will consume no power.'                 )        CompH  732
 9005 FORMAT(                                                                   CompH  733
     &14x,'Compressor: ',8A4,' must have a'                            /        CompH  734
     &14x,'MAX-CTRL-SIGNAL greater than the MIN-CTRL-SIGNAL.'          )        CompH  735
 9006 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompH  736
     &14x,'for the capacity curve at design conditions. Check curve'   /        CompH  737
     &14x,'coefficients and/or other input.'                           )        CompH  738
 9007 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompH  739
     &14x,'for the capacity curve at rated conditions. Check curve'    /        CompH  740
     &14x,'coefficients and/or other input.'                           )        CompH  741
 9008 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompH  742
     &14x,'for the power curve at design conditions. Check curve'      /        CompH  743
     &14x,'coefficients and/or other input.'                           )        CompH  744
 9009 FORMAT(14x,'Compressor: ',8A4,' has a negative value'            /        CompH  745
     &14x,'for the power curve at rated conditions. Check curve'       /        CompH  746
     &14x,'coefficients and/or other input.'                           )        CompH  747
 9010 Format(14x,'Compressor: ',8A4,' must have a'                     /        CompH  748
     &14x,'RATED-SST lower than the RATED-SDT.  SST/SDT= ',2F6.1       )        CompH  749
 9011 Format(14x,'Compressor: ',8A4,' has a design SST'                /        CompH  750
     &14x,'less than 5F colder than the SDT.  SST/SDT= ',2F6.1         )        CompH  751
 9201 FORMAT(/' COMPRESSORs                            Jcp       Kri',          CompH  752
     &'       Kro      Ctrl      Elec       Aux'                       /        CompH  753
     &1x,32('-'),6('  --------'))                                               CompH  754
 9202 FORMAT(1x,8A4,6I10)                                                       CompH  755
      END                                                                       CompH  756
C ##############################################################################CndAlg   2
C ##############################################################################CndAlg   3
C ##############################################################################CndAlg   4
C ##############################################################################CndAlg   5
C ##########                                                          ##########CndAlg   6
C ##########                    CONDENSER ROUTINES                    ##########CndAlg   7
C ##########                                                          ##########CndAlg   8
C ##############################################################################CndAlg   9
C ##############################################################################CndAlg  10
C ##############################################################################CndAlg  11
C ##############################################################################CndAlg  12
c                                                                               CndAlg  13
      SUBROUTINE CondenserAlgs(Mode, Knx)                                       CndAlg  14
c                                                                               CndAlg  15
c              Selects the correct condenser simulation algorithm               CndAlg  16
c                                                                               CndAlg  17
c              Knx  Pointer to the component or one if its nodes                CndAlg  18
c                                                                               CndAlg  19
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               CndAlg  22
      DATA IdNode /4H$Kno/                                                      /IdNode/ 2
c                                                                               CndAlg  24
c              Knx may point either to the component or to one of the           CndAlg  25
c              component's nodes                                                CndAlg  26
      IF (<nx;Ident> .EQ. IdNode)  THEN                                         CndAlg  27
        Jna = <nx;Component>                                                    CndAlg  28
      ELSE                                                                      CndAlg  29
        Jna = Knx                                                               CndAlg  30
      ENDIF                                                                     CndAlg  31
c                                                                               CndAlg  32
      SELECT CASE (<na:ALGORITHM>)                                              CndAlg  33
c                                                                               CndAlg  34
        CASE (411)  ! Air-cooled condenser                                      CndAlg  35
          CALL Condenser_Air(Mode, Jna)                                         CndAlg  36
c                                                                               CndAlg  37
        CASE (412)  ! Evaporative condenser                                     CndAlg  38
          CALL Condenser_Evap(Mode, Jna)                                        CndAlg  39
c                                                                               CndAlg  40
        CASE (413)  ! Refg-cooled condenser                                     CndAlg  41
          CALL Condenser_Refg(Mode, Jna)                                        CndAlg  42
c                                                                               CndAlg  43
c ??    CASE (414)  ! Water-cooled condenser                                    CndAlg  44
c         CALL Condenser_Water(Mode, Jna)                                       CndAlg  45
c                                                                               CndAlg  46
      END SELECT                                                                CndAlg  47
c                                                                               CndAlg  48
      RETURN                                                                    CndAlg  49
      END                                                                       CndAlg  50
      SUBROUTINE Condenser_Air(Mode, Jcd)                                       CndAir   2
c                                                                               CndAir   3
c              Simulates a single-circuit air-cooled condenser.                 CndAir   4
c                                                                               CndAir   5
c              This algorithm simplifies the NTU/effectiveness heat-            CndAir   6
c              exchanger calculations by lumping the superheat energy           CndAir   7
c              with the phase-change energy.                                    CndAir   8
c                                                                               CndAir   9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /FNSYS/  ISKIPS, MSYSF(120)                                       /FNSYS/  2
      COMMON  /HXdat / HXerror, HXconfig, HXua, Csup, Cdem, Cmin,               /HXdat/  2
     &                 HXeff, UAeff                                             /HXdat/  3
      INTEGER          HXconfig                                                 /HXdat/  4
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               CndAir  22
      COMMON  /TWRKY / Open, OpenHX, FluidCool,                                 /TWRKY/  2
     &                 Bypass, Speed1, Speed2, SpeedV, Damper,                  /TWRKY/  3
     &                 RunMinCells, RunMaxCells,                                /TWRKY/  4
     &                 ElecPanHtr, NoPanHtr, HWPanHtr,                          /TWRKY/  5
     &                 CycleWithFan, StayOn                                     /TWRKY/  6
      INTEGER          Open, OpenHX, FluidCool,                                 /TWRKY/  7
     &                 Bypass, Speed1, Speed2, SpeedV, Damper,                  /TWRKY/  8
     &                 RunMinCells, RunMaxCells,                                /TWRKY/  9
     &                 ElecPanHtr, NoPanHtr, HWPanHtr,                          /TWRKY/ 10
     &                 CycleWithFan, StayOn                                     /TWRKY/ 11
c                                                                               CndAir  24
      INTEGER  Xri, Xro, rH, FanSpeed, Routine(4)                               CndAir  25
      DATA     Routine /4HCond,4Hense,4Hr_Ai,4Hr   /                            CndAir  26
      SAVE     ErrorMax                                                         CndAir  27
                                                                                CndAir  28
c              Heat rejection for a given SCT, assuming no subcooling           Qsct     2
      Qsct(SCTx) = Max(1., Mcycle                                               Qsct     3
     &                      * (<Xri.Hinlet>-RefgH_Liquid_fT(Jre, SCTx)))        Qsct     4
c                                                                               CndAir  30
c              Inlet and outlet nodes, and their Xfaced circuits                CndAir  31
      Kri = <cd;InletNode>               ! refrigerant inlet                    CndAir  32
      Xri = <ri;Xnode>                   ! refrigerant Xinlet                   CndAir  33
      Kro = <cd;OutletNode>              ! refrigerant outlet                   CndAir  34
      Xro = <ro;Xnode>                   ! refrigerant Xoutlet                  CndAir  35
      Jre = <cd;Refrigerant>             ! refrigerant                          CndAir  36
      Jrs = <cd:REFG-SYSTEM>             ! refrigeration system                 CndAir  37
      Khx = <cd;HX>                      ! HX subcomponent                      CndAir  38
c                                                                               CndAir  39
      SELECT CASE (Mode)                                                        CndAir  40
c                                                                               CndAir  41
c                                                                               CndAir  42
c ============ HOURLY INITIALIZATION ========================================== CndAir  43
      CASE (10)                                                                 CndAir  44
c                                                                               CndAir  45
c              Staged-fan airflow                                               CndAir  46
      SELECT CASE (<rs:SCT-CTRL>)                                               CndAir  47
        CASE (0)  ! Continuous fan                                              CndAir  48
          <cd.StagedCFMr> = 1.                                                  CndAir  49
        CASE (6)  ! Drybulb-staged                                              CndAir  50
          CFMr        = 0.                                                      CndAir  51
          DO  IT=1,<cd;NumFanStages>                                            CndAir  52
            IF (DBT .GE. <cd:FAN-STAGE-T>)  CFMr = CFMr + 1.                    CndAir  53
          ENDDO                                                                 CndAir  54
          <cd.StagedCFMr> = CFMr / <cd;NumFanStages>                            CndAir  55
          <cd.StagedCFMr> = MAX(<cd:FAN-OFF-AIR>, <cd.StagedCFMr>)              CndAir  56
        CASE (7)  ! Wetbulb-staged                                              CndAir  57
          CFMr        = 0.                                                      CndAir  58
          DO  IT=1,<cd;NumFanStages>                                            CndAir  59
            IF (WBT .GE. <cd:FAN-STAGE-T>)  CFMr = CFMr + 1.                    CndAir  60
          ENDDO                                                                 CndAir  61
          <cd.StagedCFMr> = CFMr / <cd;NumFanStages>                            CndAir  62
          <cd.StagedCFMr> = MAX(<cd:FAN-OFF-AIR>, <cd.StagedCFMr>)              CndAir  63
      END SELECT  ! rs:SCT-CTRL                                                 CndAir  64
c                                                                               CndAir  65
c                                                                               CndAir  66
c ============ HOURLY SIMULATION - OPERATING CAPACITY ========================= CndAir  67
      CASE (25)                                                                 CndAir  68
c                                                                               CndAir  69
c              Control fan cfm                                                  CndAir  70
      SELECT CASE (<rs:SCT-CTRL>)                                               CndAir  71
        CASE (6,7) ! Ambient-staged fan                                         CndAir  72
          CFMr = <cd.StagedCFMr>                                                CndAir  73
        CASE DEFAULT                                                            CndAir  74
          CFMr = 1.                                                             CndAir  75
      END SELECT  ! rs:SCT-CTRL                                                 CndAir  76
c                                                                               CndAir  77
c              Setpoint must be greater than drybulb                            CndAir  78
      TDinlets   = MAX(0., <Xro.Treqd> - DBT)                                   CndAir  79
c              Operating capacity                                               CndAir  80
      CapRatio   = CFMr + <cd;CapOff>*(1.-CFMr)                                 CndAir  81
      <cd.OpCap> = <cd;Capacity/TD> * CapRatio * TDinlets                       CndAir  82
c              Ambient subcooling effect                                        CndAir  83
      dTsubcool  = <cd:SUBCOOL-EFF> * TDinlets                                  CndAir  84
c              Enthalpy at setpoint and refrigerant flow                        CndAir  85
      Hsetpt     = RefgH_Liquid_fTS(Jre, <Xro.Treqd>, dTsubcool)                CndAir  86
      <ro.MaxMrefg> = <cd.OpCap> / (<Xri.Hinlet>-Hsetpt)                        CndAir  87
c                                                                               CndAir  88
c                                                                               CndAir  89
c ============ HOURLY SIMULATION - PERFORMANCE ================================ CndAir  90
      CASE (31,32)                                                              CndAir  91
c                                                                               CndAir  92
c              Auxiliary power                                                  CndAir  93
      IF (<cd:AUX-KW> .GT. 0.)  THEN                                            CndAir  94
        SELECT CASE (<cd:AUX-MODE>)                                             CndAir  95
          CASE (1)  ! Always                                                    CndAir  96
            AuxKWh = <cd:AUX-KW>                                                CndAir  97
          CASE (2)  ! When on                                                   CndAir  98
            IF (<ro.Moutlet> .GT. 0.)                                           CndAir  99
     &        AuxKWh = <cd:AUX-KW> * <ro.RunFrac>                               CndAir 100
          CASE (3)  ! When off                                                  CndAir 101
            IF (<ro.Moutlet> .EQ. 0.)                                           CndAir 102
     &        AuxKWh = <cd:AUX-KW> * (1.-<ro.RunFrac>)                          CndAir 103
          CASE (4)  ! Scheduled                                                 CndAir 104
            AuxKWh = <cd:AUX-KW> * SchVal(<cd:AUX-SCH>)                         CndAir 105
        END SELECT                                                              CndAir 106
      ELSE                                                                      CndAir 107
        AuxKWh = 0.                                                             CndAir 108
      ENDIF                                                                     CndAir 109
c                                                                               CndAir 110
c             skip if no load                                                   CndAir 111
      <ri.Minlet> = <ro.Moutlet>                                                CndAir 112
      IF (<ro.Moutlet> .LT. 0.001)  GoTo 3190                                   CndAir 113
c                                                                               CndAir 114
c              Condenser is operating. If cycling, convert hourly               CndAir 115
c              average refrigerant flow to flow when cycled on                  CndAir 116
      Mcycle = <ro.Moutlet> / <ro.RunFrac>                                      CndAir 117
c                                                                               CndAir 118
c              Initialize FanSpeed to last hour's or iteration's mode           CndAir 119
      FanSpeed = <cd.FanSpeed>                                                  CndAir 120
      Tsetpt   = -88888.                                                        CndAir 121
c              in FloatingSCT, use UAstaged if nonzero; otherwise CFMr          CndAir 122
      UAstaged = 0.                                                             CndAir 123
c                                                                               CndAir 124
c              Calculate SCT for non-temperature controlled schemes             CndAir 125
      SELECT CASE (<rs:SCT-CTRL>)                                               CndAir 126
        CASE (0)  ! Always on                                                   CndAir 127
          CFMr   = 1.                                                           CndAir 128
          FankWr = CFMr                                                         CndAir 129
          Call AirFloatingSCT                                                   CndAir 130
          GOTO 3170                                                             CndAir 131
c                                                                               CndAir 132
        CASE (1:5)  ! Temperature setpoint sequences                            CndAir 133
          Tsetpt = <Xro.Treqd>                                                  CndAir 134
c                                                                               CndAir 135
        CASE (6,7)  ! Ambient-staged fan                                        CndAir 136
          CFMr   = <cd.StagedCFMr>                                              CndAir 137
          FankWr = CFMr                                                         CndAir 138
c              effective UA with fan off (for cells not staged on)              CndAir 139
          CALL HX(1, Khx,             xQhx,                                     CndAir 140
     &                    <cd:FAN-OFF-AIR>, xSupTi, xSupTo,                     CndAir 141
     &                              Mcycle, xDemTi, xDemTo)                     CndAir 142
          UAoff = UAeff                                                         CndAir 143
c              effective UA with fan high (for cells staged on)                 CndAir 144
          CALL HX(1, Khx,    Qhx,                                               CndAir 145
     &                        1.,    DBT, xSupTo,                               CndAir 146
     &                    Mcycle, Tsetpt, xDemTo)                               CndAir 147
          UAhi = UAeff                                                          CndAir 148
c              UA at actual fan staging                                         CndAir 149
          UAstaged = CFMr*UAhi + (1.-CFMr)*UAoff                                CndAir 150
          Call AirFloatingSCT                                                   CndAir 151
          GOTO 3170                                                             CndAir 152
c                                                                               CndAir 153
        CASE (8)  ! Load reset                                                  CndAir 154
          SELECT CASE (<cd:CAPACITY-CTRL>)                                      CndAir 155
            CASE (2)  ! 2-speed fan                                             CndAir 156
c                 let float on low speed                                        CndAir 157
              CFMr   = <cd:FAN-LOW-AIR>                                         CndAir 158
              FankWr = <cd:FAN-LOW-PWR>                                         CndAir 159
            CASE (3,4)  ! Variable speed or damper                              CndAir 160
c                 reset based on design load                                    CndAir 161
              PLR    = <Xri.Minlet>/<ro.RunFrac> * <cd;1/Mtotal>                CndAir 162
              PLR    = MAX(<rs:LOAD-MIN-PLR>,                                   CndAir 163
     &                     MIN(<rs:LOAD-MAX-PLR>, PLR))                         CndAir 164
              CFMr   = <rs:LOAD-MIN-AIR>                                        CndAir 165
     &               + (<rs:LOAD-MAX-AIR> - <rs:LOAD-MIN-AIR>)                  CndAir 166
     &               * (PLR-<rs:LOAD-MIN-PLR>)                                  CndAir 167
     &                         /(<rs:LOAD-MAX-PLR>-<rs:LOAD-MIN-PLR>)           CndAir 168
              FankWr = Curve(Jcd,<cd:FAN-KW-fAIR>, CFMr,x)                      CndAir 169
          END SELECT                                                            CndAir 170
          Call AirFloatingSCT                                                   CndAir 171
c              Check if SCT is within range                                     CndAir 172
          IF (<cd.SCT> .LT. <rs.HtRecSetpt>-<rs;Throttle/2>)  THEN              CndAir 173
c              heat-reclaim takes priority                                      CndAir 174
            Tsetpt = <rs.HtRecSetpt>                                            CndAir 175
          ELSEIF (<cd.SCT> .GT. <rs:OVERRIDE-MAX>-<rs;Throttle/2>)  THEN        CndAir 176
c              floating SCT is too hot - control to max temp                    CndAir 177
            Tsetpt = <rs:OVERRIDE-MAX>                                          CndAir 178
          ELSEIF (<cd.SCT> .LT. <rs:OVERRIDE-MIN>+<rs;Throttle/2>)  THEN        CndAir 179
c              floating SCT is too cold - control to min temp                   CndAir 180
            Tsetpt = <rs:OVERRIDE-MIN>                                          CndAir 181
          ELSE                                                                  CndAir 182
c              SCT is within acceptable range                                   CndAir 183
            GOTO 3170                                                           CndAir 184
          ENDIF                                                                 CndAir 185
c                                                                               CndAir 186
        CASE (9)  ! pan temperature reset                                       CndAir 187
      END SELECT  ! rs:SCT-CTRL                                                 CndAir 188
c                                                                               CndAir 189
c                                                                               CndAir 190
c------------- Control to SCT Setpoint ---------------------------------------- CndAir 191
c                                                                               CndAir 192
c              SCT at top and bottom of throttling range                        CndAir 193
      Ttop = Tsetpt + <rs;Throttle/2>                                           CndAir 194
      Tbot = Tsetpt - <rs;Throttle/2>                                           CndAir 195
c              temperature differentials at top, setpoint, and bottom           CndAir 196
      TDtop = Ttop   - DBT                                                      CndAir 197
      TDset = Tsetpt - DBT                                                      CndAir 198
      TDbot = Tbot   - DBT                                                      CndAir 199
c                                                                               CndAir 200
c              Capacity at top of range (fan high)                              CndAir 201
      CALL HX(1, Khx, QtopHi,                                                   CndAir 202
     &                    1.,  DBT, xSupTo,                                     CndAir 203
     &                Mcycle, Ttop, xDemTo)                                     CndAir 204
      UAhi    = UAeff                                                           CndAir 205
      QrejTop = Qsct(Ttop)                                                      CndAir 206
      IF (QtopHi .LE. QrejTop)  THEN                                            CndAir 207
c              QtopHi insufficient for load - SCT floats                        CndAir 208
        FanSpeed = 4                                                            CndAir 209
        FankWr   = 1.                                                           CndAir 210
        CFMr     = 1.                                                           CndAir 211
        Call AirFloatingSCT                                                     CndAir 212
        GOTO 3170                                                               CndAir 213
      ENDIF                                                                     CndAir 214
c                                                                               CndAir 215
c              Convective capacity at bottom of range (fan off)                 CndAir 216
      CALL HX(1, Khx,          QbotOff,                                         CndAir 217
     &                <cd:FAN-OFF-AIR>,  DBT, xSupTo,                           CndAir 218
     &                          Mcycle, Tbot, xDemTo)                           CndAir 219
      UAoff   = UAeff                                                           CndAir 220
      QrejBot = Qsct(Tbot)                                                      CndAir 221
      IF (QbotOff .GE. QrejBot)  THEN                                           CndAir 222
c              Convective capacity is greater than load - SCT floats            CndAir 223
        FanSpeed = 0                                                            CndAir 224
        FankWr   = 0.                                                           CndAir 225
        CFMr     = <cd:FAN-OFF-AIR>                                             CndAir 226
        Call AirFloatingSCT                                                     CndAir 227
        GOTO 3170                                                               CndAir 228
      ENDIF                                                                     CndAir 229
                                                                                CndAir 230
c              Fan capacity control sequences                                   CndAir 231
      SELECT CASE (<cd:CAPACITY-CTRL>)                                          CndAir 232
        CASE (1)                                                                CndAir 233
c              Single-speed fan.  Condenser may be floating with fan            CndAir 234
c              off, cycling off/hi, or floating with fan hi.  The fan           CndAir 235
c              will stay in its last operating mode unless the resulting        CndAir 236
c              temperature exceeds the max/min limits.                          CndAir 237
c                                                                               CndAir 238
c              FanSpeed is operating mode:                                      CndAir 239
c                = 0  Fan off                                                   CndAir 240
c                  1  Cycling off/hi                                            CndAir 241
c                  4  Fan on hi                                                 CndAir 242
c                                                                               CndAir 243
c               Initial                                                         CndAir 244
c              FanSpeed      Tbot        Tsetpt      Ttop                       CndAir 245
c                  0     0000000000000000000000000000000>4444                   CndAir 246
c                  4     0000<4444444444444444444444444444444                   CndAir 247
c                                                                               CndAir 248
 3132     SELECT CASE (FanSpeed)                                                CndAir 249
            CASE (0,1)  ! Off or cycling off/hi                                 CndAir 250
              IF (UAoff*TDtop .GE. QrejTop)  THEN                               CndAir 251
c                 Floating with fan off                                         CndAir 252
                FanSpeed = 0                                                    CndAir 253
                FankWr   = 0.                                                   CndAir 254
                CFMr     = <cd:FAN-OFF-AIR>                                     CndAir 255
                Call AirFloatingSCT                                             CndAir 256
                GOTO 3170                                                       CndAir 257
              ELSEIF (UAhi*TDbot .LE. QrejBot)  THEN                            CndAir 258
c                 Fan on high                                                   CndAir 259
                FanSpeed = 4                                                    CndAir 260
                GOTO 3132                                                       CndAir 261
              ELSE                                                              CndAir 262
c                 Cycling off/hi                                                CndAir 263
                FanSpeed = 1                                                    CndAir 264
c                 get fraction of hour on high, and average cd.SCT              CndAir 265
                Call Condenser_AirCycle(Jcd,                                    CndAir 266
     &                Tbot, Ttop, UAoff, UAhi, FracHi, xx)                      CndAir 267
                FankWr = FracHi                                                 CndAir 268
                CFMr   = FracHi                                                 CndAir 269
              ENDIF                                                             CndAir 270
            CASE (4)  ! On                                                      CndAir 271
              IF (UAhi*TDbot .GT. QrejBot)  THEN                                CndAir 272
c                 Fan will not run continuously                                 CndAir 273
                FanSpeed = 0                                                    CndAir 274
                GOTO 3132                                                       CndAir 275
              ELSE                                                              CndAir 276
c                 floating with fan on                                          CndAir 277
                FanSpeed = 4                                                    CndAir 278
                FankWr   = 1.                                                   CndAir 279
                CFMr     = 1.                                                   CndAir 280
                Call AirFloatingSCT                                             CndAir 281
                GOTO 3170                                                       CndAir 282
              ENDIF                                                             CndAir 283
          END SELECT  ! FanSpeed                                                CndAir 284
c                                                                               CndAir 285
        CASE (2)                                                                CndAir 286
c              Two-speed fan.  Condenser may be floating with fan off,          CndAir 287
c              cycling off/low, floating on low, cycling low/high, or           CndAir 288
c              floating on high.  The fan will stay in its last                 CndAir 289
c              operating mode unless the resulting temperature exceeds          CndAir 290
c              the max/min limits.                                              CndAir 291
c                                                                               CndAir 292
c              FanSpeed is operating mode:                                      CndAir 293
c                = 0  Fan off                                                   CndAir 294
c                  1  Cycling off/low                                           CndAir 295
c                  2  Fan on low                                                CndAir 296
c                  3  Cycling low/hi                                            CndAir 297
c                  4  Fan on hi                                                 CndAir 298
c                                                                               CndAir 299
c               Initial                                                         CndAir 300
c              FanSpeed      Tbot        Tsetpt      Ttop                       CndAir 301
c                  0     0000000000000000000>22222222222>4444                   CndAir 302
c                  2     0000<22222222222222222222222222>4444                   CndAir 303
c                  4     0000<2222222222222<44444444444444444                   CndAir 304
c                                                                               CndAir 305
c              Capacity at setpoint (low speed)                                 CndAir 306
          CALL HX(1, Khx,          QsetLow,                                     CndAir 307
     &                    <cd:FAN-LOW-AIR>,    DBT, xSupTo,                     CndAir 308
     &                              Mcycle, Tsetpt, xDemTo)                     CndAir 309
          UAlow   = UAeff                                                       CndAir 310
          QrejSet = Qsct(Tsetpt)                                                CndAir 311
 3534     SELECT CASE (FanSpeed)                                                CndAir 312
            CASE (0,1)  ! Off or cycling off/low                                CndAir 313
              IF (UAoff*TDset .GE. QrejSet)  THEN                               CndAir 314
c                 Floating with fan off                                         CndAir 315
                FanSpeed = 0                                                    CndAir 316
                FankWr   = 0.                                                   CndAir 317
                CFMr     = <cd:FAN-OFF-AIR>                                     CndAir 318
                Call AirFloatingSCT                                             CndAir 319
                GOTO 3170                                                       CndAir 320
              ELSEIF (QsetLow .LE. QrejSet)  THEN                               CndAir 321
c                 At least low speed                                            CndAir 322
                FanSpeed = 2                                                    CndAir 323
                GOTO 3534                                                       CndAir 324
              ELSE                                                              CndAir 325
c                 Cycling off/low                                               CndAir 326
                FanSpeed = 1                                                    CndAir 327
c                 get fraction of hour on low, and average cd.SCT               CndAir 328
                Call Condenser_AirCycle(Jcd,                                    CndAir 329
     &                Tbot, Tsetpt, UAoff, UAlow, FracLow, xx)                  CndAir 330
                FankWr = <cd:FAN-LOW-PWR> * FracLow                             CndAir 331
                CFMr   = <cd:FAN-LOW-AIR> * FracLow                             CndAir 332
     &                 + <cd:FAN-OFF-AIR> * (1.-FracLow)                        CndAir 333
              ENDIF                                                             CndAir 334
            CASE (2)  ! Low speed                                               CndAir 335
              IF (UAlow*TDbot .GT. QrejBot)  THEN                               CndAir 336
c                 Fan off or cycling off/low                                    CndAir 337
                FanSpeed = 0                                                    CndAir 338
                GOTO 3534                                                       CndAir 339
              ELSEIF (UAlow*TDtop .LT. QrejTop)  THEN                           CndAir 340
c                 Fan on high or cycling low/high                               CndAir 341
                FanSpeed = 4                                                    CndAir 342
                GOTO 3534                                                       CndAir 343
              ELSE                                                              CndAir 344
c                 Fan floating on low                                           CndAir 345
                FanSpeed = 2                                                    CndAir 346
                FankWr   = <cd:FAN-LOW-PWR>                                     CndAir 347
                CFMr     = <cd:FAN-LOW-AIR>                                     CndAir 348
                Call AirFloatingSCT                                             CndAir 349
                GOTO 3170                                                       CndAir 350
              ENDIF                                                             CndAir 351
            CASE (3,4)  ! High or cycling low/high                              CndAir 352
              IF (UAhi*TDset .LE. QrejSet)  THEN                                CndAir 353
c                 Fan floating on high                                          CndAir 354
                FanSpeed = 4                                                    CndAir 355
                FankWr   = 1.                                                   CndAir 356
                CFMr     = 1.                                                   CndAir 357
                Call AirFloatingSCT                                             CndAir 358
                GOTO 3170                                                       CndAir 359
              ELSEIF (UAlow*TDtop .GT. QrejTop)  THEN                           CndAir 360
c                 Low speed can handle load                                     CndAir 361
                FanSpeed = 2                                                    CndAir 362
                GOTO 3534                                                       CndAir 363
              ELSE                                                              CndAir 364
c                 Cycling low/hi                                                CndAir 365
                FanSpeed = 3                                                    CndAir 366
c                 get fraction of hour on high, and average cd.SCT              CndAir 367
                Call Condenser_AirCycle(Jcd,                                    CndAir 368
     &                Tsetpt, Ttop, UAlow, UAhi, FracHi, xx)                    CndAir 369
                FracLow = 1. - FracHi                                           CndAir 370
                FankWr  = FracLow*<cd:FAN-LOW-PWR> + FracHi                     CndAir 371
                CFMr    = FracLow*<cd:FAN-LOW-AIR> + FracHi                     CndAir 372
              ENDIF                                                             CndAir 373
          END SELECT  ! FanSpeed                                                CndAir 374
c                                                                               CndAir 375
        CASE (3,4)                                                              CndAir 376
c              Variable-speed fan or modulating damper.  Condenser may          CndAir 377
c              be floating with fan off, cycling off/minimum, or                CndAir 378
c              modulating to setpoint.  The fan will stay in its last           CndAir 379
c              operating mode unless the resulting temperature exceeds          CndAir 380
c              the max/min limits.                                              CndAir 381
c                                                                               CndAir 382
c              FanSpeed is operating mode:                                      CndAir 383
c                = 0  Fan off                                                   CndAir 384
c                  1  Cycling off/minimum                                       CndAir 385
c                  4  Fan maximum                                               CndAir 386
c                  5  Fan modulating                                            CndAir 387
c                                                                               CndAir 388
c               Initial                                                         CndAir 389
c              FanSpeed      Tbot        Tsetpt      Ttop                       CndAir 390
c                  0     0000000000000000000>5555555555555555                   CndAir 391
c                  5     0000<5555555555555555555555555555555                   CndAir 392
c                                                                               CndAir 393
c              Capacity at setpoint (minimum speed)                             CndAir 394
          CALL HX(1, Khx,          QsetLow,                                     CndAir 395
     &                    <cd:FAN-MIN-AIR>,    DBT, xSupTo,                     CndAir 396
     &                              Mcycle, Tsetpt, xDemTo)                     CndAir 397
          UAlow   = UAeff                                                       CndAir 398
          QrejSet = Qsct(Tsetpt)                                                CndAir 399
 3536     SELECT CASE (FanSpeed)                                                CndAir 400
            CASE (0,1)  ! Off or cycling off/minimum                            CndAir 401
              IF (UAoff*TDset .GE. QrejSet)  THEN                               CndAir 402
c                 Floating with fan off                                         CndAir 403
                FanSpeed = 0                                                    CndAir 404
                FankWr   = 0.                                                   CndAir 405
                CFMr     = <cd:FAN-OFF-AIR>                                     CndAir 406
                Call AirFloatingSCT                                             CndAir 407
                GOTO 3170                                                       CndAir 408
              ELSEIF (UAlow*TDbot .LE. QrejBot)  THEN                           CndAir 409
c                 Fan modulating                                                CndAir 410
                FanSpeed = 5                                                    CndAir 411
                GOTO 3536                                                       CndAir 412
              ELSE                                                              CndAir 413
c                 Cycling off/minimum                                           CndAir 414
                FanSpeed = 1                                                    CndAir 415
c                 get fraction of hour on low, and average cd.SCT               CndAir 416
                Call Condenser_AirCycle(Jcd,                                    CndAir 417
     &                Tbot, Tsetpt, UAoff, -1., FracOn, EfanOn)                 CndAir 418
                FankWr = FracOn*EfanOn                                          CndAir 419
                CFMr   = -88888.                                                CndAir 420
              ENDIF                                                             CndAir 421
            CASE (4,5)  ! Modulating                                            CndAir 422
              IF (UAlow*TDbot .GT. QrejBot)  THEN                               CndAir 423
c                 Fan will not run continuously                                 CndAir 424
                FanSpeed = 0                                                    CndAir 425
                GOTO 3536                                                       CndAir 426
              ELSE                                                              CndAir 427
c                 Fan is modulating.  Solve for balance point                   CndAir 428
                FanSpeed = 5                                                    CndAir 429
                Tmin     = Tbot                                                 CndAir 430
                Qmin     = UAlow*TDbot                                          CndAir 431
                Tmax     = Ttop                                                 CndAir 432
                Qmax     = QtopHi                                               CndAir 433
                Qrej     = Qsct(<cd.SCT>)                                       CndAir 434
                DO iCount=1,100                                                 CndAir 435
                  Ratio = (Qrej-Qmin) / (Qmax-Qmin)                             CndAir 436
                  SCT   = Tmin + (Tmax-Tmin)*Ratio                              CndAir 437
                  Qrej  = Qsct(SCT)                                             CndAir 438
c                      adjust for fan speed                                     CndAir 439
                  Ratio  = (SCT-Tbot) / (Ttop-Tbot)                             CndAir 440
                  CFMr   = <cd:FAN-MIN-AIR> +(1.-<cd:FAN-MIN-AIR>)*Ratio        CndAir 441
                  CALL HX(1, Khx, Qcap,                                         CndAir 442
     &                            CFMr, DBT, xSupTo,                            CndAir 443
     &                          Mcycle, SCT, xDemTo)                            CndAir 444
                  IF (ABS(1.-Qcap/Qrej) .LT. ErrorMax)  EXIT                    CndAir 445
                  IF (Qcap .LT. Qrej)  THEN                                     CndAir 446
                    Qmin = Qcap                                                 CndAir 447
                    Tmin = SCT                                                  CndAir 448
                  ELSE                                                          CndAir 449
                    Qmax = Qcap                                                 CndAir 450
                    Tmax = SCT                                                  CndAir 451
                  ENDIF                                                         CndAir 452
                  IF (iCount .EQ. 100)  CALL CnvgMsg2(1, Routine, Jcd)          CndAir 453
                ENDDO                                                           CndAir 454
c                 Fan power ratio, airflow ratio, and SCT                       CndAir 455
                FankWr    = Curve(Jcd,<cd:FAN-KW-fAIR>, CFMr,x)                 CndAir 456
                <cd.SCT>  = SCT                                                 CndAir 457
              ENDIF                                                             CndAir 458
          END SELECT  ! FanSpeed                                                CndAir 459
c                                                                               CndAir 460
      END SELECT ! cd:CAPACITY-CTRL                                             CndAir 461
c                                                                               CndAir 462
c                                                                               CndAir 463
c------------- MISCELLANEOUS -------------------------------------------------- CndAir 464
c                                                                               CndAir 465
c              Re-entry point for floating calcs                                CndAir 466
 3170 CONTINUE                                                                  CndAir 467
c                                                                               CndAir 468
c              Outlet setpoint, pressure, enthalpy                              CndAir 469
      <cd.Tsetpt>    = Tsetpt                                                   CndAir 470
      <ro.Poutlet>   = RefgP_fT(Jre, <cd.SCT>)                                  CndAir 471
      <cd.dTsubcool> = <cd:SUBCOOL-EFF> * TDinlets                              CndAir 472
      <ro.Houtlet>   = RefgH_Liquid_fTS(Jre, <cd.SCT>,<cd.dTsubcool>)           CndAir 473
c              inlet pressure, adjusted for condenser pressure drop             CndAir 474
      dP = <cd:CONDENSER-DP> * (Mcycle*<cd;1/Mtotal>)**1.87                     CndAir 475
      <ri.Pinlet> = <ro.Poutlet> + dP                                           CndAir 476
c                                                                               CndAir 477
c              Re-entry point when condenser is off                             CndAir 478
 3190 <ro.Qoutlet> = <ro.Moutlet> * (<Xri.Hinlet>-<ro.Houtlet>)                 CndAir 479
      <cd.Qrej>    = <ro.Qoutlet>                                               CndAir 480
c                                                                               CndAir 481
c              Power consumption of fans and spray pump                         CndAir 482
      IF (<cd.Qrej> .GT. 0.)  THEN                                              CndAir 483
        <cd.FankWr>   = FankWr                                                  CndAir 484
        <cd.FankW>    = <cd;FanKWdes> * FankWr * <ro.RunFrac>                   CndAir 485
        <cd.FanSpeed> = FanSpeed                                                CndAir 486
        <cd.FankWr>   = FankWr                                                  CndAir 487
        <cd.CFMr>     = CFMr                                                    CndAir 488
      ELSE                                                                      CndAir 489
        <cd.FankWr>   = 0.                                                      CndAir 490
        <cd.FankW>    = 0.                                                      CndAir 491
        <cd.FanSpeed> = 0                                                       CndAir 492
        <cd.CFMr>     = 0.                                                      CndAir 493
      ENDIF                                                                     CndAir 494
      ElecKW = <cd.FankW>                                                       CndAir 495
      IF (<cd:AUX-METER> .GT. 0)  THEN                                          CndAir 496
        Kmd       = <cd:AUX-METER>                                              CndAir 497
        <md.Elec> = AuxKWh                                                      CndAir 498
      ELSE                                                                      CndAir 499
        ElecKW = ElecKW + AuxKwh                                                CndAir 500
      ENDIF                                                                     CndAir 501
      Kmd       = <cd:ELEC-METER>                                               CndAir 502
      <md.Elec> = ElecKW                                                        CndAir 503
c                                                                               CndAir 504
c              check for convergence                                            CndAir 505
      IF (Mode .EQ. 31)  THEN                                                   CndAir 506
        CALL CnvgCheck(1, <cd;EnergyHsty>)  ! Loads to Plant                    CndAir 507
      ELSE                                                                      CndAir 508
        CALL CnvgCheck(0, <cd;EnergyHsty>)                                      CndAir 509
      ENDIF                                                                     CndAir 510
c                                                                               CndAir 511
c                                                                               CndAir 512
c ============ REPORT CREATION ================================================ CndAir 513
      CASE (50)                                                                 CndAir 514
c                                                                               CndAir 515
c              statistics blocks                                                CndAir 516
      Ks2Load    = NewStat2(Jcd,    <+cd.Qrej>, 0, 1.)                          CndAir 517
      Ks2Flow    = NewStat2(Kro, <+ro.Moutlet>, 0, 1.)                          CndAir 518
      Ks2Elec    = NewStat2(Jcd,   <+cd.FankW>, 0, 1.)                          CndAir 519
      Kli        = 0                                                            CndAir 520
      CALL ListNodes(Kli, 0,0,Jcd,0, 11,2)                                      CndAir 521
      Ks2ElecT   = NewStat2(Kli,    <+md.Elec>, 0, 1.)                          CndAir 522
      Ks5FlowBin = NewStat5(Kro, <+ro.Moutlet>, 0, 1.)                          CndAir 523
      Ks5ElecBin = NewStat5(Kli,    <+md.Elec>, 0, 1.)                          CndAir 524
c                                                                               CndAir 525
c              Create the type "H" report                                       CndAir 526
      IF (<cd:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      CndAir 527
     &  <cd;PS-H> = NewReport_H(Jcd, 132,                                       CndAir 528
     &                          4, 5, 6,                                        CndAir 529
     &                          Ks2Load, Ks2Flow, Ks2Elec, Ks2ElecT,            CndAir 530
     &                          Ks5FlowBin, Ks5ElecBin, 0,                      CndAir 531
     &                          0, 0, 0)                                        CndAir 532
c                                                                               CndAir 533
c              Setpoint overload                                                CndAir 534
      <cd;s10> = NewStat10(Jcd, <#cd.Tsetpt>, <#cd.SCT>,                        CndAir 535
     &                          <rs:SCT-THROTTLE>*0.5, 1, <#cd.Qrej>)           CndAir 536
c                                                                               CndAir 537
c                                                                               CndAir 538
c ============ REPORT ORDER =================================================== CndAir 539
      CASE (52)                                                                 CndAir 540
c                                                                               CndAir 541
      Call Report_H(Mode, <cd;PS-H>)                                            CndAir 542
c                                                                               CndAir 543
c                                                                               CndAir 544
c ============ REPORTS - VERIFICATION DATA ==================================== CndAir 545
      CASE (54)                                                                 CndAir 546
c                                                                               CndAir 547
c              Output design information                                        CndAir 548
      IF (<cd;PS-H> .ne. 0)  THEN                                               CndAir 549
        rH = <cd;PS-H>                                                          CndAir 550
        WRITE (IREPFL) 4,<rH;Iuniq>,1,8,0                                       CndAir 551
        CALL GetAttachments(Jcd, 2)                                             CndAir 552
        WRITE (IREPFL)  25,<rH;Iuniq>,1,9,21,                                   CndAir 553
     &    (NameAttachments(II,1,1),II=1,8),                                     CndAir 554
     &    (NameAttachments(II,1,2),II=1,8),                                     CndAir 555
     &    <cd;Capacity/TD>,<ro.Moutlet>,                                        CndAir 556
     &    <cd;FanKWdes>,<cd;DesignKW>,<cd.Tsetpt>                               CndAir 557
        DO  Irow=2,NumRowsOfAttachments                                         CndAir 558
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 CndAir 559
     &      (NameAttachments(II,Irow,1),II=1,8),                                CndAir 560
     &      (NameAttachments(II,Irow,2),II=1,8)                                 CndAir 561
        ENDDO                                                                   CndAir 562
      ENDIF                                                                     CndAir 563
c                                                                               CndAir 564
c                                                                               CndAir 565
c ============ REPORTS - YEARLY SUMMARY (SPECIAL) ============================= CndAir 566
      CASE (58)                                                                 CndAir 567
c                                                                               CndAir 568
c              Setpoint overload                                                CndAir 569
      IF (<cd;PS-H> .ne. 0)  THEN                                               CndAir 570
        rH = <cd;PS-H>                                                          CndAir 571
        CALL Report_s10(<rH;Iuniq>, 7, <cd;s10>)                                CndAir 572
      ENDIF                                                                     CndAir 573
c                                                                               CndAir 574
c                                                                               CndAir 575
c ============ HOURLY REPORTS - HOURLY DATA =================================== CndAir 576
      CASE (62)                                                                 CndAir 577
c                                                                               CndAir 578
      IF (<cd;HourRepBuf> .EQ. 0)  RETURN                                       CndAir 579
      TDinlets = MAX(0., <cd.SCT>-DBT)                                          CndAir 580
c                                                                               CndAir 581
      IAptr = <cd;HourRepBuf> - 1                                               CndAir 582
      AA(IAptr+1)  = <cd.Qrej>                                                  CndAir 583
      AA(IAptr+2)  = <cd.OpCap>                                                 CndAir 584
      AA(IAptr+3)  = <ro.Moutlet>                                               CndAir 585
      AA(IAptr+4)  = <cd.Tsetpt>                                                CndAir 586
      AA(IAptr+5)  = <cd.SCT>                                                   CndAir 587
      AA(IAptr+6)  = <cd.dTsubcool>                                             CndAir 588
      AA(IAptr+7)  = -88888.                                                    CndAir 589
      AA(IAptr+8)  = DBT                                                        CndAir 590
      AA(IAptr+9)  = <cd.FankWr>                                                CndAir 591
      AA(IAptr+10) = <cd.FankW>                                                 CndAir 592
      AA(IAptr+11) = -888.                                                      CndAir 593
      AA(IAptr+12) = <Xri.Hinlet>                                               CndAir 594
      AA(IAptr+13) = <ro.Houtlet>                                               CndAir 595
      AA(IAptr+17) = <ro.RunFrac>                                               CndAir 596
c                                                                               CndAir 597
c                                                                               CndAir 598
c ============ DESIGN CALCULATIONS ============================================ CndAir 599
      CASE (111)                                                                CndAir 600
c                                                                               CndAir 601
c              This call calculates the design capacity and flow                CndAir 602
c                                                                               CndAir 603
c              Inlets TD                                                        CndAir 604
      TDinlets = MAX(5., <rs:DESIGN-SCT>-DBTMAX)                                CndAir 605
      IF (<cd:RATED-TD> .GT. 0.)  THEN                                          CndAir 606
        <cd;InletsTD> = <cd:RATED-TD>                                           CndAir 607
      ELSE                                                                      CndAir 608
        <cd;InletsTD> = TDinlets                                                CndAir 609
      ENDIF                                                                     CndAir 610
c              Design setpoint                                                  CndAir 611
      <cd.Tsetpt> = Max(<rs:DESIGN-SCT>, DBTMAX+<cd;InletsTD>)                  CndAir 612
c                                                                               CndAir 613
c              Ambient subcooling effect                                        CndAir 614
      dTsubcool    = MAX(0., <cd:SUBCOOL-EFF>*<cd;InletsTD>)                    CndAir 615
c              Outlet pressure, enthalpy, enthalpy differential                 CndAir 616
      <ro.Poutlet> = RefgP_fT(Jre, <cd.Tsetpt>)                                 CndAir 617
      <ro.Houtlet> = RefgH_Liquid_fTS(Jre, <cd.Tsetpt>, dTsubcool)              CndAir 618
      dHrefg       = <Xri.Hinlet> - <ro.Houtlet>                                CndAir 619
c                                                                               CndAir 620
c              Design capacity, normalized to 1F TD                             CndAir 621
      IF (<cd:RATED-CAPACIT> .GT. 0.)  THEN                                     CndAir 622
        <cd.Qrej> = <cd:RATED-CAPACIT> * <cd:CLASS-FACTOR>                      CndAir 623
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndAir 624
     &    <cd.Qrej> = <cd.Qrej> * <cd:CAP-RATIO>                                CndAir 625
      ELSE                                                                      CndAir 626
        IF (<cd:CAP-RATIO> .GT. 0.)  THEN                                       CndAir 627
          <cd.Qrej> = <Xri.Minlet> * dHrefg * <cd:CAP-RATIO>                    CndAir 628
        ELSE                                                                    CndAir 629
c              no capacity ratio specified - size equipment equally             CndAir 630
          Kli = <Xro;Xnode>                                                     CndAir 631
          IF (Kli .EQ. Kro)  THEN                                               CndAir 632
c              this condenser is the only attachment                            CndAir 633
            <cd.Qrej> = <Xri.Minlet> * dHrefg                                   CndAir 634
          ELSE  ! this condenser is one in a list                               CndAir 635
            <cd.Qrej> = <Xri.Minlet> * dHrefg / FLOAT(<li;NumItems>)            CndAir 636
          ENDIF                                                                 CndAir 637
        ENDIF                                                                   CndAir 638
      ENDIF  ! cd:RATED-CAPACIT                                                 CndAir 639
      <cd;Capacity/TD> = <cd.Qrej> / <cd;InletsTD>                              CndAir 640
c                                                                               CndAir 641
c              Design refrigerant flow                                          CndAir 642
      IF (<cd:RATED-FLOW> .GT. 0.)  THEN                                        CndAir 643
        RatedMrefg   = <cd:RATED-FLOW>                                          CndAir 644
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndAir 645
     &    RatedMrefg = RatedMrefg * <cd:CAP-RATIO>                              CndAir 646
        <ro.Moutlet> = RatedMrefg * <cd;InletsTD>/<cd:RATED-TD>                 CndAir 647
      ELSE                                                                      CndAir 648
        <ro.Moutlet> = <cd;Capacity/TD>*TDinlets / dHrefg                       CndAir 649
        IF (<cd:RATED-TD> .EQ. 0.)  THEN                                        CndAir 650
          RatedMrefg = <ro.Moutlet>                                             CndAir 651
        ELSE                                                                    CndAir 652
          RatedMrefg = <ro.Moutlet> * <cd:RATED-TD>/TDinlets                    CndAir 653
        ENDIF                                                                   CndAir 654
      ENDIF                                                                     CndAir 655
c              inlet flow and pressure                                          CndAir 656
      <ri.Minlet> = <ro.Moutlet>                                                CndAir 657
      IF (RatedMrefg .eq. 0.)  THEN                                             CndAir 658
        dP = <cd:CONDENSER-DP>                                                  CndAir 659
      ELSE                                                                      CndAir 660
        <cd;1/Mtotal> = 1. / RatedMrefg                                         CndAir 661
        dP = <cd:CONDENSER-DP> * (<ro.Moutlet>*<cd;1/Mtotal>)**1.87             CndAir 662
      ENDIF                                                                     CndAir 663
      <ri.Pinlet> = <ro.Poutlet> + dP                                           CndAir 664
c                                                                               CndAir 665
c              Design airflow                                                   CndAir 666
      IF (<cd:AIRFLOW> .GT. 0.)  THEN                                           CndAir 667
        <cd;CFMdes> = <cd:AIRFLOW>                                              CndAir 668
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndAir 669
     &    <cd;CFMdes> = <cd;CFMdes> * <cd:CAP-RATIO>                            CndAir 670
      ELSE                                                                      CndAir 671
        <cd;CFMdes> = <cd;Capacity/TD> * <cd:AIRFLOW-TD/CA>                     CndAir 672
      ENDIF                                                                     CndAir 673
c                                                                               CndAir 674
c              Capacity w/o subcooling                                          CndAir 675
      dHsubcool = dTsubcool * RefgCp_Liquid_fT(Jre, <cd.Tsetpt>)                CndAir 676
      Qsubcool  = RatedMrefg * dHsubcool                                        CndAir 677
      Qsat      = <cd.Qrej> - Qsubcool                                          CndAir 678
c                                                                               CndAir 679
c              Design the heat exchanger - assumes that all heat                CndAir 680
c              rejection can be treated as latent (ignores effect               CndAir 681
c              of superheat).  Note also that airflow will be treated           CndAir 682
c              as ratio in hourly calcs.  HX UA is based on saturated           CndAir 683
c              heat; subcooling will be added hourly.                           CndAir 684
      Tair  = <cd.Tsetpt> - <cd;InletsTD>                ! entering air         CndAir 685
      Wair  = WFDBWB(95.,78.,29.921)                     ! W at 95/78WB         CndAir 686
      Vair  = 0.754*(95.+459.7)*(1.0+1.605*Wair)/29.921  ! specific vol         CndAir 687
      AirCp = 0.24 + 0.444*Wair                          ! specific heat        CndAir 688
      Cair  = AirCp * <cd;CFMdes> * 60. / Vair           ! air transport        CndAir 689
      CALL HX_Design(Khx,       Qsat,                                           CndAir 690
     &                            1.,   Cair,        Tair,                      CndAir 691
     &                    RatedMrefg,  1.E20, <cd.Tsetpt>)                      CndAir 692
c                                                                               CndAir 693
c              Condenser fan energy                                             CndAir 694
      IF (<cd:KW/FAN> .GT. 0.)  THEN                                            CndAir 695
        <cd;FanKWdes> = <cd:KW/FAN> * <cd:NUM-OF-FANS>                          CndAir 696
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndAir 697
     &    <cd;FanKWdes> = <cd;FanKWdes> * <cd:CAP-RATIO>                        CndAir 698
      ELSE                                                                      CndAir 699
        <cd;FanKWdes> = <cd;Capacity/TD> * <cd:FAN-EIR-TD> * KWBTU              CndAir 700
      ENDIF                                                                     CndAir 701
c              Store electrical consumption                                     CndAir 702
      Kmd       = <cd:ELEC-METER>                                               CndAir 703
      <md.Elec> = <cd;FanKWdes>                                                 CndAir 704
      IF (<cd:AUX-METER> .GT. 0)  THEN                                          CndAir 705
        Kmd       = <cd:AUX-METER>                                              CndAir 706
        <md.Elec> = <cd:AUX-KW>                                                 CndAir 707
      ENDIF                                                                     CndAir 708
c                                                                               CndAir 709
c                                                                               CndAir 710
c ============ DESIGN RECONCILIATION ========================================== CndAir 711
      CASE (119)                                                                CndAir 712
c                                                                               CndAir 713
      IF (<cd;Capacity/TD> .EQ. 0.)  THEN                                       CndAir 714
        CALL MSGSIM(-2,II,II,II,II)                                             CndAir 715
        WRITE (IOUTPT,9002)  (<cd:NAME>,II=1,8)                                 CndAir 716
        RETURN                                                                  CndAir 717
      ENDIF                                                                     CndAir 718
                                                                                CndAir 719
      <ro;DesMoutlet> = <ro.Moutlet>                                            CndAir 720
      ErrorMax        = <sp:ERROR-LOAD> * 0.2                                   CndAir 721
      <cd;NumFanStages> = INT(<cd:NUM-OF-FANS> + 0.1)                           CndAir 722
c                                                                               CndAir 723
c              Design capacity ratio when fan off                               CndAir 724
c              First, fan off                                                   CndAir 725
      Tair = <cd.Tsetpt> - <cd;InletsTD>                ! entering air          CndAir 726
      CALL HX(1, Khx,             Qoff,                                         CndAir 727
     &                <cd:FAN-OFF-AIR>,        Tair, xSupTo,                    CndAir 728
     &                    <ro.Moutlet>, <cd.Tsetpt>, xDemTo)                    CndAir 729
      <cd;CapOff> = Qoff / <cd.Qrej>                                            CndAir 730
c                                                                               CndAir 731
c              Low speed or min fan speed                                       CndAir 732
      SELECT CASE (<cd:CAPACITY-CTRL>)                                          CndAir 733
        CASE (0,1)  ! None or cycling                                           CndAir 734
          IF (<rs:SCT-CTRL> .EQ. 8)  THEN                                       CndAir 735
c              Temperature control strategy is LOAD-RESET; the                  CndAir 736
c              condenser fan must be 2-speed, variable-speed or                 CndAir 737
c              damper.                                                          CndAir 738
            CALL MSGSIM(-2,II,II,II,II)                                         CndAir 739
            WRITE (IOUTPT,9003)  (<cd:NAME>,II=1,8)                             CndAir 740
          ENDIF                                                                 CndAir 741
        CASE (2)  ! Two-speed fan                                               CndAir 742
          IF (<cd:FAN-LOW-PWR> .EQ. 0.)  <cd:FAN-LOW-PWR> =                     CndAir 743
     &                  Curve(Jcd,<cd:FAN-KW-fAIR>, <cd:FAN-LOW-AIR>,x)         CndAir 744
        CASE (3,4)  ! Variable-speed fan, damper                                CndAir 745
          <cd:FAN-MIN-AIR> = MAX(<cd:FAN-MIN-AIR>, <cd:FAN-OFF-AIR>)            CndAir 746
          <cd:FAN-LOW-PWR> = Curve(Jcd,<cd:FAN-KW-fAIR>,                        CndAir 747
     &                                              <cd:FAN-MIN-AIR>,x)         CndAir 748
      END SELECT                                                                CndAir 749
c                                                                               CndAir 750
c              Total electrical consumption                                     CndAir 751
      <cd;DesignKW> = <cd;FanKWdes> + <cd:AUX-KW>                               CndAir 752
c                                                                               CndAir 753
c                                                                               CndAir 754
c ============ ATTACHMENTS ==================================================== CndAir 755
c                                                                               CndAir 756
c              Initial attachments                                              CndAir 757
      CASE (201)                                                                CndAir 758
c              Component pointers, schedules, and curves                        CndAir 759
        <cd:REFG-SYSTEM>   = Jcomponent(29, <cd:REFG-SYSTEM>)                   CndAir 760
        <cd:ELEC-METER>    = Jcomponent(13, <cd:ELEC-METER>)                    CndAir 761
        <cd:AUX-METER>     = Jcomponent(13, <cd:AUX-METER>)                     CndAir 762
        <cd:COST-DATA>     = Jcomponent(18, <cd:COST-DATA>)                     CndAir 763
        <cd:AUX-SCH>       = Jsched(<cd:AUX-SCH>)                               CndAir 764
        <cd:FAN-KW-fAIR>   = Jcurve(<cd:FAN-KW-fAIR>)                           CndAir 765
c                                                                               CndAir 766
c              Fluid properties subcomponent                                    CndAir 767
        <cd;SupFluidProp> = NewFluidProperties(Jcd,<cd:REFG-SYSTEM>,21,         CndAir 768
     &                      0., 0., 0., 0.,                                     CndAir 769
     &                      0., 0., 0., 0.,                                     CndAir 770
     &                      0., 0., 0., 0., 0.)                                 CndAir 771
        <cd;RfgFluidProp> = NewFluidProperties(Jcd,<cd:REFG-SYSTEM>,34,         CndAir 772
     &                      0., 0., 0., 0.,                                     CndAir 773
     &                      0., 0., 0., 0.,                                     CndAir 774
     &                      0., 0., 0., 0., 0.)                                 CndAir 775
c                                                                               CndAir 776
c              Heat-exchanger subcomponent                                      CndAir 777
        <cd;HX> = NewHX(Jcd, 0, 0.,                                             CndAir 778
     &                  <cd;SupFluidProp>,  0.4,                                CndAir 779
     &                  <cd;RfgFluidProp>,  0.3)                                CndAir 780
c                                                                               CndAir 781
c              Create nodes                                                     CndAir 782
      CASE (203)                                                                CndAir 783
c              Outlet interface (supply to liquid)                              CndAir 784
        <cd;InletNode>  = NewNode(1, 0,Jrs,Jcd,Jrs, 65,1,0, 1.)                 CndAir 785
        <cd;OutletNode> = NewNode(1, 0,Jrs,Jcd,Jrs, 65,2,0, 1.)                 CndAir 786
c                                                                               CndAir 787
c              Electric and auxiliary meter                                     CndAir 788
        Jme = <cd:ELEC-METER>                                                   CndAir 789
        <cd:ELEC-METER> = NewNode(1, Jrs,Jrs,Jcd,Jme, 11,2,6, 1.)               CndAir 790
        IF (<cd:AUX-METER> .GT. 0)  THEN                                        CndAir 791
          Jme = <cd:AUX-METER>                                                  CndAir 792
          <cd:AUX-METER> = NewNode(1, Jrs,Jrs,Jcd,Jme, 11,2,6, 1.)              CndAir 793
        ENDIF                                                                   CndAir 794
c                                                                               CndAir 795
c              Links, lists                                                     CndAir 796
      CASE (205)                                                                CndAir 797
c              Get refrigerant pointer from refg plant                          CndAir 798
        <cd;Refrigerant> = <rs:REFRIGERANT>                                     CndAir 799
c              Get pointer to reference enthalpy from liquid trunk              CndAir 800
c                                                                               CndAir 801
c              Histories                                                        CndAir 802
      CASE (208)                                                                CndAir 803
c              Set up history on outlet conditions                              CndAir 804
        Kli = 0                                                                 CndAir 805
        Kmx = <cd:ELEC-METER>                                                   CndAir 806
        CALL ListAdd(Kli, Kmx)                                                  CndAir 807
        CALL ListAdd(Kli, <cd:AUX-METER>)                                       CndAir 808
        KliX = Kli                                                              CndAir 809
        CALL ListXNodes(Kli, KliX)                                              CndAir 810
        <cd;EnergyHsty> = NewHistory(Jrs,Jrs,Jcd, KliX, Kmx,                    CndAir 811
     &                      0, 0, 1.,                                           CndAir 812
     &                      <#mx.Load>, <sp:ERROR-LOAD>, 2,                     CndAir 813
     &                      0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)             CndAir 814
c                                                                               CndAir 815
c              Dump pointers                                                    CndAir 816
      CASE (210)                                                                CndAir 817
        IF (<cd;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         CndAir 818
        WRITE (IOUTPT, 9202)  (<cd:NAME>,II=1,8),                               CndAir 819
     &    Jcd, Xri, Kro, Xro, <cd;HWInletNode>, <cd;HWOutletNode>               CndAir 820
c                                                                               CndAir 821
c                                                                               CndAir 822
      END SELECT  ! Mode                                                        CndAir 823
c                                                                               CndAir 824
      RETURN                                                                    CndAir 825
c                                                                               CndAir 826
c              Message formats                                                  CndAir 827
 9002 FORMAT(14x,'Condenser: ',8A4,' has no design load'               )        CndAir 828
 9003 FORMAT(14x,'Condenser: ',8A4,' must have a 2-speed or'           /        CndAir 829
     &       14x,'variable-speed fan for the condenser loop LOAD-RESET'/        CndAir 830
     &       14x,'temperature control strategy to work.  The control'  /        CndAir 831
     &       14x,'strategy has been changed to FIXED.'                 )        CndAir 832
 9201 FORMAT(/' CONDENSERs                             Jcd       Xri',          CndAir 833
     &'       Kro       Xro     HW In    HW Out'                       /        CndAir 834
     &1x,32('-'),6('  --------'))                                               CndAir 835
 9202 FORMAT(1x,8A4,6I10)                                                       CndAir 836
c                                                                               CndAir 837
c                                                                               CndAir 838
      CONTAINS                                                                  CndAir 839
c ============== AirFloatingSCT =============================================== CndAir 840
      Subroutine AirFloatingSCT                                                 CndAir 841
                                                                                CndAir 842
c              Calculates the SCT for given refrigerant and air flows           CndAir 843
                                                                                CndAir 844
c              Get the effective UA (UAeff) for the given refrigerant           CndAir 845
c              and air flows; UAstaged is already set for                       CndAir 846
c              SCT-CTRL = ambient-staged.                                       CndAir 847
      IF (UAstaged .gt. 0.)  THEN                                               CndAir 848
        UAeff = UAstaged                                                        CndAir 849
      ELSE  ! get UAeff                                                         CndAir 850
        CALL HX(1, Khx, xQhx,                                                   CndAir 851
     &                  CFMr,  xSupTi, xSupTo,                                  CndAir 852
     &                Mcycle,  xDemTi, xDemTo)                                  CndAir 853
      ENDIF                                                                     CndAir 854
c              initialize heat rejection based on last known SCT                CndAir 855
      Qrej = Qsct(<cd.SCT>)                                                     CndAir 856
                                                                                CndAir 857
c              Solve to find SCT and Qrej                                       CndAir 858
      ErrorMult = 1.                                                            CndAir 859
      Error1    = 1.E20                                                         CndAir 860
      IterQ     = 0                                                             CndAir 861
      DO                                                                        CndAir 862
        <cd.SCT>  = DBT + Qrej/UAeff                                            CndAir 863
        <cd.Qrej> = Qsct(<cd.SCT>)                                              CndAir 864
        Error     = <cd.Qrej> - Qrej                                            CndAir 865
        IF (Abs(Error/Qrej) .lt. ErrorMax)  Exit                                CndAir 866
        IF (Error/Error1 .lt. -0.5)  ! oscillating strongly                     CndAir 867
     &    ErrorMult = ErrorMult * 0.5                                           CndAir 868
        Qrej   = Qrej + Error * ErrorMult                                       CndAir 869
        Error1 = Error                                                          CndAir 870
        IF (IterQ .eq. 20)  THEN                                                CndAir 871
          CALL CnvgMsg2(1, Routine, Jcd)                                        CndAir 872
          Exit                                                                  CndAir 873
        ENDIF                                                                   CndAir 874
        IterQ  = IterQ + 1                                                      CndAir 875
      ENDDO                                                                     CndAir 876
                                                                                CndAir 877
      End Subroutine AirFloatingSCT                                             CndAir 878
                                                                                CndAir 879
      END                                                                       CndAir 880
      Subroutine Condenser_AirCycle(Jcd, Tmin, Tmax, UAmin, UAmax,              CndACy   2
     &                                           FracMax, EfanMax)              CndACy   3
                                                                                CndACy   4
c              When an air-cooled condenser is cycling between two              CndACy   5
c              fan modes, such as off/hi, off/low, low/high, etc.,              CndACy   6
c              calculates the fraction of time in the higher mode.              CndACy   7
                                                                                CndACy   8
c              Jcd     Pointer to the condenser                                 CndACy   9
c              Tmin    Temperature at bottom of range                           CndACy  10
c              UAmin   UA when in minimum mode of operation                     CndACy  11
c              Tmax    Temperature at top of range                              CndACy  12
c              UAmax   UA when in maximum mode of operation                     CndACy  13
c                        -1 means modulating fan (VFD)                          CndACy  14
                                                                                CndACy  15
c              FracMax  Fraction of hour in maximum mode                        CndACy  16
c              EfanMax  For VFD only, weighted kW in maximum mode               CndACy  17
c              cd.SCT   Average SCT during the hour                             CndACy  18
                                                                                CndACy  19
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
                                                                                CndACy  24
      Integer  Xri                                                              CndACy  25
      Real     mCap, mRej                                                       CndACy  26
                                                                                CndACy  27
c              Heat rejection for a given SCT, assuming no subcooling           Qsct     2
      Qsct(SCTx) = Max(1., Mcycle                                               Qsct     3
     &                      * (<Xri.Hinlet>-RefgH_Liquid_fT(Jre, SCTx)))        Qsct     4
                                                                                CndACy  29
      Kri = <cd;InletNode>               ! refrigerant inlet                    CndACy  30
      Xri = <ri;Xnode>                   ! refrigerant Xinlet                   CndACy  31
      Kro = <cd;OutletNode>              ! refrigerant outlet                   CndACy  32
      Jre = <cd;Refrigerant>             ! refrigerant                          CndACy  33
                                                                                CndACy  34
c              Get the weighted capacity in minimum and maximum modes           CndACy  35
      CALL Condenser_AirCycleMode(Jcd, Tmin, Tmax, UAmin,                       CndACy  36
     &                                          Qmin, SCTmin,      xx)          CndACy  37
      CALL Condenser_AirCycleMode(Jcd, Tmin, Tmax, UAmax,                       CndACy  38
     &                                          Qmax, SCTmax, EfanMax)          CndACy  39
                                                                                CndACy  40
c              Heat rejection at average temperature of the two modes           CndACy  41
      QrejMax = Qsct(SCTmax)                                                    CndACy  42
      QrejMin = Qsct(SCTmin)                                                    CndACy  43
                                                                                CndACy  44
      dTsct   = SCTmax - SCTmin                                                 CndACy  45
      IF (Abs(dTsct) .lt. 0.000001)  THEN                                       CndACy  46
c              special case where two modes produce identical average           CndACy  47
c              temperatures (don't believe this can actually happen)            CndACy  48
        <cd.SCT> = SCTmax                                                       CndACy  49
        FracMax  = (QrejMax-Qmin) / (Qmax-Qmin)                                 CndACy  50
      ELSE                                                                      CndACy  51
c              Condenser capacity as a function of SCT,                         CndACy  52
c              expressed as y = mx + b; Qcap = mSCT + b                         CndACy  53
        mCap = (Qmax-Qmin) / dTsct                                              CndACy  54
        bCap = Qmin - mCap*SCTmin                                               CndACy  55
c              net heat rejected for a given SCT, expressed as y = mx+b         CndACy  56
        mRej = (QrejMax-QrejMin) / dTsct                                        CndACy  57
        bRej = QrejMin - mRej*SCTmin                                            CndACy  58
c              solve for the intersection of the condenser capacity and         CndACy  59
c              heat rejection                                                   CndACy  60
        <cd.SCT> = (bRej-bCap) / (mCap-mRej)                                    CndACy  61
c              fraction of the hour in the maximum mode                         CndACy  62
        FracMax = (<cd.SCT>-SCTmin) / dTsct                                     CndACy  63
      ENDIF                                                                     CndACy  64
                                                                                CndACy  65
      IF (FracMax .gt. 1.05  .or.  FracMax .lt. -0.05)  THEN                    CndACy  66
        Write (IOUTPT,9101) (<cd:NAME>,II=1,8)                                  CndACy  67
      ENDIF                                                                     CndACy  68
      FracMax = Max(0., Min(1., FracMax))                                       CndACy  69
                                                                                CndACy  70
      Return                                                                    CndACy  71
                                                                                CndACy  72
 9101 Format(14x,' Condenser_AirCycle Error ', 8A4)                             CndACy  73
      End  ! Condenser_AirCycleMax                                              CndACy  74
      Subroutine Condenser_AirCycleMode(Jcd, Tcutout, Tcutin, UAhx,             CndACM   2
     &                                   Qweight, Tweight, Eweight)             CndACM   3
c                                                                               CndACM   4
c              Solves for the average SCT of an air-cooled condenser            CndACM   5
c              for one mode (such as On or Off) when the fan is cycling.        CndACM   6
c                                                                               CndACM   7
c              Jcd       Pointer to the condenser                               CndACM   8
c              Tcutout   Temperature fan cycles off                             CndACM   9
c              Tcutin    Temperature fan cycles on                              CndACM  10
c              UAhx      Fan-adjusted effective UA of heat-exchanger            CndACM  11
c                          -1 means modulating fan (VFD)                        CndACM  12
c              Qweight   Weighted heat rejection in range                       CndACM  13
c              Tweight   Weighted SCT in range                                  CndACM  14
c              Eweight   Weighted fan power in range                            CndACM  15
c                                                                               CndACM  16
c              Common block variables                                           CndACM  17
c              Mcycle    Refrigerant flow when cycled on                        CndACM  18
c              Ttop      Temperature at top of throttling range                 CndACM  19
c              Tbot      Temperature at bottom of throttling range              CndACM  20
c              DBT       Drybulb temperature                                    CndACM  21
c                                                                               CndACM  22
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
c                                                                               CndACM  27
      Integer   Xri                                                             CndACM  28
      DIMENSION Tbin(5), Qbin(5), Ebin(5), Weight(5), BinSize(5)                CndACM  29
      DATA      BinSize /0.5, 1.0, 1.0, 1.0, 0.5/                               CndACM  30
                                                                                CndACM  31
c              Heat rejection for a given SCT, assuming no subcooling           Qsct     2
      Qsct(SCTx) = Max(1., Mcycle                                               Qsct     3
     &                      * (<Xri.Hinlet>-RefgH_Liquid_fT(Jre, SCTx)))        Qsct     4
                                                                                CndACM  33
      Kri = <cd;InletNode>               ! refrigerant inlet                    CndACM  34
      Xri = <ri;Xnode>                   ! refrigerant Xinlet                   CndACM  35
      Kro = <cd;OutletNode>              ! refrigerant outlet                   CndACM  36
      Jre = <cd;Refrigerant>             ! refrigerant                          CndACM  37
      Khx = <cd;HX>                      ! HX subcomponent                      CndACM  38
c                                                                               CndACM  39
c              Look at performance at 5 points in the throttling range          CndACM  40
c              in order to take into account the effect of approach             CndACM  41
      dTbin = (Tcutin-Tcutout) * 0.25                                           CndACM  42
      SCT   = Tcutout - dTbin                                                   CndACM  43
      DO  I=1,5                                                                 CndACM  44
        SCT     = SCT + dTbin                                                   CndACM  45
        Tbin(I) = SCT                                                           CndACM  46
c              adjust for fan modulation                                        CndACM  47
        IF (UAhx .GT. 0.)  THEN                                                 CndACM  48
          Qbin(I) = UAhx * (SCT-DBT)                                            CndACM  49
        ELSE                                                                    CndACM  50
c              variable-speed or damper                                         CndACM  51
          Ratio   = (SCT-Tbot) / (Ttop-Tbot)                                    CndACM  52
          CFMr    = <cd:FAN-MIN-AIR> + (1.-<cd:FAN-MIN-AIR>)*Ratio              CndACM  53
          CALL HX(1, Khx, Qbin(I),                                              CndACM  54
     &                       CFMr, DBT, xSupTo,                                 CndACM  55
     &                     Mcycle, SCT, xDemTo)                                 CndACM  56
          Ebin(I) = Curve(Jcd,<cd:FAN-KW-fAIR>, CFMr,x)                         CndACM  57
        ENDIF                                                                   CndACM  58
      ENDDO                                                                     CndACM  59
c                                                                               CndACM  60
c              Relative time spent in each bin                                  CndACM  61
      SumWeight = 0.                                                            CndACM  62
      DO  I=1,5                                                                 CndACM  63
        Qrej      = Qsct(Tbin(I))                                               CndACM  64
        Weight(I) = BinSize(I) / Max(1.E-20, ABS(Qrej - Qbin(I)))               CndACM  65
        SumWeight = SumWeight + Weight(I)                                       CndACM  66
      ENDDO                                                                     CndACM  67
c                                                                               CndACM  68
c              Weighted capacity, temperature, and fan power                    CndACM  69
      Qweight = 0.                                                              CndACM  70
      Tweight = 0.                                                              CndACM  71
      Eweight = 0.                                                              CndACM  72
      Denom   = 1. / SumWeight                                                  CndACM  73
      DO  I=1,5                                                                 CndACM  74
        WeightBin = Weight(I) * Denom                                           CndACM  75
        Qweight   = Qweight + Qbin(I) * WeightBin                               CndACM  76
        Tweight   = Tweight + Tbin(I) * WeightBin                               CndACM  77
        Eweight   = Eweight + Ebin(I) * WeightBin                               CndACM  78
      ENDDO                                                                     CndACM  79
c                                                                               CndACM  80
      RETURN                                                                    CndACM  81
      END                                                                       CndACM  82
      SUBROUTINE Condenser_Evap(Mode, Jcd)                                      CndEv    2
c                                                                               CndEv    3
c              Simulates a single-circuit evaporative condenser.                CndEv    4
c                                                                               CndEv    5
c                                                                               CndEv    6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /FNSYS/  ISKIPS, MSYSF(120)                                       /FNSYS/  2
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               CndEv   18
      COMMON  /TWRKY / Open, OpenHX, FluidCool,                                 /TWRKY/  2
     &                 Bypass, Speed1, Speed2, SpeedV, Damper,                  /TWRKY/  3
     &                 RunMinCells, RunMaxCells,                                /TWRKY/  4
     &                 ElecPanHtr, NoPanHtr, HWPanHtr,                          /TWRKY/  5
     &                 CycleWithFan, StayOn                                     /TWRKY/  6
      INTEGER          Open, OpenHX, FluidCool,                                 /TWRKY/  7
     &                 Bypass, Speed1, Speed2, SpeedV, Damper,                  /TWRKY/  8
     &                 RunMinCells, RunMaxCells,                                /TWRKY/  9
     &                 ElecPanHtr, NoPanHtr, HWPanHtr,                          /TWRKY/ 10
     &                 CycleWithFan, StayOn                                     /TWRKY/ 11
c                                                                               CndEv   20
      INTEGER  Xri, Xro, rH, FanSpeed, Routine(4)                               CndEv   21
      DATA     Routine   /4HCond,4Hense,4Hr_Ev,4Hap  /                          CndEv   22
      SAVE     ErrorMax                                                         CndEv   23
c                                                                               CndEv   24
c              Heat rejection for a given SCT, assuming no subcooling           Qsct     2
      Qsct(SCTx) = Max(1., Mcycle                                               Qsct     3
     &                      * (<Xri.Hinlet>-RefgH_Liquid_fT(Jre, SCTx)))        Qsct     4
c                                                                               CndEv   26
c              Inlet and outlet nodes, and their Xfaced circuits                CndEv   27
      Kri = <cd;InletNode>               ! refrigerant inlet                    CndEv   28
      Xri = <ri;Xnode>                   ! refrigerant Xinlet                   CndEv   29
      Kro = <cd;OutletNode>              ! refrigerant outlet                   CndEv   30
      Xro = <ro;Xnode>                   ! refrigerant Xoutlet                  CndEv   31
      Jre = <cd;Refrigerant>             ! refrigerant                          CndEv   32
      Jrs = <cd:REFG-SYSTEM>             ! refrigeration system                 CndEv   33
c                                                                               CndEv   34
      SELECT CASE (Mode)                                                        CndEv   35
c                                                                               CndEv   36
c                                                                               CndEv   37
c ============ HOURLY INITIALIZATION ========================================== CndEv   38
      CASE (10)                                                                 CndEv   39
c                                                                               CndEv   40
c              Staged-fan airflow                                               CndEv   41
      SELECT CASE (<rs:SCT-CTRL>)                                               CndEv   42
        CASE (0)  ! Continuous fan                                              CndEv   43
          <cd.StagedCFMr> = 1.                                                  CndEv   44
        CASE (6)  ! Drybulb-staged                                              CndEv   45
          CFMr        = 0.                                                      CndEv   46
          DO  IT=1,<cd;NumFanStages>                                            CndEv   47
            IF (DBT .GE. <cd:FAN-STAGE-T>)  CFMr = CFMr + 1.                    CndEv   48
          ENDDO                                                                 CndEv   49
          <cd.StagedCFMr> = CFMr / <cd;NumFanStages>                            CndEv   50
          <cd.StagedCFMr> = MAX(<cd:FAN-OFF-AIR>, <cd.StagedCFMr>)              CndEv   51
        CASE (7)  ! Wetbulb-staged                                              CndEv   52
          CFMr        = 0.                                                      CndEv   53
          DO  IT=1,<cd;NumFanStages>                                            CndEv   54
            IF (WBT .GE. <cd:FAN-STAGE-T>)  CFMr = CFMr + 1.                    CndEv   55
          ENDDO                                                                 CndEv   56
          <cd.StagedCFMr> = CFMr / <cd;NumFanStages>                            CndEv   57
          <cd.StagedCFMr> = MAX(<cd:FAN-OFF-AIR>, <cd.StagedCFMr>)              CndEv   58
      END SELECT  ! rs:SCT-CTRL                                                 CndEv   59
c                                                                               CndEv   60
c                                                                               CndEv   61
c ============ HOURLY SIMULATION - OPERATING CAPACITY ========================= CndEv   62
      CASE (25)                                                                 CndEv   63
c                                                                               CndEv   64
c              Temperature setpoint and control fan cfm                         CndEv   65
      Tsetpt = <Xro.Treqd>                                                      CndEv   66
      SELECT CASE (<rs:SCT-CTRL>)                                               CndEv   67
        CASE (6,7) ! Ambient-staged fan                                         CndEv   68
          CFMr = <cd.StagedCFMr>                                                CndEv   69
        CASE DEFAULT                                                            CndEv   70
          CFMr = 1.                                                             CndEv   71
      END SELECT  ! rs:SCT-CTRL                                                 CndEv   72
c                                                                               CndEv   73
c              Wetbulb is limited to 20-90F, Setpoint must be                   CndEv   74
c              greater than wetbulb                                             CndEv   75
      Twb = MIN(MAX(WBT, 20.), 90.)                                             CndEv   76
      IF (Tsetpt .GT. Twb)  THEN                                                CndEv   77
        Tsetpt     = MAX(Tsetpt, Twb+2.)                                        CndEv   78
c              Operating capacity                                               CndEv   79
        CapRatio   = Curve(Jcd,<cd:CAP-fSCT&WB>, Tsetpt,Twb)                    CndEv   80
     &             * Curve(Jcd,<cd:CAP-fAIRFLOW>, CFMr,x)                       CndEv   81
        <cd.OpCap> = <cd;NormalCap> * CapRatio                                  CndEv   82
c              Enthalpy at setpoint and refrigerant flow                        CndEv   83
        Hsetpt        = RefgH_Liquid_fT(Jre, Tsetpt)                            CndEv   84
        <ro.MaxMrefg> = <cd.OpCap> / (<Xri.Hinlet>-Hsetpt)                      CndEv   85
      ELSE                                                                      CndEv   86
        <cd.OpCap>    = 0.                                                      CndEv   87
        <ro.MaxMrefg> = 0.                                                      CndEv   88
      ENDIF                                                                     CndEv   89
c                                                                               CndEv   90
c                                                                               CndEv   91
c ============ HOURLY SIMULATION - PERFORMANCE ================================ CndEv   92
      CASE (31,32)                                                              CndEv   93
c                                                                               CndEv   94
c              Auxiliary power                                                  CndEv   95
      IF (<cd:AUX-KW> .GT. 0.)  THEN                                            CndEv   96
        SELECT CASE (<cd:AUX-MODE>)                                             CndEv   97
          CASE (1)  ! Always                                                    CndEv   98
            AuxKWh = <cd:AUX-KW>                                                CndEv   99
          CASE (2)  ! When on                                                   CndEv  100
            IF (<ro.Moutlet> .GT. 0.)                                           CndEv  101
     &        AuxKWh = <cd:AUX-KW> * <ro.RunFrac>                               CndEv  102
          CASE (3)  ! When off                                                  CndEv  103
            IF (<ro.Moutlet> .EQ. 0.)                                           CndEv  104
     &        AuxKWh = <cd:AUX-KW> * (1.-<ro.RunFrac>)                          CndEv  105
          CASE (4)  ! Scheduled                                                 CndEv  106
            AuxKWh = <cd:AUX-KW> * SchVal(<cd:AUX-SCH>)                         CndEv  107
        END SELECT                                                              CndEv  108
      ELSE                                                                      CndEv  109
        AuxKWh = 0.                                                             CndEv  110
      ENDIF                                                                     CndEv  111
c                                                                               CndEv  112
c             skip if no load                                                   CndEv  113
      <ri.Minlet> = <ro.Moutlet>                                                CndEv  114
      IF (<ro.Moutlet> .LT. 0.001)  THEN                                        CndEv  115
c              check for pan heater                                             CndEv  116
        IF (<cd:PAN-HTR-TYPE> .GT. 0.  .AND.                                    CndEv  117
     &                                  DBT .LT. <cd:PAN-FLUID-T>)  THEN        CndEv  118
          Tpan     = <cd:PAN-FLUID-T>                                           CndEv  119
          UA       = <cd;PanUA> * SurfaceFilmAdj(Tpan, DBT, WNDSPD)             CndEv  120
          QpanLoss = UA * (DBT - Tpan)                                          CndEv  121
          IF (<cd:PAN-HTR-TYPE> .EQ. ElecPanHtr)  THEN                          CndEv  122
c              electric pan heater - pass on to auxiliary                       CndEv  123
            AuxKWh = AuxKWh - QpanLoss * KWBTU                                  CndEv  124
          ELSE                                                                  CndEv  125
c              hot water pan heater                                             CndEv  126
            Jpl         = <cd:PAN-HTR-LOOP>                                     CndEv  127
            Kfi         = <cd;HWInletNode>                                      CndEv  128
C ??            <fi.Qinlet> = QpanLoss * <lp;HCAP_RATIO>                        CndEv  129
C ??           QpanLoss    = QpanLoss * <lp;HCAP_RATIO>                         CndEv  130
            IF (<cd:PAN-VALVE-TYP> .EQ. 3)  THEN                                CndEv  131
c              3-way valve                                                      CndEv  132
              <fi.Minlet> = <cd;DesignPanGPM>                                   CndEv  133
              <fi.Pinlet> = <cd:PAN-HTR-HEAD>                                   CndEv  134
            ELSE                                                                CndEv  135
c              2-way valve - assume linear with load                            CndEv  136
              PLR = MIN(1., QpanLoss/<cd:PAN-LOSS>)                             CndEv  137
              <fi.Minlet> = <cd;DesignPanGPM> * PLR                             CndEv  138
              <fi.Pinlet> = <cd:PAN-HTR-HEAD>*PLR**1.87                         CndEv  139
            ENDIF                                                               CndEv  140
            IF (Mode .EQ. 31)  THEN                                             CndEv  141
              CALL CnvgCheck(1, <cd;HWOutletHsty>)  ! Loads to Plant            CndEv  142
            ELSE                                                                CndEv  143
              CALL CnvgCheck(0, <cd;HWOutletHsty>)                              CndEv  144
            ENDIF                                                               CndEv  145
          ENDIF                                                                 CndEv  146
        ENDIF  !pan losses                                                      CndEv  147
        GOTO 3190                                                               CndEv  148
      ENDIF                                                                     CndEv  149
c                                                                               CndEv  150
c              Condenser is operating                                           CndEv  151
c              Pan heater is off when condenser is on                           CndEv  152
      IF (<cd:PAN-HTR-TYPE> .EQ. HWPanHtr)  THEN                                CndEv  153
        Kfi         = <cd;HWInletNode>                                          CndEv  154
        <fi.Qinlet> = 0.                                                        CndEv  155
        IF (<cd:PAN-VALVE-TYP> .EQ. 3)  THEN                                    CndEv  156
c              3-way valve                                                      CndEv  157
          <fi.Minlet> = <cd;DesignPanGPM>                                       CndEv  158
          <fi.Preqd>  = <cd:PAN-HTR-HEAD>                                       CndEv  159
        ELSE                                                                    CndEv  160
          <fi.Minlet> = 0.                                                      CndEv  161
          <fi.Preqd>  = 0.                                                      CndEv  162
        ENDIF                                                                   CndEv  163
        IF (Mode .EQ. 31)  THEN                                                 CndEv  164
          CALL CnvgCheck(1, <cd;HWOutletHsty>)  ! Loads to Plant                CndEv  165
        ELSE                                                                    CndEv  166
          CALL CnvgCheck(0, <cd;HWOutletHsty>)                                  CndEv  167
        ENDIF                                                                   CndEv  168
      ENDIF                                                                     CndEv  169
c                                                                               CndEv  170
c              Wetbulb is limited to 20-90F                                     CndEv  171
      Twb  = MIN(MAX(WBT, 20.), 90.)                                            CndEv  172
      Twb2 = Twb + 2.                                                           CndEv  173
c              value of capacity curve when SCT is 2F above Twb                 CndEv  174
      CapfTwb2 = Curve(-1, <cd:CAP-fSCT&WB>, Twb2, Twb)                         CndEv  175
c                                                                               CndEv  176
c              If cycling, convert hourly average refrigerant flow to           CndEv  177
c              flow when cycled on                                              CndEv  178
      Mcycle = <ro.Moutlet> / <ro.RunFrac>                                      CndEv  179
                                                                                CndEv  180
c              Initialize FanSpeed to last hour's or iteration's mode           CndEv  181
      FanSpeed = <cd.FanSpeed>                                                  CndEv  182
      Tsetpt   = -88888.                                                        CndEv  183
c              in FloatingSCT, use CapfCFM if nonzero; otherwise CFMr           CndEv  184
      CapfCFM  = 0.                                                             CndEv  185
c                                                                               CndEv  186
c              Calculate SCT for non-temperature controlled schemes             CndEv  187
      SELECT CASE (<rs:SCT-CTRL>)                                               CndEv  188
c                                                                               CndEv  189
        CASE (0,6,7)  ! Always on or ambient-staged fan                         CndEv  190
          CFMr    = <cd.StagedCFMr>                                             CndEv  191
          FankWr  = CFMr                                                        CndEv  192
          CapfCFM = (CFMr + <cd;CapOff>*(1.-CFMr))                              CndEv  193
c              floating temperature                                             CndEv  194
          Call EvapFloatingSCT                                                  CndEv  195
          GOTO 3170                                                             CndEv  196
c                                                                               CndEv  197
        CASE (1:5)  ! Temperature setpoint sequences                            CndEv  198
          Tsetpt = <Xro.Treqd>                                                  CndEv  199
c                                                                               CndEv  200
        CASE (8)  ! Load reset                                                  CndEv  201
          SELECT CASE (<cd:CAPACITY-CTRL>)                                      CndEv  202
            CASE (2)  ! 2-speed fan                                             CndEv  203
c                 let float on low speed                                        CndEv  204
              CFMr   = <cd:FAN-LOW-AIR>                                         CndEv  205
              FankWr = <cd:FAN-LOW-PWR>                                         CndEv  206
            CASE (3,4)  ! Variable speed or damper                              CndEv  207
c                 reset based on design load                                    CndEv  208
              PLR    = <Xri.Minlet>/<ro.RunFrac> * <cd;1/Mtotal>                CndEv  209
              PLR    = MAX(<rs:LOAD-MIN-PLR>,                                   CndEv  210
     &                     MIN(<rs:LOAD-MAX-PLR>, PLR))                         CndEv  211
              CFMr   = <rs:LOAD-MIN-AIR>                                        CndEv  212
     &               + (<rs:LOAD-MAX-AIR> - <rs:LOAD-MIN-AIR>)                  CndEv  213
     &               * (PLR-<rs:LOAD-MIN-PLR>)                                  CndEv  214
     &                         /(<rs:LOAD-MAX-PLR>-<rs:LOAD-MIN-PLR>)           CndEv  215
              FankWr = Curve(Jcd,<cd:FAN-KW-fAIR>, CFMr,x)                      CndEv  216
          END SELECT                                                            CndEv  217
c              Get floating SCT                                                 CndEv  218
          Call EvapFloatingSCT                                                  CndEv  219
c              Check if SCT is within range                                     CndEv  220
          IF (<cd.SCT> .LT. <rs.HtRecSetpt>-<rs;Throttle/2>)  THEN              CndEv  221
c              heat-reclaim takes priority                                      CndEv  222
            Tsetpt = <rs.HtRecSetpt>                                            CndEv  223
          ELSEIF (<cd.SCT> .GT. <rs:OVERRIDE-MAX>-<rs;Throttle/2>)  THEN        CndEv  224
c              floating SCT is too hot - control to max temp                    CndEv  225
            Tsetpt = <rs:OVERRIDE-MAX>-<rs;Throttle/2>                          CndEv  226
          ELSEIF (<cd.SCT> .LT. <rs:OVERRIDE-MIN>+<rs;Throttle/2>)  THEN        CndEv  227
c              floating SCT is too cold - control to min temp                   CndEv  228
            Tsetpt = <rs:OVERRIDE-MIN>+<rs;Throttle/2>                          CndEv  229
          ELSE                                                                  CndEv  230
c              SCT is within acceptable range                                   CndEv  231
            GOTO 3170                                                           CndEv  232
          ENDIF                                                                 CndEv  233
c                                                                               CndEv  234
        CASE (9)  ! pan temperature reset                                       CndEv  235
      END SELECT  ! rs:SCT-CTRL                                                 CndEv  236
c                                                                               CndEv  237
c                                                                               CndEv  238
c------------- Control to SCT Setpoint ---------------------------------------- CndEv  239
c                                                                               CndEv  240
c              Adjust actual setpoint for the controller's throttling           CndEv  241
c              range.  To do this, capacity must be known at top and            CndEv  242
c              bottom of throttling range.                                      CndEv  243
      Ttop = Tsetpt + <rs;Throttle/2>                                           CndEv  244
      Tbot = Tsetpt - <rs;Throttle/2>                                           CndEv  245
                                                                                CndEv  246
c              Capacity at top of throttling range                              CndEv  247
      IF (Ttop .GE. Twb2)  THEN                                                 CndEv  248
        Qtop = <cd;NormalCap> * Curve(Jcd,<cd:CAP-fSCT&WB>,Ttop,Twb)            CndEv  249
      ELSEIF (Ttop .GT. Twb)  THEN                                              CndEv  250
c              close to wetbulb - interpolate to 0 capacity at wetbulb          CndEv  251
        Qtop = <cd;NormalCap> * CapfTwb2 * (Ttop-Twb) / 2.                      CndEv  252
      ELSE                                                                      CndEv  253
c              Ttop is below wetbulb - SCT floats                               CndEv  254
        FanSpeed = 4                                                            CndEv  255
        FankWr   = 1.                                                           CndEv  256
        CFMr     = 1.                                                           CndEv  257
        Call EvapFloatingSCT                                                    CndEv  258
        GOTO 3170                                                               CndEv  259
      ENDIF                                                                     CndEv  260
      QrejTop = Qsct(Ttop)                                                      CndEv  261
      IF (Qtop .le. QrejTop)  THEN                                              CndEv  262
c              Qtop insufficient for load - SCT floats                          CndEv  263
        FanSpeed = 4                                                            CndEv  264
        FankWr   = 1.                                                           CndEv  265
        CFMr     = 1.                                                           CndEv  266
        Call EvapFloatingSCT                                                    CndEv  267
        GOTO 3170                                                               CndEv  268
      ENDIF                                                                     CndEv  269
c                                                                               CndEv  270
c              Repeat for capacity at bottom of throttling range                CndEv  271
      IF (Tbot .GE. Twb2)  THEN                                                 CndEv  272
        Qbot = <cd;NormalCap> * Curve(Jcd,<cd:CAP-fSCT&WB>,Tbot,Twb)            CndEv  273
      ELSEIF (Tbot .GT. Twb)  THEN                                              CndEv  274
c              close to wetbulb - interpolate to 0 capacity at wetbulb          CndEv  275
        Qbot = <cd;NormalCap> * CapfTwb2 * (Tbot-Twb) / 2.                      CndEv  276
      ELSE                                                                      CndEv  277
c              Tbot is below wetbulb                                            CndEv  278
        Qbot = 0.                                                               CndEv  279
        Tbot = Twb                                                              CndEv  280
      ENDIF                                                                     CndEv  281
      QrejBot = Qsct(Tbot)                                                      CndEv  282
      IF (Qbot*<cd;CapOff> .GE. QrejBot)  THEN                                  CndEv  283
c              Convective capacity is greater than load - SCT floats            CndEv  284
        FanSpeed = 0                                                            CndEv  285
        FankWr   = 0.                                                           CndEv  286
        CFMr     = <cd:FAN-OFF-AIR>                                             CndEv  287
        Call EvapFloatingSCT                                                    CndEv  288
        GOTO 3170                                                               CndEv  289
      ENDIF                                                                     CndEv  290
      Qbot = MAX(0., Qbot)                                                      CndEv  291
c                                                                               CndEv  292
c              Capacity at Tsetpt                                               CndEv  293
      IF (Tsetpt .GE. Twb2)  THEN                                               CndEv  294
        Qset = <cd;NormalCap>*Curve(Jcd,<cd:CAP-fSCT&WB>,Tsetpt,Twb)            CndEv  295
      ELSEIF (Tsetpt .GT. Twb)  THEN                                            CndEv  296
c              close to wetbulb - interpolate to 0 capacity at wetbulb          CndEv  297
        Qset = <cd;NormalCap> * CapfTwb2 * (Tsetpt-Twb) / 2.                    CndEv  298
      ELSE                                                                      CndEv  299
c              Tsetpt is below wetbulb                                          CndEv  300
        Qset   = 0.                                                             CndEv  301
        Tsetpt = Twb                                                            CndEv  302
      ENDIF                                                                     CndEv  303
      Qset    = MAX(0., Qset)                                                   CndEv  304
      QrejSet = Qsct(Tsetpt)                                                    CndEv  305
c                                                                               CndEv  306
c              Fan capacity control sequences                                   CndEv  307
      SELECT CASE (<cd:CAPACITY-CTRL>)                                          CndEv  308
        CASE (1)                                                                CndEv  309
c              Single-speed fan.  Condenser may be floating with fan            CndEv  310
c              off, cycling off/hi, or floating with fan hi.  The fan           CndEv  311
c              will stay in its last operating mode unless the resulting        CndEv  312
c              temperature exceeds the max/min limits.                          CndEv  313
c                                                                               CndEv  314
c              FanSpeed is operating mode:                                      CndEv  315
c                = 0  Fan off                                                   CndEv  316
c                  1  Cycling off/hi                                            CndEv  317
c                  4  Fan on hi                                                 CndEv  318
c                                                                               CndEv  319
c               Initial                                                         CndEv  320
c              FanSpeed      Tbot        Tsetpt      Ttop                       CndEv  321
c                  0     0000000000000000000000000000000>4444                   CndEv  322
c                  4     0000<4444444444444444444444444444444                   CndEv  323
c                                                                               CndEv  324
 3132     SELECT CASE (FanSpeed)                                                CndEv  325
            CASE (0,1)  ! Off or cycling off/hi                                 CndEv  326
              IF (Qtop*<cd;CapOff> .GE. QrejTop)  THEN                          CndEv  327
c                 Floating with fan off                                         CndEv  328
                FanSpeed = 0                                                    CndEv  329
                FankWr   = 0.                                                   CndEv  330
                CFMr     = <cd:FAN-OFF-AIR>                                     CndEv  331
                Call EvapFloatingSCT                                            CndEv  332
                GOTO 3170                                                       CndEv  333
              ELSEIF (Qbot .LE. QrejBot)  THEN                                  CndEv  334
c                 Fan on high                                                   CndEv  335
                FanSpeed = 4                                                    CndEv  336
                GOTO 3132                                                       CndEv  337
              ELSE                                                              CndEv  338
c                 Cycling off/hi                                                CndEv  339
                FanSpeed = 1                                                    CndEv  340
c                 get fraction of hour on high, and average cd.SCT              CndEv  341
                Call Condenser_EvapCycle(Jcd,                                   CndEv  342
     &                Tbot, Ttop, <cd;CapOff>, 1., FracHi, xx)                  CndEv  343
c                 cycling fan energy and flow                                   CndEv  344
                FankWr   = FracHi                                               CndEv  345
                CFMr     = FracHi                                               CndEv  346
              ENDIF                                                             CndEv  347
            CASE (4)  ! On                                                      CndEv  348
              IF (Qbot .GT. QrejBot)  THEN                                      CndEv  349
c                 Fan will not run continuously                                 CndEv  350
                FanSpeed = 0                                                    CndEv  351
                GOTO 3132                                                       CndEv  352
              ELSE                                                              CndEv  353
c                 floating with fan on                                          CndEv  354
                FanSpeed = 4                                                    CndEv  355
                FankWr   = 1.                                                   CndEv  356
                CFMr     = 1.                                                   CndEv  357
                Call EvapFloatingSCT                                            CndEv  358
                GOTO 3170                                                       CndEv  359
              ENDIF                                                             CndEv  360
          END SELECT  ! FanSpeed                                                CndEv  361
c                                                                               CndEv  362
        CASE (2)                                                                CndEv  363
c              Two-speed fan.  Condenser may be floating with fan off,          CndEv  364
c              cycling off/low, floating on low, cycling low/high, or           CndEv  365
c              floating on high.  The fan will stay in its last                 CndEv  366
c              operating mode unless the resulting temperature exceeds          CndEv  367
c              the max/min limits.                                              CndEv  368
c                                                                               CndEv  369
c              FanSpeed is operating mode:                                      CndEv  370
c                = 0  Fan off                                                   CndEv  371
c                  1  Cycling off/low                                           CndEv  372
c                  2  Fan on low                                                CndEv  373
c                  3  Cycling low/hi                                            CndEv  374
c                  4  Fan on hi                                                 CndEv  375
c                                                                               CndEv  376
c               Initial                                                         CndEv  377
c              FanSpeed      Tbot        Tsetpt      Ttop                       CndEv  378
c                  0     0000000000000000000>22222222222>4444                   CndEv  379
c                  2     0000<22222222222222222222222222>4444                   CndEv  380
c                  4     0000<2222222222222<44444444444444444                   CndEv  381
c                                                                               CndEv  382
 3534     SELECT CASE (FanSpeed)                                                CndEv  383
            CASE (0,1)  ! Off or cycling off/low                                CndEv  384
              IF (Qset*<cd;CapOff> .GE. QrejSet)  THEN                          CndEv  385
c                 Floating with fan off                                         CndEv  386
                FanSpeed = 0                                                    CndEv  387
                FankWr   = 0.                                                   CndEv  388
                CFMr     = <cd:FAN-OFF-AIR>                                     CndEv  389
                Call EvapFloatingSCT                                            CndEv  390
                GOTO 3170                                                       CndEv  391
              ELSEIF (Qset*<cd;CapLow> .LE. QrejSet)  THEN                      CndEv  392
c                 At least low speed                                            CndEv  393
                FanSpeed = 2                                                    CndEv  394
                GOTO 3534                                                       CndEv  395
              ELSE                                                              CndEv  396
c                 Cycling off/low                                               CndEv  397
                FanSpeed = 1                                                    CndEv  398
c                 get fraction of hour on low, and average cd.SCT               CndEv  399
                Call Condenser_EvapCycle(Jcd,                                   CndEv  400
     &              Tbot, Tsetpt, <cd;CapOff>, <cd;CapLow>, FracLow, xx)        CndEv  401
                FankWr   = <cd:FAN-LOW-PWR> * FracLow                           CndEv  402
                CFMr     = <cd:FAN-LOW-AIR> * FracLow                           CndEv  403
     &                   + <cd:FAN-OFF-AIR> * (1.-FracLow)                      CndEv  404
              ENDIF                                                             CndEv  405
            CASE (2)  ! Low speed                                               CndEv  406
              IF (Qbot*<cd;CapLow> .GT. QrejBot)  THEN                          CndEv  407
c                 Fan off or cycling off/low                                    CndEv  408
                FanSpeed = 0                                                    CndEv  409
                GOTO 3534                                                       CndEv  410
              ELSEIF (Qtop*<cd;CapLow> .LT. QrejTop)  THEN                      CndEv  411
c                 Fan on high or cycling low/high                               CndEv  412
                FanSpeed = 4                                                    CndEv  413
                GOTO 3534                                                       CndEv  414
              ELSE                                                              CndEv  415
c                 Fan floating on low                                           CndEv  416
                FanSpeed = 2                                                    CndEv  417
                FankWr   = <cd:FAN-LOW-PWR>                                     CndEv  418
                CFMr     = <cd:FAN-LOW-AIR>                                     CndEv  419
                Call EvapFloatingSCT                                            CndEv  420
                GOTO 3170                                                       CndEv  421
              ENDIF                                                             CndEv  422
            CASE (3,4)  ! High or cycling low/high                              CndEv  423
              IF (Qset .LE. QrejSet)  THEN                                      CndEv  424
c                 Fan floating on high                                          CndEv  425
                FanSpeed = 4                                                    CndEv  426
                FankWr   = 1.                                                   CndEv  427
                CFMr     = 1.                                                   CndEv  428
                Call EvapFloatingSCT                                            CndEv  429
                GOTO 3170                                                       CndEv  430
              ELSEIF (Qtop*<cd;CapLow> .GT. QrejTop)  THEN                      CndEv  431
c                 Low speed can handle load                                     CndEv  432
                FanSpeed = 2                                                    CndEv  433
                GOTO 3534                                                       CndEv  434
              ELSE                                                              CndEv  435
c                 Cycling low/hi                                                CndEv  436
                FanSpeed = 3                                                    CndEv  437
c                 get fraction of hour on high, and average cd.SCT              CndEv  438
                Call Condenser_EvapCycle(Jcd,                                   CndEv  439
     &              Tsetpt, Ttop, <cd;CapLow>, 1., FracHi, xx)                  CndEv  440
                FracLow  = 1. - FracHi                                          CndEv  441
                FankWr   = FracLow*<cd:FAN-LOW-PWR> + FracHi                    CndEv  442
                CFMr     = FracLow*<cd:FAN-LOW-AIR> + FracHi                    CndEv  443
              ENDIF                                                             CndEv  444
          END SELECT  ! FanSpeed                                                CndEv  445
c                                                                               CndEv  446
        CASE (3,4)                                                              CndEv  447
c              Variable-speed fan or modulating damper.  Condenser may          CndEv  448
c              be floating with fan off, cycling off/minimum, or                CndEv  449
c              modulating to setpoint.  The fan will stay in its last           CndEv  450
c              operating mode unless the resulting temperature exceeds          CndEv  451
c              the max/min limits.                                              CndEv  452
c                                                                               CndEv  453
c              FanSpeed is operating mode:                                      CndEv  454
c                = 0  Fan off                                                   CndEv  455
c                  1  Cycling off/minimum                                       CndEv  456
c                  4  Fan maximum                                               CndEv  457
c                  5  Fan modulating                                            CndEv  458
c                                                                               CndEv  459
c               Initial                                                         CndEv  460
c              FanSpeed      Tbot        Tsetpt      Ttop                       CndEv  461
c                  0     0000000000000000000>5555555555555555                   CndEv  462
c                  5     0000<5555555555555555555555555555555                   CndEv  463
c                                                                               CndEv  464
 3536     SELECT CASE (FanSpeed)                                                CndEv  465
            CASE (0,1)  ! Off or cycling off/minimum                            CndEv  466
              IF (Qset*<cd;CapOff> .GE. QrejSet)  THEN                          CndEv  467
c                 Floating with fan off                                         CndEv  468
                FanSpeed = 0                                                    CndEv  469
                FankWr   = 0.                                                   CndEv  470
                CFMr     = <cd:FAN-OFF-AIR>                                     CndEv  471
                Call EvapFloatingSCT                                            CndEv  472
                GOTO 3170                                                       CndEv  473
              ELSEIF (Qbot*<cd;CapLow> .LE. QrejBot)  THEN                      CndEv  474
c                 Fan modulating                                                CndEv  475
                FanSpeed = 5                                                    CndEv  476
                GOTO 3536                                                       CndEv  477
              ELSE                                                              CndEv  478
c                 Cycling off/minimum                                           CndEv  479
                FanSpeed = 1                                                    CndEv  480
c                 get fraction of hour on low, and average cd.SCT               CndEv  481
                Call Condenser_EvapCycle(Jcd,                                   CndEv  482
     &              Tbot, Tsetpt, <cd;CapOff>, -1., FracOn, EfanOn)             CndEv  483
                FankWr = FracOn*EfanOn                                          CndEv  484
                CFMr   = -88888.                                                CndEv  485
              ENDIF                                                             CndEv  486
            CASE (4,5)  ! Modulating                                            CndEv  487
              IF (Qbot*<cd;CapLow> .GT. QrejBot)  THEN                          CndEv  488
c                 Fan will not run continuously                                 CndEv  489
                FanSpeed = 0                                                    CndEv  490
                GOTO 3536                                                       CndEv  491
              ELSE                                                              CndEv  492
c                 Fan is modulating.  Solve for balance point                   CndEv  493
                FanSpeed = 5                                                    CndEv  494
                Tmin     = Tbot                                                 CndEv  495
                Qmin     = Qbot * <cd;CapLow>                                   CndEv  496
                Tmax     = Ttop                                                 CndEv  497
                Qmax     = Qtop                                                 CndEv  498
                Qrej     = Qsct(<cd.SCT>)                                       CndEv  499
                DO  iCount=1,100                                                CndEv  500
                  Ratio = (Qrej-Qmin) / (Qmax-Qmin)                             CndEv  501
                  SCT   = Tmin + (Tmax-Tmin)*Ratio                              CndEv  502
                  Qrej  = Qsct(SCT)                                             CndEv  503
                  IF (SCT .GT. Twb2)  THEN                                      CndEv  504
                    Qcap = <cd;NormalCap>                                       CndEv  505
     &                          * Curve(Jcd,<cd:CAP-fSCT&WB>,SCT,Twb)           CndEv  506
                  ELSE                                                          CndEv  507
c                      close to wetbulb - interpolate to 0 capacity at wetbulb  CndEv  508
                    Qcap = <cd;NormalCap> * CapfTwb2 * (SCT-Twb) / 2.           CndEv  509
                  ENDIF                                                         CndEv  510
c                      adjust for fan speed                                     CndEv  511
                  Ratio = (SCT-Tbot) / (Ttop-Tbot)                              CndEv  512
                  CFMr  = <cd:FAN-MIN-AIR> +(1.-<cd:FAN-MIN-AIR>)*Ratio         CndEv  513
                  Qcap  = Qcap * Curve(Jcd,<cd:CAP-fAIRFLOW>, CFMr,x)           CndEv  514
                  Qcap  = MAX(0., Qcap)                                         CndEv  515
                  IF (ABS(1.-Qcap/Qrej) .LT. ErrorMax)  EXIT                    CndEv  516
                  IF (Qcap .LT. Qrej)  THEN                                     CndEv  517
                    Qmin = Qcap                                                 CndEv  518
                    Tmin = SCT                                                  CndEv  519
                  ELSE                                                          CndEv  520
                    Qmax = Qcap                                                 CndEv  521
                    Tmax = SCT                                                  CndEv  522
                  ENDIF                                                         CndEv  523
                  IF (iCount .EQ. 100)  CALL CnvgMsg2(1, Routine, Jcd)          CndEv  524
                ENDDO                                                           CndEv  525
c                 Fan power ratio, airflow ratio, and SCT                       CndEv  526
                FankWr    = Curve(Jcd,<cd:FAN-KW-fAIR>, CFMr,x)                 CndEv  527
                <cd.SCT>  = SCT                                                 CndEv  528
                <cd.Qrej> = Qrej                                                CndEv  529
              ENDIF                                                             CndEv  530
          END SELECT  ! FanSpeed                                                CndEv  531
c                                                                               CndEv  532
      END SELECT ! cd:CAPACITY-CTRL                                             CndEv  533
c                                                                               CndEv  534
c                                                                               CndEv  535
c------------- MISCELLANEOUS -------------------------------------------------- CndEv  536
c                                                                               CndEv  537
c              Re-entry point for floating SCT                                  CndEv  538
 3170 CONTINUE                                                                  CndEv  539
c                                                                               CndEv  540
c              Outlet setpoint, pressure, enthalpy                              CndEv  541
      <cd.Tsetpt>    = Tsetpt                                                   CndEv  542
      <ro.Poutlet>   = RefgP_fT(Jre, <cd.SCT>)                                  CndEv  543
      <cd.dTsubcool> = <cd:SUBCOOL-EFF> * (<cd.SCT>-WBT)                        CndEv  544
      <ro.Houtlet>   = RefgH_Liquid_fTS(Jre, <cd.SCT>,<cd.dTsubcool>)           CndEv  545
c              inlet pressure, adjusted for condenser pressure drop             CndEv  546
      dP = <cd:CONDENSER-DP> * (Mcycle*<cd;1/Mtotal>)**1.87                     CndEv  547
      <ri.Pinlet> = <ro.Poutlet> + dP                                           CndEv  548
c                                                                               CndEv  549
c              Re-entry point when condenser is off                             CndEv  550
 3190 <ro.Qoutlet> = <ro.Moutlet> * (<Xri.Hinlet>-<ro.Houtlet>)                 CndEv  551
      <cd.Qrej>    = <ro.Qoutlet>                                               CndEv  552
c                                                                               CndEv  553
c              Power consumption of fans and spray pumps. If cycling,           CndEv  554
c              assume spray pump runs 5 mins after shutdown, 2x/hr              CndEv  555
      IF (<cd.Qrej> .GT. 0.)  THEN                                              CndEv  556
        <cd.FankWr>   = FankWr                                                  CndEv  557
        <cd.FankW>    = <cd;FanKWdes> * FankWr * <ro.RunFrac>                   CndEv  558
        <cd.SpraykW>  = <cd;SprayKWdes> * Min(1., <ro.RunFrac>+0.167)           CndEv  559
        <cd.FanSpeed> = FanSpeed                                                CndEv  560
        <cd.CFMr>     = CFMr                                                    CndEv  561
      ELSE                                                                      CndEv  562
        <cd.FankWr>   = 0.                                                      CndEv  563
        <cd.FankW>    = 0.                                                      CndEv  564
        <cd.SpraykW>  = 0.                                                      CndEv  565
        <cd.FanSpeed> = 0                                                       CndEv  566
        <cd.CFMr>     = 0.                                                      CndEv  567
      ENDIF                                                                     CndEv  568
      ElecKW = <cd.FankW> + <cd.SpraykW>                                        CndEv  569
      IF (<cd:AUX-METER> .GT. 0)  THEN                                          CndEv  570
        Kmd       = <cd:AUX-METER>                                              CndEv  571
        <md.Elec> = AuxKWh                                                      CndEv  572
      ELSE                                                                      CndEv  573
        ElecKW = ElecKW + AuxKwh                                                CndEv  574
      ENDIF                                                                     CndEv  575
      Kmd       = <cd:ELEC-METER>                                               CndEv  576
      <md.Elec> = ElecKW                                                        CndEv  577
c                                                                               CndEv  578
c              check for convergence                                            CndEv  579
                                                                                CndEv  580
      IF (Mode .EQ. 31)  THEN                                                   CndEv  581
        CALL CnvgCheck(1, <cd;EnergyHsty>)  ! Loads to Plant                    CndEv  582
      ELSE                                                                      CndEv  583
        CALL CnvgCheck(0, <cd;EnergyHsty>)                                      CndEv  584
      ENDIF                                                                     CndEv  585
c                                                                               CndEv  586
c                                                                               CndEv  587
c ============ REPORT CREATION ================================================ CndEv  588
      CASE (50)                                                                 CndEv  589
c                                                                               CndEv  590
c              statistics blocks                                                CndEv  591
      Ks2Load    = NewStat2(Jcd,    <+cd.Qrej>, 0, 1.)                          CndEv  592
      Ks2Flow    = NewStat2(Kro, <+ro.Moutlet>, 0, 1.)                          CndEv  593
      Ks2Elec    = NewStat2(Jcd,   <+cd.FankW>, 0, 1.)                          CndEv  594
      Kli        = 0                                                            CndEv  595
      CALL ListNodes(Kli, 0,0,Jcd,0, 11,2)                                      CndEv  596
      Ks2ElecT   = NewStat2(Kli,    <+md.Elec>, 0, 1.)                          CndEv  597
      Ks5FlowBin = NewStat5(Kro, <+ro.Moutlet>, 0, 1.)                          CndEv  598
      Ks5ElecBin = NewStat5(Kli,    <+md.Elec>, 0, 1.)                          CndEv  599
c                                                                               CndEv  600
c              Create the type "H" report                                       CndEv  601
      IF (<cd:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      CndEv  602
     &  <cd;PS-H> = NewReport_H(Jcd, 132,                                       CndEv  603
     &                          4, 5, 6,                                        CndEv  604
     &                          Ks2Load, Ks2Flow, Ks2Elec, Ks2ElecT,            CndEv  605
     &                          Ks5FlowBin, Ks5ElecBin, 0,                      CndEv  606
     &                          0, 0, 0)                                        CndEv  607
c                                                                               CndEv  608
c              Setpoint overload                                                CndEv  609
      <cd;s10> = NewStat10(Jcd, <#cd.Tsetpt>, <#cd.SCT>,                        CndEv  610
     &                          <rs:SCT-THROTTLE>*0.5, 1, <#cd.Qrej>)           CndEv  611
c                                                                               CndEv  612
c                                                                               CndEv  613
c ============ REPORT ORDER =================================================== CndEv  614
      CASE (52)                                                                 CndEv  615
c                                                                               CndEv  616
      Call Report_H(Mode, <cd;PS-H>)                                            CndEv  617
c                                                                               CndEv  618
c                                                                               CndEv  619
c ============ REPORTS - VERIFICATION DATA ==================================== CndEv  620
      CASE (54)                                                                 CndEv  621
c                                                                               CndEv  622
c              Output design information                                        CndEv  623
      IF (<cd;PS-H> .ne. 0)  THEN                                               CndEv  624
        rH = <cd;PS-H>                                                          CndEv  625
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       CndEv  626
        CALL GetAttachments(Jcd, 2)                                             CndEv  627
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   CndEv  628
     &    (NameAttachments(II,1,1),II=1,8),                                     CndEv  629
     &    (NameAttachments(II,1,2),II=1,8),                                     CndEv  630
     &    <cd;Capacity>,<ro.Moutlet>,                                           CndEv  631
     &    <cd;FanKWdes>,<cd;DesignKW>,<cd.Tsetpt>                               CndEv  632
        DO  Irow=2,NumRowsOfAttachments                                         CndEv  633
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 CndEv  634
     &      (NameAttachments(II,Irow,1),II=1,8),                                CndEv  635
     &      (NameAttachments(II,Irow,2),II=1,8)                                 CndEv  636
        ENDDO                                                                   CndEv  637
      ENDIF                                                                     CndEv  638
c                                                                               CndEv  639
c                                                                               CndEv  640
c ============ REPORTS - YEARLY SUMMARY (SPECIAL) ============================= CndEv  641
      CASE (58)                                                                 CndEv  642
c                                                                               CndEv  643
c              Setpoint overload                                                CndEv  644
      IF (<cd;PS-H> .ne. 0)  THEN                                               CndEv  645
        rH = <cd;PS-H>                                                          CndEv  646
        CALL Report_s10(<rH;Iuniq>, 7, <cd;s10>)                                CndEv  647
      ENDIF                                                                     CndEv  648
c                                                                               CndEv  649
c                                                                               CndEv  650
c ============ HOURLY REPORTS - HOURLY DATA =================================== CndEv  651
      CASE (62)                                                                 CndEv  652
c                                                                               CndEv  653
      IF (<cd;HourRepBuf> .EQ. 0)  RETURN                                       CndEv  654
      Twb = MIN(MAX(WBT, 20.), 90.)                                             CndEv  655
c                                                                               CndEv  656
      IAptr = <cd;HourRepBuf> - 1                                               CndEv  657
      AA(IAptr+1)  = <cd.Qrej>                                                  CndEv  658
      AA(IAptr+2)  = <cd.OpCap>                                                 CndEv  659
      AA(IAptr+3)  = <ro.Moutlet>                                               CndEv  660
      AA(IAptr+4)  = <cd.Tsetpt>                                                CndEv  661
      AA(IAptr+5)  = <cd.SCT>                                                   CndEv  662
      AA(IAptr+6)  = <cd.dTsubcool>                                             CndEv  663
      AA(IAptr+7)  = <cd.SCT> - Twb                                             CndEv  664
      AA(IAptr+8)  = Twb                                                        CndEv  665
      AA(IAptr+9)  = <cd.FankWr>                                                CndEv  666
      AA(IAptr+10) = <cd.FankW>                                                 CndEv  667
      AA(IAptr+11) = <cd.SpraykW>                                               CndEv  668
      AA(IAptr+12) = <Xri.Hinlet>                                               CndEv  669
      AA(IAptr+13) = <ro.Houtlet>                                               CndEv  670
      AA(IAptr+17) = <ro.RunFrac>                                               CndEv  671
c                                                                               CndEv  672
c                                                                               CndEv  673
c ============ DESIGN CALCULATIONS ============================================ CndEv  674
      CASE (111)                                                                CndEv  675
c                                                                               CndEv  676
c              This call calculates the design capacity and flow                CndEv  677
c                                                                               CndEv  678
c              Design wetbulb and setpoint                                      CndEv  679
      <cd.Tsetpt> = <rs:DESIGN-SCT>                                             CndEv  680
      Twb         = <rs:DESIGN-WETBUL>                                          CndEv  681
      IF (<cd.Tsetpt> .LT. Twb+5.)  THEN                                        CndEv  682
        Tsetpt = Twb + 5.                                                       CndEv  683
        CALL MSGSIM(-3,II,II,II,II)                                             CndEv  684
        WRITE (IOUTPT,9001)  (<cd:NAME>,II=1,8), Twb, <cd.Tsetpt>,              CndEv  685
     &                        Tsetpt                                            CndEv  686
        <cd.Tsetpt> = Tsetpt                                                    CndEv  687
      ENDIF                                                                     CndEv  688
c                                                                               CndEv  689
c              Rated and design capacity factors                                CndEv  690
      CapfRated  = Curve(Jcd,<cd:CAP-fSCT&WB>,<cd:RATED-SCT>,                   CndEv  691
     &                                        <cd:RATED-WETBULB>)               CndEv  692
      CapfDesign = Curve(Jcd,<cd:CAP-fSCT&WB>,<cd.Tsetpt>,Twb)                  CndEv  693
c                                                                               CndEv  694
c              Outlet pressure, enthalpy, and enthalpy differential             CndEv  695
      <ro.Poutlet> = RefgP_fT(Jre, <cd.Tsetpt>)                                 CndEv  696
      dTsubcool    = <cd:SUBCOOL-EFF> * (<cd.Tsetpt>-Twb)                       CndEv  697
      <ro.Houtlet> = RefgH_Liquid_fTS(Jre, <cd.Tsetpt>, dTsubcool)              CndEv  698
      dHrefg       = <Xri.Hinlet> - <ro.Houtlet>                                CndEv  699
                                                                                CndEv  700
      IF (<cd:RATED-CAPACIT> .GT. 0.)  THEN                                     CndEv  701
        <cd;Capacity> = <cd:RATED-CAPACIT>*<cd:CLASS-FACTOR> / CapfRated        CndEv  702
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndEv  703
     &    <cd;Capacity> = <cd;Capacity> * <cd:CAP-RATIO>                        CndEv  704
      ELSE                                                                      CndEv  705
        IF (<cd:CAP-RATIO> .GT. 0.)  THEN                                       CndEv  706
          <cd;Capacity> = <Xri.Minlet> * dHrefg * <cd:CAP-RATIO>                CndEv  707
        ELSE                                                                    CndEv  708
c              no capacity ratio specified - size equipment equally             CndEv  709
          Kli = <Xro;Xnode>                                                     CndEv  710
          IF (Kli .EQ. Kro)  THEN                                               CndEv  711
c              this condenser is the only attachment                            CndEv  712
            <cd;Capacity> = <Xri.Minlet> * dHrefg                               CndEv  713
          ELSE  ! this condenser is one in a list                               CndEv  714
            <cd;Capacity> = <Xri.Minlet> * dHrefg / FLOAT(<li;NumItems>)        CndEv  715
          ENDIF                                                                 CndEv  716
        ENDIF                                                                   CndEv  717
        <cd;Capacity> = <cd;Capacity> / CapfDesign                              CndEv  718
      ENDIF  ! cd:RATED-CAPACIT                                                 CndEv  719
c                                                                               CndEv  720
c              Design refrigerant flow                                          CndEv  721
      IF (<cd:RATED-FLOW> .GT. 0.)  THEN                                        CndEv  722
        RatedMrefg = <cd:RATED-FLOW>                                            CndEv  723
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndEv  724
     &    RatedMrefg = RatedMrefg * <cd:CAP-RATIO>                              CndEv  725
        <ro.Moutlet> = RatedMrefg / CapfRated                                   CndEv  726
      ELSE                                                                      CndEv  727
        <ro.Moutlet> = <cd;Capacity> / dHrefg                                   CndEv  728
        RatedMrefg   = <ro.Moutlet> * CapfRated                                 CndEv  729
      ENDIF                                                                     CndEv  730
c              translate to design point                                        CndEv  731
      <ro.Moutlet> = <ro.Moutlet> * CapfDesign                                  CndEv  732
c              inlet flow and pressure                                          CndEv  733
      <ri.Minlet> = <ro.Moutlet>                                                CndEv  734
      IF (RatedMrefg .eq. 0.)  THEN                                             CndEv  735
        dP = <cd:CONDENSER-DP>                                                  CndEv  736
      ELSE                                                                      CndEv  737
        <cd;1/Mtotal> = 1. / RatedMrefg                                         CndEv  738
        dP = <cd:CONDENSER-DP> * (<ro.Moutlet>*<cd;1/Mtotal>)**1.87             CndEv  739
      ENDIF                                                                     CndEv  740
      <ri.Pinlet> = <ro.Poutlet> + dP                                           CndEv  741
c                                                                               CndEv  742
c              Capacity w/o subcooling - this will be used hourly               CndEv  743
      dHsubcool = dTsubcool * RefgCp_Liquid_fT(Jre, <cd.Tsetpt>)                CndEv  744
      Qsubcool  = RatedMrefg * dHsubcool                                        CndEv  745
      RatedCap  = <cd;Capacity> * CapfRated                                     CndEv  746
      <cd;NormalCap> = (RatedCap-Qsubcool) / CapfRated                          CndEv  747
c                                                                               CndEv  748
c              Condenser fan energy                                             CndEv  749
      IF (<cd:KW/FAN> .GT. 0.)  THEN                                            CndEv  750
        <cd;FanKWdes> = <cd:KW/FAN> * <cd:NUM-OF-FANS>                          CndEv  751
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndEv  752
     &    <cd;FanKWdes> = <cd;FanKWdes> * <cd:CAP-RATIO>                        CndEv  753
      ELSE                                                                      CndEv  754
        <cd;FanKWdes> = <cd;Capacity>                                           CndEv  755
     &                * Curve(Jcd,<cd:CAP-fSCT&WB>,<cd:EIR-RATED-SCT>,          CndEv  756
     &                                             <cd:EIR-RATED-WB>)           CndEv  757
     &                * <cd:FAN-EIR> * KWBTU                                    CndEv  758
      ENDIF                                                                     CndEv  759
c              Condenser spray pump not simulated using pump component          CndEv  760
c              because constant kW all hours of operation                       CndEv  761
      IF (<cd:SPRAY-KW> .GT. 0.)  THEN                                          CndEv  762
        <cd;SprayKWdes> = <cd:SPRAY-KW>                                         CndEv  763
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndEv  764
     &    <cd;SprayKWdes> = <cd;SprayKWdes> * <cd:CAP-RATIO>                    CndEv  765
      ELSE                                                                      CndEv  766
        <cd;SprayKWdes> = <cd;Capacity>                                         CndEv  767
     &                  * Curve(Jcd,<cd:CAP-fSCT&WB>,<cd:EIR-RATED-SCT>,        CndEv  768
     &                                               <cd:EIR-RATED-WB>)         CndEv  769
     &                  * <cd:SPRAY-EIR> * KWBTU                                CndEv  770
      ENDIF                                                                     CndEv  771
c              Store electrical consumption                                     CndEv  772
      Kmd       = <cd:ELEC-METER>                                               CndEv  773
      <md.Elec> = <cd;FanKWdes> + <cd;SprayKWdes>                               CndEv  774
      IF (<cd:AUX-METER> .GT. 0)  THEN                                          CndEv  775
        Kmd       = <cd:AUX-METER>                                              CndEv  776
        <md.Elec> = <cd:AUX-KW>                                                 CndEv  777
      ENDIF                                                                     CndEv  778
c                                                                               CndEv  779
c                                                                               CndEv  780
c ============ DESIGN RECONCILIATION ========================================== CndEv  781
      CASE (119)                                                                CndEv  782
c                                                                               CndEv  783
      IF (<cd;Capacity> .EQ. 0.)  THEN                                          CndEv  784
        CALL MSGSIM(-2,II,II,II,II)                                             CndEv  785
        WRITE (IOUTPT,9002)  (<cd:NAME>,II=1,8)                                 CndEv  786
      ENDIF                                                                     CndEv  787
c                                                                               CndEv  788
      <ro;DesMoutlet>   = <ro.Moutlet>                                          CndEv  789
      ErrorMax          = <sp:ERROR-LOAD> * 0.2                                 CndEv  790
      <cd;NumFanStages> = INT(<cd:NUM-OF-FANS> + 0.1)                           CndEv  791
c                                                                               CndEv  792
c              Capacity and fan power at reduced airflows                       CndEv  793
      <cd;CapOff> = Curve(Jcd,<cd:CAP-fAIRFLOW>, <cd:FAN-OFF-AIR>,x)            CndEv  794
      <cd;CapOff> = Max(0., <cd;CapOff>)                                        CndEv  795
      SELECT CASE (<cd:CAPACITY-CTRL>)                                          CndEv  796
        CASE (0,1)  ! None or cycling                                           CndEv  797
          IF (<rs:SCT-CTRL> .EQ. 8)  THEN                                       CndEv  798
c              Temperature control strategy is LOAD-RESET; the                  CndEv  799
c              condenser fan must be 2-speed, variable-speed or                 CndEv  800
c              damper.                                                          CndEv  801
            CALL MSGSIM(-2,II,II,II,II)                                         CndEv  802
            WRITE (IOUTPT,9003)  (<cd:NAME>,II=1,8)                             CndEv  803
          ENDIF                                                                 CndEv  804
        CASE (2)  ! Two-speed fan                                               CndEv  805
          <cd;CapLow> = Curve(Jcd,<cd:CAP-fAIRFLOW>, <cd:FAN-LOW-AIR>,x)        CndEv  806
          IF (<cd:FAN-LOW-PWR> .EQ. 0.)  <cd:FAN-LOW-PWR> =                     CndEv  807
     &                  Curve(Jcd,<cd:FAN-KW-fAIR>, <cd:FAN-LOW-AIR>,x)         CndEv  808
        CASE (3,4)  ! Variable-speed fan, damper                                CndEv  809
          <cd:FAN-MIN-AIR> = MAX(<cd:FAN-MIN-AIR>, <cd:FAN-OFF-AIR>)            CndEv  810
          <cd;CapLow> = Curve(Jcd,<cd:CAP-fAIRFLOW>, <cd:FAN-MIN-AIR>,x)        CndEv  811
          <cd:FAN-LOW-PWR> = Curve(Jcd,<cd:FAN-KW-fAIR>,                        CndEv  812
     &                                              <cd:FAN-MIN-AIR>,x)         CndEv  813
      END SELECT                                                                CndEv  814
c                                                                               CndEv  815
c              Total electrical consumption, excluding pan heater               CndEv  816
      <cd;DesignKW> = <cd;FanKWdes> + <cd:AUX-KW>                               CndEv  817
     &              + <cd;SprayKWdes>                                           CndEv  818
c                                                                               CndEv  819
c              Set up the pan heater if required                                CndEv  820
      IF (<cd:PAN-HTR-TYPE> .NE. NoPanHtr)  THEN                                CndEv  821
        IF (<cd:PAN-LOSS> .EQ. 0.)  THEN                                        CndEv  822
            <cd:PAN-LOSS> = <cd;Capacity>                                       CndEv  823
     &                    * <cd:PAN-LOSS-RATI>                                  CndEv  824
        ELSE                                                                    CndEv  825
            <cd:PAN-LOSS> = -<cd:PAN-LOSS>                                      CndEv  826
        ENDIF                                                                   CndEv  827
c              effective loss coefficient                                       CndEv  828
        Tair = <cd:PAN-AMBIENT-T>                                               CndEv  829
        Tpan = <cd:PAN-FLUID-T>                                                 CndEv  830
        dT   = Tair - Tpan                                                      CndEv  831
        IF (dT .GE. 0.)  THEN                                                   CndEv  832
          CALL MSGSIM(-1,II,II,II,II)                                           CndEv  833
          WRITE (IOUTPT, 9004)  (<cd:NAME>,II=1,8), Tair, Tpan                  CndEv  834
          CALL MessageBox( NULL,                                                CndEv  835
     &      'Pan loss design parameters are inconsistent'//char(0),             CndEv  836
     &      'CONDENSER Errors'//char(0),                                        CndEv  837
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                CndEv  838
          IwinReturn = 1                                                        CndEv  839
          RETURN                                                                CndEv  840
        ENDIF                                                                   CndEv  841
        <cd;PanUA> = <cd:PAN-LOSS>                                              CndEv  842
     &             / (dT * SurfaceFilmAdj(Tpan,Tair,<cd:PAN-WINDSPEED>))        CndEv  843
        IF (<cd:PAN-HTR-LOOP> .GT. 0)  THEN                                     CndEv  844
          Jpl = <cd:PAN-HTR-LOOP>                                               CndEv  845
c              design dT                                                        CndEv  846
C ??     IF (<cd:PAN-HTR-DT> .EQ. 0.)                                           CndEv  847
C ?? &        <cd:PAN-HTR-DT> = -ABS(<lp:DESIGN-DT>)                            CndEv  848
c              design flow                                                      CndEv  849
          <cd;DesignPanGPM> = -<cd:PAN-LOSS>                                    CndEv  850
     &                               / (<pl.Btuh/GPM-F>*<cd:PAN-HTR-DT>)        CndEv  851
        ENDIF                                                                   CndEv  852
      ENDIF                                                                     CndEv  853
c                                                                               CndEv  854
c                                                                               CndEv  855
c ============ ATTACHMENTS ==================================================== CndEv  856
c                                                                               CndEv  857
c              Initial attachments                                              CndEv  858
      CASE (201)                                                                CndEv  859
c              Component pointers, schedules, and curves                        CndEv  860
        <cd:REFG-SYSTEM>   = Jcomponent(29, <cd:REFG-SYSTEM>)                   CndEv  861
        <cd:PAN-HTR-LOOP>  = Jcomponent( 2, <cd:PAN-HTR-LOOP>)                  CndEv  862
        <cd:ELEC-METER>    = Jcomponent(13, <cd:ELEC-METER>)                    CndEv  863
        <cd:AUX-METER>     = Jcomponent(13, <cd:AUX-METER>)                     CndEv  864
        <cd:COST-DATA>     = Jcomponent(18, <cd:COST-DATA>)                     CndEv  865
        <cd:AUX-SCH>       = Jsched(<cd:AUX-SCH>)                               CndEv  866
        <cd:FAN-KW-fAIR>   = Jcurve(<cd:FAN-KW-fAIR>)                           CndEv  867
        <cd:CAP-fSCT&WB>   = Jcurve(<cd:CAP-fSCT&WB>)                           CndEv  868
        <cd:CAP-fAIRFLOW>  = Jcurve(<cd:CAP-fAIRFLOW>)                          CndEv  869
c                                                                               CndEv  870
c              Create nodes                                                     CndEv  871
      CASE (203)                                                                CndEv  872
c              Inlet and outlet nodes                                           CndEv  873
        <cd;InletNode>  = NewNode(1, 0,Jrs,Jcd,Jrs, 65,1,0, 1.)                 CndEv  874
        <cd;OutletNode> = NewNode(1, 0,Jrs,Jcd,Jrs, 65,2,0, 1.)                 CndEv  875
c                                                                               CndEv  876
c              Electric and auxiliary meter                                     CndEv  877
        Jme = <cd:ELEC-METER>                                                   CndEv  878
        <cd:ELEC-METER> = NewNode(1, Jrs,Jrs,Jcd,Jme, 11,2,6, 1.)               CndEv  879
        IF (<cd:AUX-METER> .GT. 0)  THEN                                        CndEv  880
          Jme = <cd:AUX-METER>                                                  CndEv  881
          <cd:AUX-METER> = NewNode(1, Jrs,Jrs,Jcd,Jme, 11,2,6, 1.)              CndEv  882
        ENDIF                                                                   CndEv  883
c              HW pan heater                                                    CndEv  884
        IF (<cd:PAN-HTR-TYPE> .EQ. HWPanHtr)  THEN                              CndEv  885
          <cd;HWInletNode>  = NewNode(1, Jrs,Jrs,Jcd,<cd:PAN-HTR-LOOP>,         CndEv  886
     &                                                       51,1,7, 1.)        CndEv  887
          <cd;HWOutletNode> = NewNode(1, Jrs,Jrs,Jcd,<cd:PAN-HTR-LOOP>,         CndEv  888
     &                                                       52,2,7, 1.)        CndEv  889
        ENDIF                                                                   CndEv  890
c                                                                               CndEv  891
c              Links, lists                                                     CndEv  892
      CASE (205)                                                                CndEv  893
c              Get refrigerant pointer from refg plant                          CndEv  894
        <cd;Refrigerant> = <rs:REFRIGERANT>                                     CndEv  895
c              Get pointer to reference enthalpy from liquid trunk              CndEv  896
c                                                                               CndEv  897
c              Histories                                                        CndEv  898
      CASE (208)                                                                CndEv  899
c              Set up history on outlet conditions                              CndEv  900
        Kli = 0                                                                 CndEv  901
        Kmx = <cd:ELEC-METER>                                                   CndEv  902
        CALL ListAdd(Kli, Kmx)                                                  CndEv  903
        CALL ListAdd(Kli, <cd:AUX-METER>)                                       CndEv  904
        KliX = Kli                                                              CndEv  905
        CALL ListXNodes(Kli, KliX)                                              CndEv  906
        <cd;EnergyHsty> = NewHistory(Jrs,Jrs,Jcd, KliX, Kmx,                    CndEv  907
     &                      0, 0, 1.,                                           CndEv  908
     &                      <#mx.Load>, <sp:ERROR-LOAD>, 2,                     CndEv  909
     &                      0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)             CndEv  910
c              Set up history for hw pan heater                                 CndEv  911
        IF (<cd:PAN-HTR-TYPE> .EQ. HWPanHtr)  THEN                              CndEv  912
          Kli = 0                                                               CndEv  913
          CALL ListAdd(Kli, <cd;HWInletNode>)                                   CndEv  914
          CALL ListAdd(Kli, <cd;HWOutletNode>)                                  CndEv  915
          KliX = Kli                                                            CndEv  916
          CALL ListXNodes(Kli, KliX)                                            CndEv  917
          Kfo = <cd;HWOutletNode>                                               CndEv  918
          <cd;HWOutletHsty> = NewHistory(Jrs,Jrs,Jcd, KliX, Kfo,                CndEv  919
     &                          3, 5, 1.5,                                      CndEv  920
     &                          <#fo.Moutlet2>, <sp:ERROR-FLOW>, 2,             CndEv  921
     &                          <#fo.Toutlet> , <sp:ERROR-T>   , 1,             CndEv  922
     &                          0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                 CndEv  923
        ENDIF                                                                   CndEv  924
c                                                                               CndEv  925
c              Dump pointers                                                    CndEv  926
      CASE (210)                                                                CndEv  927
        IF (<cd;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         CndEv  928
        WRITE (IOUTPT, 9202)  (<cd:NAME>,II=1,8),                               CndEv  929
     &    Jcd, Xri, Kro, Xro, <cd;HWInletNode>, <cd;HWOutletNode>               CndEv  930
c                                                                               CndEv  931
c                                                                               CndEv  932
      END SELECT  ! Mode                                                        CndEv  933
c                                                                               CndEv  934
      RETURN                                                                    CndEv  935
c                                                                               CndEv  936
c              Message formats                                                  CndEv  937
 9001 FORMAT(14x,'Condenser: ',8A4,' has design wetbulb'               /        CndEv  938
     &       14x,'and condensing temperatures of:',2F6.1,' which are'  /        CndEv  939
     &       14x,'unrealistic. The design condensing temperature will' /        CndEv  940
     &       14x,'be reset to:',F6.1                                   )        CndEv  941
 9002 FORMAT(14x,'Condenser: ',8A4,' has no design load'               )        CndEv  942
 9003 FORMAT(14x,'Condenser: ',8A4,' must have a 2-speed or'           /        CndEv  943
     &       14x,'variable-speed fan for the condenser loop LOAD-RESET'/        CndEv  944
     &       14x,'temperature control strategy to work.  The control'  /        CndEv  945
     &       14x,'strategy has been changed to FIXED.'                 )        CndEv  946
 9004 FORMAT(14x,'Condenser: ',8A4,' is specified to have'             /        CndEv  947
     &       14x,'pan losses, but the design outdoor temperature is '  /        CndEv  948
     &       14x,'higher than the design pan temperature.'             /        CndEv  949
     &       14x,'Outdoor T: ',F5.1,' Pan setpoint: ',F5.1             )        CndEv  950
 9201 FORMAT(/' CONDENSERs                             Jcd       Xri',          CndEv  951
     &'       Kro       Xro     HW In    HW Out'                       /        CndEv  952
     &1x,32('-'),6('  --------'))                                               CndEv  953
 9202 FORMAT(1x,8A4,6I10)                                                       CndEv  954
c                                                                               CndEv  955
c                                                                               CndEv  956
      CONTAINS                                                                  CndEv  957
c ============== EvapFloatingSCT ============================================== CndEv  958
      Subroutine EvapFloatingSCT                                                CndEv  959
                                                                                CndEv  960
c              Calculates the SCT for given refrigerant and air flows           CndEv  961
                                                                                CndEv  962
c              Capacity adjusted for airflow; CapfCFM is set if                 CndEv  963
c              SCT-CTRL = always-on or ambient-staged                           CndEv  964
      IF (CapfCFM .gt. 0.)  THEN                                                CndEv  965
        CapCFM = <cd;NormalCap> * CapfCFM                                       CndEv  966
      ELSE                                                                      CndEv  967
        CapCFM = <cd;NormalCap> * Curve(Jcd,<cd:CAP-fAIRFLOW>,CFMr, x)          CndEv  968
      ENDIF                                                                     CndEv  969
c              Initialize heat rejection based on last known SCT                CndEv  970
      Qrej = Qsct(<cd.SCT>)                                                     CndEv  971
                                                                                CndEv  972
c              Solve to find SCT and Qrej                                       CndEv  973
      ErrorMult = 1.                                                            CndEv  974
      Error1    = 1.E20                                                         CndEv  975
      IterQ     = 0                                                             CndEv  976
      DO                                                                        CndEv  977
c              solve for SCT                                                    CndEv  978
        CapfSCT = Qrej / CapCFM                                                 CndEv  979
        IF (CapfSCT .lt. CapfTwb2)  THEN    ! interpolate to wetbulb            CndEv  980
          <cd.SCT> = Twb + 2.*CapfSCT/CapfTwb2                                  CndEv  981
        ELSE                                                                    CndEv  982
          CALL CurveInvert(Jcd,<cd:CAP-fSCT&WB>, 1,<cd.SCT>,Twb,CapfSCT,        CndEv  983
     &                                                             IERR)        CndEv  984
        ENDIF                                                                   CndEv  985
c              solve for saturated heat rejection at this SCT                   CndEv  986
        <cd.Qrej> = Qsct(<cd.SCT>)                                              CndEv  987
        Error     = <cd.Qrej> - Qrej                                            CndEv  988
        IF (Abs(Error/Qrej) .lt. ErrorMax)  Exit                                CndEv  989
        IF (Error/Error1 .lt. -0.5)  ! oscillating strongly                     CndEv  990
     &    ErrorMult = ErrorMult * 0.5                                           CndEv  991
        Qrej   = Qrej + Error * ErrorMult                                       CndEv  992
        Error1 = Error                                                          CndEv  993
        IF (IterQ .eq. 20)  THEN                                                CndEv  994
          CALL CnvgMsg2(1, Routine, Jcd)                                        CndEv  995
          Exit                                                                  CndEv  996
        ENDIF                                                                   CndEv  997
        IterQ  = IterQ + 1                                                      CndEv  998
      ENDDO                                                                     CndEv  999
c                                                                               CndEv 1000
      End Subroutine EvapFloatingSCT                                            CndEv 1001
c                                                                               CndEv 1002
      END                                                                       CndEv 1003
      Subroutine Condenser_EvapCycle(Jcd, Tmin, Tmax, CapMin, CapMax,           CndECy   2
     &                                              FracMax, EfanMax)           CndECy   3
                                                                                CndECy   4
c              When an evaporative condenser is cycling between two             CndECy   5
c              fan modes, such as off/hi, off/low, low/high, etc.,              CndECy   6
c              calculates the fraction of time in the higher mode.              CndECy   7
                                                                                CndECy   8
c              Jcd      Pointer to the condenser                                CndECy   9
c              Tmin     Temperature at bottom of range                          CndECy  10
c              CapMin   Capacity when in minimum mode of operation              CndECy  11
c              Tmax     Temperature at top of range                             CndECy  12
c              CapMax   Capacity when in maximum mode of operation              CndECy  13
c                         -1 means modulating                                   CndECy  14
                                                                                CndECy  15
c              FracMax  Fraction of hour in maximum mode                        CndECy  16
c              EfanMax  For VFD only, weighted kW in maximum mode               CndECy  17
c              cd.SCT   Average SCT during the hour                             CndECy  18
                                                                                CndECy  19
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
                                                                                CndECy  24
      Integer  Xri                                                              CndECy  25
      Real     mCap, mRej                                                       CndECy  26
                                                                                CndECy  27
c              Heat rejection for a given SCT, assuming no subcooling           Qsct     2
      Qsct(SCTx) = Max(1., Mcycle                                               Qsct     3
     &                      * (<Xri.Hinlet>-RefgH_Liquid_fT(Jre, SCTx)))        Qsct     4
                                                                                CndECy  29
      Kri = <cd;InletNode>               ! refrigerant inlet                    CndECy  30
      Xri = <ri;Xnode>                   ! refrigerant Xinlet                   CndECy  31
      Kro = <cd;OutletNode>              ! refrigerant outlet                   CndECy  32
      Jre = <cd;Refrigerant>             ! refrigerant                          CndECy  33
                                                                                CndECy  34
c              Get the weighted capacity in minimum and maximum modes           CndECy  35
      CALL Condenser_EvapCycleMode(Jcd, Tmin, Tmax, CapMin,                     CndECy  36
     &                                          Qmin, SCTmin,      xx)          CndECy  37
      CALL Condenser_EvapCycleMode(Jcd, Tmin, Tmax, CapMax,                     CndECy  38
     &                                          Qmax, SCTmax, EfanMax)          CndECy  39
                                                                                CndECy  40
c              Heat rejection at average temperature of the two modes           CndECy  41
      QrejMax = Qsct(SCTmax)                                                    CndECy  42
      QrejMin = Qsct(SCTmin)                                                    CndECy  43
                                                                                CndECy  44
      dTsct   = SCTmax - SCTmin                                                 CndECy  45
      IF (Abs(dTsct) .lt. 0.000001)  THEN                                       CndECy  46
c              special case where two modes produce identical average           CndECy  47
c              temperatures (don't believe this can actually happen)            CndECy  48
        <cd.SCT> = SCTmax                                                       CndECy  49
        FracMax  = (QrejMax-Qmin) / (Qmax-Qmin)                                 CndECy  50
      ELSE                                                                      CndECy  51
c              Condenser capacity as a function of SCT,                         CndECy  52
c              expressed as y = mx + b; Qcap = mSCT + b                         CndECy  53
        mCap = (Qmax-Qmin) / dTsct                                              CndECy  54
        bCap = Qmin - mCap*SCTmin                                               CndECy  55
c              net heat rejected for a given SCT, expressed as y = mx+b         CndECy  56
        mRej = (QrejMax-QrejMin) / dTsct                                        CndECy  57
        bRej = QrejMin - mRej*SCTmin                                            CndECy  58
c              solve for the intersection of the condenser capacity and         CndECy  59
c              heat rejection                                                   CndECy  60
        <cd.SCT> = (bRej-bCap) / (mCap-mRej)                                    CndECy  61
c              fraction of the hour in the maximum mode                         CndECy  62
        FracMax = (<cd.SCT>-SCTmin) / dTsct                                     CndECy  63
      ENDIF                                                                     CndECy  64
                                                                                CndECy  65
      IF (FracMax .gt. 1.05  .or.  FracMax .lt. -0.05)  THEN                    CndECy  66
        Write (IOUTPT,9101) (<cd:NAME>,II=1,8)                                  CndECy  67
      ENDIF                                                                     CndECy  68
      FracMax = Max(0., Min(1., FracMax))                                       CndECy  69
                                                                                CndECy  70
      Return                                                                    CndECy  71
                                                                                CndECy  72
 9101 Format(14x,' Condenser_EvapCycle Error ', 8A4)                            CndECy  73
      End  ! Condenser_EvapCycleMax                                             CndECy  74
      Subroutine Condenser_EvapCycleMode(Jcd, Tcutout, Tcutin, FanCap,          CndECM   2
     &                                      Qweight, Tweight, Eweight)          CndECM   3
c                                                                               CndECM   4
c              Solves for the average SCT of an evaporative condenser           CndECM   5
c              for one mode (such as On or Off) when the fan is cycling.        CndECM   6
c                                                                               CndECM   7
c              Jcd      Pointer to the condenser                                CndECM   8
c              Tcutout    Temperature fan cycles off                            CndECM   9
c              Tcutin   Temperature fan cycles on                               CndECM  10
c              FanCap   Capacity adjustment for fan speed                       CndECM  11
c                         if -1, then modulating                                CndECM  12
c              Qweight  Weighted heat rejection in range                        CndECM  13
c              Tweight  Weighted SCT in range                                   CndECM  14
c              Eweight  Weighted fan power in range                             CndECM  15
c                                                                               CndECM  16
c              Common block variables                                           CndECM  17
c              Twb      Wetbulb temperature                                     CndECM  18
c              Ttop     Temperature at top of throttling range                  CndECM  19
c              Tbot     Temperature at bottom of throttling range               CndECM  20
c                                                                               CndECM  21
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
c                                                                               CndECM  25
      Integer   Xri                                                             CndECM  26
      Dimension Tbin(5), Qbin(5), Ebin(5), Weight(5), BinSize(5)                CndECM  27
      Data      BinSize /0.5, 1.0, 1.0, 1.0, 0.5/                               CndECM  28
                                                                                CndECM  29
c              Heat rejection for a given SCT, assuming no subcooling           Qsct     2
      Qsct(SCTx) = Max(1., Mcycle                                               Qsct     3
     &                      * (<Xri.Hinlet>-RefgH_Liquid_fT(Jre, SCTx)))        Qsct     4
                                                                                CndECM  31
      Kri = <cd;InletNode>               ! refrigerant inlet                    CndECM  32
      Xri = <ri;Xnode>                   ! refrigerant Xinlet                   CndECM  33
      Kro = <cd;OutletNode>              ! refrigerant outlet                   CndECM  34
      Jre = <cd;Refrigerant>             ! refrigerant                          CndECM  35
                                                                                CndECM  36
c              Look at performance at 5 points in the throttling range          CndECM  37
c              in order to take into account the effect of approach             CndECM  38
      dTbin = (Tcutin-Tcutout) * 0.25                                           CndECM  39
      SCT   = Tcutout - dTbin                                                   CndECM  40
      Qnrml = <cd;NormalCap>                                                    CndECM  41
      DO  I=1,5                                                                 CndECM  42
        SCT     = SCT + dTbin                                                   CndECM  43
        Tbin(I) = SCT                                                           CndECM  44
        IF (SCT .GT. Twb2)  THEN                                                CndECM  45
          Qbin(I) = Qnrml * Curve(Jcd,<cd:CAP-fSCT&WB>,SCT,Twb)                 CndECM  46
        ELSE                                                                    CndECM  47
c              close to wetbulb - interpolate to 0 capacity at wetbulb          CndECM  48
          Qbin(I) = Qnrml * CapfTwb2                                            CndECM  49
          Qbin(I) = Qbin(I) * (SCT-Twb)/2.                                      CndECM  50
        ENDIF                                                                   CndECM  51
        Qbin(I) = Max(0., Qbin(I))                                              CndECM  52
c              adjust for fan modulation                                        CndECM  53
        IF (FanCap .GE. 0.)  THEN                                               CndECM  54
          Qbin(I) = Qbin(I) * FanCap                                            CndECM  55
        ELSE                                                                    CndECM  56
c              variable-speed or damper                                         CndECM  57
          Ratio   = (SCT-Tbot) / (Ttop-Tbot)                                    CndECM  58
          CFMr    = <cd:FAN-MIN-AIR> + (1.-<cd:FAN-MIN-AIR>)*Ratio              CndECM  59
          CapCFM  = Curve(Jcd,<cd:CAP-fAIRFLOW>, CFMr,x)                        CndECM  60
          Qbin(I) = Qbin(I) * CapCFM                                            CndECM  61
          Ebin(I) = Curve(Jcd,<cd:FAN-KW-fAIR>, CFMr,x)                         CndECM  62
        ENDIF                                                                   CndECM  63
      ENDDO                                                                     CndECM  64
c                                                                               CndECM  65
c              Relative time spent in each bin                                  CndECM  66
      SumWeight = 0.                                                            CndECM  67
      DO  I=1,5                                                                 CndECM  68
        Qrej      = Qsct(Tbin(I))                                               CndECM  69
        Weight(I) = BinSize(I) / Max(1.E-20, ABS(Qrej - Qbin(I)))               CndECM  70
        SumWeight = SumWeight + Weight(I)                                       CndECM  71
      ENDDO                                                                     CndECM  72
c                                                                               CndECM  73
c              Weighted capacity, temperature, and fan power                    CndECM  74
      Qweight = 0.                                                              CndECM  75
      Tweight = 0.                                                              CndECM  76
      Eweight = 0.                                                              CndECM  77
      Denom   = 1. / SumWeight                                                  CndECM  78
      DO  I=1,5                                                                 CndECM  79
        WeightBin = Weight(I) * Denom                                           CndECM  80
        Qweight   = Qweight + Qbin(I) * WeightBin                               CndECM  81
        Tweight   = Tweight + Tbin(I) * WeightBin                               CndECM  82
        Eweight   = Eweight + Ebin(I) * WeightBin                               CndECM  83
      ENDDO                                                                     CndECM  84
c                                                                               CndECM  85
      RETURN                                                                    CndECM  86
      END                                                                       CndECM  87
      SUBROUTINE Condenser_Refg(Mode, Jcd)                                      CndRfg   2
c                                                                               CndRfg   3
c              Simulates a single-circuit refrigerant-cooled condenser.         CndRfg   4
c                                                                               CndRfg   5
c              This algorithm simplifies the NTU/effectiveness heat-            CndRfg   6
c              exchanger calculations by lumping the superheat energy           CndRfg   7
c              with the phase-change energy.                                    CndRfg   8
c                                                                               CndRfg   9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /FNSYS/  ISKIPS, MSYSF(120)                                       /FNSYS/  2
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
      COMMON  /CndDat/ Mcycle, Twb, Twb2, CapfTwb2, Ttop, Tbot                  /CndDat/ 2
      Real             Mcycle                                                   /CndDat/ 3
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               CndRfg  22
      COMMON  /TWRKY / Open, OpenHX, FluidCool,                                 /TWRKY/  2
     &                 Bypass, Speed1, Speed2, SpeedV, Damper,                  /TWRKY/  3
     &                 RunMinCells, RunMaxCells,                                /TWRKY/  4
     &                 ElecPanHtr, NoPanHtr, HWPanHtr,                          /TWRKY/  5
     &                 CycleWithFan, StayOn                                     /TWRKY/  6
      INTEGER          Open, OpenHX, FluidCool,                                 /TWRKY/  7
     &                 Bypass, Speed1, Speed2, SpeedV, Damper,                  /TWRKY/  8
     &                 RunMinCells, RunMaxCells,                                /TWRKY/  9
     &                 ElecPanHtr, NoPanHtr, HWPanHtr,                          /TWRKY/ 10
     &                 CycleWithFan, StayOn                                     /TWRKY/ 11
c                                                                               CndRfg  24
      INTEGER  Xri, Xro, rH                                                     CndRfg  25
      REAL     Mmax1, Mmax2                                                     CndRfg  26
      LOGICAL  IterReqdHsty                                                     CndRfg  27
      Save     ErrorMaxT                                                        CndRfg  28
                                                                                CndRfg  29
c              Heat rejection for a given SCT, assuming no subcooling           CndRfg  30
      Qsct(SCTx) = Max(1., Mcycle*(HrefgIn-RefgH_Liquid_fT(JreD, SCTx)))        CndRfg  31
                                                                                CndRfg  32
      Khx  = <cd;HX>                     ! HX subcomponent                      CndRfg  33
      Jrs  = <cd:REFG-SYSTEM>            ! refrigeration system                 CndRfg  34
      JreS = <cd;SucRefg>                ! Supply-side refrigerant              CndRfg  35
      JreD = <cd;Refrigerant>            ! Demand-side refrigerant              CndRfg  36
                                                                                CndRfg  37
c                                                                               CndRfg  38
      SELECT CASE (Mode)                                                        CndRfg  39
c                                                                               CndRfg  40
c                                                                               CndRfg  41
c ============ HOURLY INITIALIZATION ========================================== CndRfg  42
      CASE (10)                                                                 CndRfg  43
c                                                                               CndRfg  44
c                                                                               CndRfg  45
c ============ HOURLY SIMULATION - OPERATING CAPACITY ========================= CndRfg  46
      CASE (25)                                                                 CndRfg  47
c                                                                               CndRfg  48
c              Condenser side of HX                                             CndRfg  49
      Kri           = <cd;InletNode>                                            CndRfg  50
      Xri           = <ri;Xnode>                                                CndRfg  51
      HrefgIn       = <Xri.Hinlet>                                              CndRfg  52
      Kro           = <cd;OutletNode>                                           CndRfg  53
      Xro           = <ro;Xnode>                                                CndRfg  54
      roHout        = <ro.Houtlet>                                              CndRfg  55
      <cd.Tsetpt>   = <Xro.Tsetpt>                                              CndRfg  56
      <ro.MaxMrefg> = 0.                                                        CndRfg  57
c              initialize condensed flow                                        CndRfg  58
      <ro.Moutlet>  = Max(<cd.MrefgOpCap>, 0.01)                                CndRfg  59
c                                                                               CndRfg  60
c              Suction side of HX                                               CndRfg  61
      Kri     = <cd;SupInNode>                                                  CndRfg  62
      Xri     = <ri;Xnode>                                                      CndRfg  63
      Krx     = <cd;SupOutNode>                                                 CndRfg  64
      Xro     = <rx;Xnode>                                                      CndRfg  65
      rxMrefg = <rx.Mrefg>                                                      CndRfg  66
c              minimum possible suction temperature                             CndRfg  67
      SSTmin = RefgT_fP(JreS, <Xro.Poutlet>)                                    CndRfg  68
c              Check if condenser can meet setpoint                             CndRfg  69
      IF (SSTmin .GE. <cd.Tsetpt>)  RETURN                                      CndRfg  70
c                                                                               CndRfg  71
c              Initialize suction conditions                                    CndRfg  72
      <rx.Mrefg> = Max(<cd.MsucOpCap>, 0.01)                                    CndRfg  73
c              EPR setpoint                                                     CndRfg  74
      IF (<cd:TEMP-CTRL> .NE. 2)  THEN                                          CndRfg  75
        SSTepr = -88888.                                                        CndRfg  76
      ELSE  ! EPR                                                               CndRfg  77
        SSTepr = <cd.Tsetpt>-<cd;EPRoffset>                                     CndRfg  78
      ENDIF                                                                     CndRfg  79
c                                                                               CndRfg  80
c              Iterate to solve for suction and refg flows; note that           CndRfg  81
c              Krx refers to the suction flow, and Kro to the condenser         CndRfg  82
      CALL HistoryInit(<cd;FlowsHsty>)                                          CndRfg  83
      DO  iCount=1,100                                                          CndRfg  84
c              Available suction pressure, adjusted for control valve           CndRfg  85
        Voutlet = RefgV_fPH(JreS, <Xro.Poutlet>, <rx.Hrefg>)                    CndRfg  86
        dPctrl  = (<rx.Mrefg> * <cd;1/Msupply>)**1.87                           CndRfg  87
     &          * (   Voutlet * <cd;SuctionD> )**1.6                            CndRfg  88
        dPctrl  = dPctrl * <cd;CtrlValveDP>                                     CndRfg  89
        Pctrl   = <Xro.Poutlet> + dPctrl                                        CndRfg  90
c              suction temperature, adjusted for control valve                  CndRfg  91
        SST     = MAX(RefgT_fP(JreS, Pctrl), SSTepr)                            CndRfg  92
        SST     = MIN(<cd.Tsetpt>, SST)                                         CndRfg  93
c              get heat transfer; UA & Q are based on no subcooling             CndRfg  94
        CALL HX(1, Khx, <cd.OpCap>,                                             CndRfg  95
     &                  <rx.Mrefg>,         SST, xSupTo,   ! suction            CndRfg  96
     &                <ro.Moutlet>, <cd.Tsetpt>, xDemTo)   ! condenser          CndRfg  97
c              condenser enthalpy at setpoint and flow                          CndRfg  98
        <ro.Houtlet> = RefgH_Liquid_fT(JreD, <cd.Tsetpt>)                       CndRfg  99
        <ro.Moutlet> = <cd.OpCap> / (HrefgIn-<ro.Houtlet>)                      CndRfg 100
        <ro.Moutlet> = Max(<ro.Moutlet>, 0.01)                                  CndRfg 101
c              include subcooling in suction load                               CndRfg 102
        dTinlets     = <cd.Tsetpt> - SST                                        CndRfg 103
        dTsubcool    = <cd:SUBCOOL-EFF> * dTinlets                              CndRfg 104
        <ro.Houtlet> = RefgH_Liquid_fTS(JreD, <cd.Tsetpt>, dTsubcool)           CndRfg 105
        Qtot         = <ro.Moutlet> * (HrefgIn-<ro.Houtlet>)                    CndRfg 106
c              suction flow at these conditions                                 CndRfg 107
        dTsuper      = MAX(0., MIN(<cd:SUPERHEAT-DT>, dTinlets))                CndRfg 108
        <rx.Hrefg>   = RefgH_Vapor_fTS(JreS, SST, dTsuper)                      CndRfg 109
        dHsuction    = <rx.Hrefg> - <Xri.Hinlet>                                CndRfg 110
        <rx.Mrefg>   = Qtot / dHsuction                                         CndRfg 111
c              check for convergence                                            CndRfg 112
        CALL CnvgCheck(2, <cd;FlowsHsty>)                                       CndRfg 113
        IF (.NOT. IterReqdHsty(<cd;FlowsHsty>))  EXIT                           CndRfg 114
        IF (iCount .EQ. 100)  CALL CnvgMsg2(1, Routine, Jcd)                    CndRfg 115
      ENDDO                                                                     CndRfg 116
c              Save flows for next call                                         CndRfg 117
      <cd.MrefgOpCap> = <ro.Moutlet>    ! condenser flow                        CndRfg 118
      <cd.MsucOpCap>  = <rx.Mrefg>      ! suction flow                          CndRfg 119
      <rx.Mrefg>      = rxMrefg                                                 CndRfg 120
c                                                                               CndRfg 121
c              Limit by available suction capacity                              CndRfg 122
c              Maximum suction flow across condenser                            CndRfg 123
      dP     = MAX(0., <Xri.Pinlet> - <Xro.Poutlet>)                            CndRfg 124
      Mmax1  = <cd;Msupply> * (dP*<cd;1/dPsupply>)**(1./1.87)                   CndRfg 125
c              Maximum suction flow, inlet to control valve                     CndRfg 126
      dP     = MAX(0., <Xri.Pinlet> - Pctrl)                                    CndRfg 127
      Mmax2  = <cd;Msupply> * (dP*<cd;1/dPsupplyHX>)**(1./1.87)                 CndRfg 128
c              Maximum possible refrigerant flow and heat removal               CndRfg 129
      QhxMax = MIN(Mmax1, Mmax2) * dHsuction                                    CndRfg 130
      IF (<cd.OpCap> .GT. QhxMax)  THEN                                         CndRfg 131
        <ro.Moutlet> = <ro.Moutlet> * QhxMax/<cd.OpCap>                         CndRfg 132
        <cd.OpCap>   = QhxMax                                                   CndRfg 133
      ENDIF                                                                     CndRfg 134
c                                                                               CndRfg 135
c              refrigerant capacity                                             CndRfg 136
      <ro.MaxMrefg> = <ro.Moutlet>                                              CndRfg 137
      <ro.Houtlet>  = roHout                                                    CndRfg 138
c                                                                               CndRfg 139
c                                                                               CndRfg 140
c ============ HOURLY SIMULATION - PERFORMANCE ================================ CndRfg 141
      CASE (31,32)                                                              CndRfg 142
                                                                                CndRfg 143
c******** Note: RunFrac and Mcycle not debugged ?? ***************              CndRfg 144
                                                                                CndRfg 145
c              Condenser side                                                   CndRfg 146
      Kro         = <cd;OutletNode>   ! condenser outlet                        CndRfg 147
      Kri         = <cd;InletNode>                                              CndRfg 148
      <ri.Minlet> = <ro.Moutlet>                                                CndRfg 149
                                                                                CndRfg 150
c              Auxiliary power                                                  CndRfg 151
      IF (<cd:AUX-KW> .GT. 0.)  THEN                                            CndRfg 152
        Kmd = <cd:AUX-METER>                                                    CndRfg 153
        SELECT CASE (<cd:AUX-MODE>)                                             CndRfg 154
          CASE (1)  ! Always                                                    CndRfg 155
            <md.Elec> = <cd:AUX-KW>                                             CndRfg 156
          CASE (2)  ! When on                                                   CndRfg 157
            IF (<ro.Moutlet> .GT. 0.)                                           CndRfg 158
     &        AuxKWh = <cd:AUX-KW> * <ro.RunFrac>                               CndRfg 159
          CASE (3)  ! When off                                                  CndRfg 160
            IF (<ro.Moutlet> .EQ. 0.)                                           CndRfg 161
     &        AuxKWh = <cd:AUX-KW> * (1.-<ro.RunFrac>)                          CndRfg 162
          CASE (4)  ! Scheduled                                                 CndRfg 163
            <md.Elec> = <cd:AUX-KW> * SchVal(<cd:AUX-SCH>)                      CndRfg 164
        END SELECT                                                              CndRfg 165
      ENDIF                                                                     CndRfg 166
                                                                                CndRfg 167
c              Check if off                                                     CndRfg 168
      IF (<ro.Moutlet> .eq. 0.)  THEN                                           CndRfg 169
        CALL ZeroAA(<#cd~HrZeroStart..>, <#cd~HrZeroEnd....>)                   CndRfg 170
        <rx.Mrefg> = 0.  ! suction outlet                                       CndRfg 171
        <rx.Mreqd> = 0.                                                         CndRfg 172
        <cd.Qrej>  = 0.                                                         CndRfg 173
        GOTO 3190                                                               CndRfg 174
      ENDIF                                                                     CndRfg 175
                                                                                CndRfg 176
c              Condenser is operating. If cycling, convert hourly               CndRfg 177
c              average refrigerant flow to flow when cycled on                  CndRfg 178
      Mcycle  = <ro.Moutlet> / <ro.RunFrac>                                     CndRfg 179
                                                                                CndRfg 180
      Xri     = <ri;Xnode>                                                      CndRfg 181
      Xro     = <ro;Xnode>                                                      CndRfg 182
c              Condenser inlet H and T                                          CndRfg 183
      HrefgIn = <Xri.Hinlet>                                                    CndRfg 184
      TrefgIn = RefgT_fPH(JreD, <Xri.Pinlet>, HrefgIn)                          CndRfg 185
c                                                                               CndRfg 186
c              Condenser setpoint                                               CndRfg 187
      Throttle    = 0.5 - Mcycle*<cd;1/Mtotal>                                  CndRfg 188
      Throttle    = Max(-0.5, Min(0.5, Throttle)) * <rs:SCT-THROTTLE>           CndRfg 189
      <cd.Tsetpt> = <Xro.Tsetpt> - Throttle                                     CndRfg 190
                                                                                CndRfg 191
c              Minimum possible suction conditions; these pointers              CndRfg 192
c              are held fixed until after 3190                                  CndRfg 193
      Kri        = <cd;SupInNode>                                               CndRfg 194
      Xri        = <ri;Xnode>                                                   CndRfg 195
      Krx        = <cd;SupOutNode>   ! suction outlet                           CndRfg 196
      Xro        = <rx;Xnode>                                                   CndRfg 197
      SSTmin     = RefgT_fP(JreS, <Xro.Poutlet>)                                CndRfg 198
c                                                                               CndRfg 199
c              Condenser performance                                            CndRfg 200
      SELECT CASE (<cd:TEMP-CTRL>)                                              CndRfg 201
                                                                                CndRfg 202
      CASE (1)  ! Floating                                                      CndRfg 203
        SSTset = SSTmin                                                         CndRfg 204
        Call RefgFloatingSCT                                                    CndRfg 205
c              required suction pressure                                        CndRfg 206
        <rx.Preqd> = RefgP_fT(JreS, <cd.Tsetpt>-dTinlets)                       CndRfg 207
                                                                                CndRfg 208
      CASE (2)  ! Local EPR                                                     CndRfg 209
c              Suction setpoint is condenser setpoint, minus the design         CndRfg 210
c              EPR differential                                                 CndRfg 211
        SSTset = <cd.Tsetpt> - <cd;EPRoffset>                                   CndRfg 212
        Call RefgFloatingSCT                                                    CndRfg 213
c              required suction pressure                                        CndRfg 214
        <rx.Preqd> = RefgP_fT(JreS, SSTset) - dPctrl                            CndRfg 215
                                                                                CndRfg 216
      CASE (3)  ! Thermostat                                                    CndRfg 217
c              required suction conditions                                      CndRfg 218
        Call ReqdSST                                                            CndRfg 219
        IF (<rx.Preqd> .LT. <Xro.Poutlet>)  THEN                                CndRfg 220
c               setpoint can't be met; take what we can                         CndRfg 221
          SSTset = SSTmin                                                       CndRfg 222
          Call RefgFloatingSCT                                                  CndRfg 223
        ENDIF                                                                   CndRfg 224
      END SELECT  ! cd:TEMP-CTRL                                                CndRfg 225
c              Pressure as regulated by temperature control valve               CndRfg 226
      <cd.Pctrl> = RefgP_fT(JreS, MAX(SST, SSTmin))                             CndRfg 227
c                                                                               CndRfg 228
c              Check load-based flow against pressure-based flow                CndRfg 229
      dP     = MAX(0., <Xri.Pinlet> - <Xro.Poutlet>)                            CndRfg 230
      Mmax1  = <cd;Msupply> * (dP*<cd;1/dPsupply>)**(1./1.87)                   CndRfg 231
c              Maximum suction flow, inlet to control valve                     CndRfg 232
      dP     = MAX(0., <Xri.Pinlet> - <cd.Pctrl>)                               CndRfg 233
      Mmax2  = <cd;Msupply> * (dP*<cd;1/dPsupplyHX>)**(1./1.87)                 CndRfg 234
      <cd.MsupMax> = MIN(Mmax1, Mmax2)                                          CndRfg 235
c              Maximum possible refrigerant flow and heat removal               CndRfg 236
      IF (<rx.Mrefg> .gt. <cd.MsupMax>)  THEN                                   CndRfg 237
c              Load-based suction flow is greater than what the                 CndRfg 238
c              liquid/suction pressure differential permits                     CndRfg 239
        <rx.Mrefg> = <cd.MsupMax>                                               CndRfg 240
c              Suction pressure, adjusted for control valve                     CndRfg 241
        dPctrl     = (<rx.Mrefg> * <cd;1/Msupply>)**1.87                        CndRfg 242
     &             * (   Voutlet * <cd;SuctionD> )**1.6                         CndRfg 243
        dPctrl     = dPctrl * <cd;CtrlValveDP>                                  CndRfg 244
        <cd.Pctrl> = <Xro.Poutlet> + dPctrl                                     CndRfg 245
        SSTmin     = RefgT_fP(JreS, <cd.Pctrl>)                                 CndRfg 246
        SELECT CASE (<cd:TEMP-CTRL>)                                            CndRfg 247
        CASE (2)  ! Local EPR                                                   CndRfg 248
          SST = MAX(SSTmin, SSTset)                                             CndRfg 249
        CASE DEFAULT                                                            CndRfg 250
          SST = SSTmin                                                          CndRfg 251
        END SELECT                                                              CndRfg 252
c              Maximum possible heat transfer, assuming the supply              CndRfg 253
c              temperature approaches the condensing inlet temperature          CndRfg 254
        dTsuper    = TrefgIn - SST                                              CndRfg 255
        <rx.Hrefg> = RefgH_Vapor_fTS(JreS, SST, dTsuper)                        CndRfg 256
        QhxMax     = <rx.Mrefg> * (<rx.Hrefg>-<Xri.Hinlet>)                     CndRfg 257
        IF (QhxMax .GE. <cd.Qrej>)  THEN                                        CndRfg 258
c              extra superheat can handle load; suction enthalpy                CndRfg 259
          <rx.Hrefg>   = <Xri.Hinlet> + <cd.Qrej>/<rx.Mrefg>                    CndRfg 260
        ELSEIF (<rx.Mrefg> .GT. 0.)  THEN                                       CndRfg 261
c              condensing temperature rises                                     CndRfg 262
          <cd.Qrej>    = QhxMax                                                 CndRfg 263
          <rx.Hrefg>   = <Xri.Hinlet> + Qhxmax/<rx.Mrefg>                       CndRfg 264
c              condensed liquid                                                 CndRfg 265
          Cp           = RefgCp_Liquid_fT(JreD, <cd.SCT>)                       CndRfg 266
          <ro.Houtlet> = HrefgIn - QhxMax/Mcycle                                CndRfg 267
          Hsat         = <ro.Houtlet> - Cp*<cd.dTsubcool>                       CndRfg 268
          <cd.SCT>     = RefgT_Liquid_fH(JreD, Hsat)                            CndRfg 269
        ELSE                                                                    CndRfg 270
          <cd.Qrej>    = 0.                                                     CndRfg 271
          <ro.Houtlet> = HrefgIn                                                CndRfg 272
          <cd.SCT>     = TrefgIn                                                CndRfg 273
        ENDIF                                                                   CndRfg 274
      ENDIF  ! rx.Mrefg .gt. cd.MsupMax                                         CndRfg 275
c                                                                               CndRfg 276
c              Re-entry point when condenser is off                             CndRfg 277
 3190 CONTINUE                                                                  CndRfg 278
c                                                                               CndRfg 279
c              Suction conditions at inlet; pointers set to suction             CndRfg 280
      <rx.RunFrac> = <ro.RunFrac>                                               CndRfg 281
      <rx.Mrefg>   = <rx.Mrefg> * <ro.RunFrac>                                  CndRfg 282
      <ri.Minlet>  = <rx.Mrefg>                                                 CndRfg 283
      <ri.Qinlet> = <rx.Mrefg>  * (<Xri.Hinlet>-AA(<cd;SucHrefPtr>))            CndRfg 284
      <cd.Qrej>   = <cd.Qrej>   * <ro.RunFrac>                                  CndRfg 285
      <rx.Qrefg>  = <ri.Qinlet> + <cd.Qrej>                                     CndRfg 286
c              required conditions at inlet                                     CndRfg 287
      dPhx         = <cd:SUCTION-DP> * (<rx.Mreqd>*<cd;1/Msupply>)**1.87        CndRfg 288
      <ri.Preqd>   = <cd.Pctrl> + dPhx                                          CndRfg 289
      <rx.Mreqd>   = <rx.Mreqd> * <ro.RunFrac>                                  CndRfg 290
      <ri.Mreqd>   = <rx.Mreqd>                                                 CndRfg 291
c              Liquid should be delivered no warmer than saturation             CndRfg 292
      <ri.Treqd>   = RefgT_fP(JreS, <Xri.Pinlet>)                               CndRfg 293
c              Check for convergence (suction side)                             CndRfg 294
      IF (Mode .EQ. 31)  THEN                                                   CndRfg 295
        CALL CnvgCheck(1, <cd;EnergyHsty>)  ! Loads to plant                    CndRfg 296
      ELSE                                                                      CndRfg 297
        CALL CnvgCheck(0, <cd;EnergyHsty>)                                      CndRfg 298
      ENDIF                                                                     CndRfg 299
c                                                                               CndRfg 300
c              Outlet pressure, load                                            CndRfg 301
      <ro.Poutlet> = RefgP_fT(JreD, <cd.SCT>)                                   CndRfg 302
      <ro.Qoutlet> = <cd.Qrej>                                                  CndRfg 303
c              inlet pressure, adjusted for condenser pressure drop             CndRfg 304
      Kri = <cd;InletNode>                                                      CndRfg 305
      dP  = <cd:CONDENSER-DP> * (Mcycle*<cd;1/Mtotal>)**1.87                    CndRfg 306
      <ri.Pinlet> = <ro.Poutlet> + dP                                           CndRfg 307
c                                                                               CndRfg 308
c                                                                               CndRfg 309
c ============ REPORT CREATION ================================================ CndRfg 310
      CASE (50)                                                                 CndRfg 311
c                                                                               CndRfg 312
c              statistics blocks                                                CndRfg 313
      Ks2Load    = NewStat2(Jcd,    <+cd.Qrej>, 0, 1.)                          CndRfg 314
      Kro        = <cd;OutletNode>                                              CndRfg 315
      Ks2Flow    = NewStat2(Kro, <+ro.Moutlet>, 0, 1.)                          CndRfg 316
      Ks5FlowBin = NewStat5(Kro, <+ro.Moutlet>, 0, 1.)                          CndRfg 317
      Kro        = <cd;SupOutNode>                                              CndRfg 318
      Ks2Suct    = NewStat2(Kro, <+ro.Moutlet>, 0, 1.)                          CndRfg 319
      Ks5SuctBin = NewStat5(Kro, <+ro.Moutlet>, 0, 1.)                          CndRfg 320
      Kmd        = <cd:AUX-METER>                                               CndRfg 321
      Ks2Elec    = NewStat2(Kmd,    <+md.Elec>, 0, 1.)                          CndRfg 322
c                                                                               CndRfg 323
c              Create the type "H" report                                       CndRfg 324
      IF (<cd:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      CndRfg 325
     &  <cd;PS-H> = NewReport_H(Jcd, 144,                                       CndRfg 326
     &                          4, 5, 6,                                        CndRfg 327
     &                          Ks2Load, Ks2Flow, Ks2Suct, Ks2Elec,             CndRfg 328
     &                          Ks5FlowBin, Ks5SuctBin, 0,                      CndRfg 329
     &                          0, 0, 0)                                        CndRfg 330
c                                                                               CndRfg 331
c              Setpoint overload                                                CndRfg 332
      <cd;s10> = NewStat10(Jcd, <#cd.Tsetpt>, <#cd.SCT>,                        CndRfg 333
     &                          <rs:SCT-THROTTLE>*0.5, 1, <#cd.Qrej>)           CndRfg 334
c                                                                               CndRfg 335
c                                                                               CndRfg 336
c ============ REPORT ORDER =================================================== CndRfg 337
      CASE (52)                                                                 CndRfg 338
c                                                                               CndRfg 339
      Call Report_H(Mode, <cd;PS-H>)                                            CndRfg 340
c                                                                               CndRfg 341
c                                                                               CndRfg 342
c ============ REPORTS - VERIFICATION DATA ==================================== CndRfg 343
      CASE (54)                                                                 CndRfg 344
c                                                                               CndRfg 345
c              Output design information                                        CndRfg 346
      Kro = <cd;OutletNode>                                                     CndRfg 347
      Krx = <cd;SupOutNode>                                                     CndRfg 348
      IF (<cd;PS-H> .ne. 0)  THEN                                               CndRfg 349
        rH = <cd;PS-H>                                                          CndRfg 350
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       CndRfg 351
        CALL GetAttachments(Jcd, 2)                                             CndRfg 352
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   CndRfg 353
     &    (NameAttachments(II,1,1),II=1,8),                                     CndRfg 354
     &    (NameAttachments(II,1,2),II=1,8),                                     CndRfg 355
     &    <cd;Capacity>,<ro.Moutlet>,<rx.Mrefg>,<cd;DesignKW>,                  CndRfg 356
     &    <cd.Tsetpt>                                                           CndRfg 357
        DO  Irow=2,NumRowsOfAttachments                                         CndRfg 358
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 CndRfg 359
     &      (NameAttachments(II,Irow,1),II=1,8),                                CndRfg 360
     &      (NameAttachments(II,Irow,2),II=1,8)                                 CndRfg 361
        ENDDO                                                                   CndRfg 362
      ENDIF                                                                     CndRfg 363
c                                                                               CndRfg 364
c                                                                               CndRfg 365
c ============ REPORTS - YEARLY SUMMARY (SPECIAL) ============================= CndRfg 366
      CASE (58)                                                                 CndRfg 367
c                                                                               CndRfg 368
c              Setpoint overload                                                CndRfg 369
      IF (<cd;PS-H> .ne. 0)  THEN                                               CndRfg 370
        rH = <cd;PS-H>                                                          CndRfg 371
        CALL Report_s10(<rH;Iuniq>, 7, <cd;s10>)                                CndRfg 372
      ENDIF                                                                     CndRfg 373
c                                                                               CndRfg 374
c                                                                               CndRfg 375
c ============ HOURLY REPORTS - HOURLY DATA =================================== CndRfg 376
      CASE (62)                                                                 CndRfg 377
c                                                                               CndRfg 378
      IF (<cd;HourRepBuf> .EQ. 0)  RETURN                                       CndRfg 379
      TDinlets = MAX(0., <cd.SCT>-DBT)                                          CndRfg 380
c                                                                               CndRfg 381
      IAptr = <cd;HourRepBuf> - 1                                               CndRfg 382
      AA(IAptr+1)  = <cd.Qrej>                                                  CndRfg 383
      AA(IAptr+2)  = <cd.OpCap>                                                 CndRfg 384
      AA(IAptr+3)  = <ro.Moutlet>                                               CndRfg 385
      AA(IAptr+4)  = <cd.Tsetpt>                                                CndRfg 386
      AA(IAptr+5)  = <cd.SCT>                                                   CndRfg 387
      AA(IAptr+6)  = <cd.dTsubcool>                                             CndRfg 388
      AA(IAptr+7)  = -888.                                                      CndRfg 389
      AA(IAptr+8)  = -888.                                                      CndRfg 390
      AA(IAptr+9)  = -888.                                                      CndRfg 391
      AA(IAptr+10) = -888.                                                      CndRfg 392
      AA(IAptr+11) = -888.                                                      CndRfg 393
      Kri          = <cd;InletNode>                                             CndRfg 394
      Xri          = <ri;Xnode>                                                 CndRfg 395
      Kro          = <cd;OutletNode>                                            CndRfg 396
      AA(IAptr+12) = <Xri.Hinlet>                                               CndRfg 397
      AA(IAptr+13) = <ro.Houtlet>                                               CndRfg 398
      Kri          = <cd;SupInNode>                                             CndRfg 399
      Xri          = <ri;Xnode>                                                 CndRfg 400
      Kro          = <cd;SupOutNode>                                            CndRfg 401
      AA(IAptr+14) = <ro.Moutlet>                                               CndRfg 402
      AA(IAptr+15) = <Xri.Hinlet>                                               CndRfg 403
      AA(IAptr+16) = <ro.Houtlet>                                               CndRfg 404
      AA(IAptr+17) = <ro.RunFrac>                                               CndRfg 405
c                                                                               CndRfg 406
c                                                                               CndRfg 407
c ============ DESIGN CALCULATIONS ============================================ CndRfg 408
      CASE (111)                                                                CndRfg 409
c                                                                               CndRfg 410
c              This call calculates the design capacity and flow                CndRfg 411
c                                                                               CndRfg 412
c              Design setpoint and inlets TD                                    CndRfg 413
      <cd.Tsetpt>   = <rs:DESIGN-SCT>                                           CndRfg 414
      <cd;InletsTD> = <cd:RATED-TD>                                             CndRfg 415
      <cd.SSTreqd>  = <cd.Tsetpt> - <cd:RATED-TD>                               CndRfg 416
c                                                                               CndRfg 417
c              Condensed side of HX                                             CndRfg 418
      Kri = <cd;InletNode>                                                      CndRfg 419
      Xri = <ri;Xnode>                                                          CndRfg 420
      Kro = <cd;OutletNode>                                                     CndRfg 421
      Xro = <ro;Xnode>                                                          CndRfg 422
c              Outlet pressure, enthalpy, enthalpy differential                 CndRfg 423
      <ro.Poutlet> = RefgP_fT(JreD, <cd.Tsetpt>)                                CndRfg 424
      dTsubcool    = MAX(0.,<cd:SUBCOOL-EFF>*(<cd.Tsetpt>-<cd.SSTreqd>))        CndRfg 425
      <ro.Houtlet> = RefgH_Liquid_fTS(JreD, <cd.Tsetpt>, dTsubcool)             CndRfg 426
      dHrefg       = <Xri.Hinlet> - <ro.Houtlet>                                CndRfg 427
c                                                                               CndRfg 428
c              Design capacity and flow                                         CndRfg 429
      IF (<cd:RATED-CAPACIT> .GT. 0.)  THEN                                     CndRfg 430
        <cd;Capacity> = <cd:RATED-CAPACIT> * <cd:CLASS-FACTOR>                  CndRfg 431
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndRfg 432
     &    <cd;Capacity> = <cd;Capacity> * <cd:CAP-RATIO>                        CndRfg 433
      ELSE                                                                      CndRfg 434
        IF (<cd:CAP-RATIO> .GT. 0.)  THEN                                       CndRfg 435
          <cd;Capacity> = <Xri.Minlet> * dHrefg * <cd:CAP-RATIO>                CndRfg 436
        ELSE                                                                    CndRfg 437
c              no capacity ratio specified - size equipment equally             CndRfg 438
          Kli = <Xro;Xnode>                                                     CndRfg 439
          IF (Kli .EQ. Kro)  THEN                                               CndRfg 440
c              this condenser is the only attachment                            CndRfg 441
            <cd;Capacity> = <Xri.Minlet> * dHrefg                               CndRfg 442
          ELSE  ! this condenser is one in a list                               CndRfg 443
            <cd;Capacity> = <Xri.Minlet> * dHrefg / FLOAT(<li;NumItems>)        CndRfg 444
          ENDIF                                                                 CndRfg 445
        ENDIF                                                                   CndRfg 446
      ENDIF  ! cd:RATED-CAPACIT                                                 CndRfg 447
c                                                                               CndRfg 448
c              Design refrigerant flow                                          CndRfg 449
      IF (<cd:RATED-FLOW> .GT. 0.)  THEN                                        CndRfg 450
        <ro.Moutlet> = <cd:RATED-FLOW>                                          CndRfg 451
        IF (<cd:CAP-RATIO> .GT. 0.)                                             CndRfg 452
     &    <ro.Moutlet> = <ro.Moutlet> * <cd:CAP-RATIO>                          CndRfg 453
      ELSE                                                                      CndRfg 454
        <ro.Moutlet> = <cd;Capacity> / dHrefg                                   CndRfg 455
      ENDIF                                                                     CndRfg 456
c              inlet pressure and flow                                          CndRfg 457
      <ri.Minlet> = <ro.Moutlet>                                                CndRfg 458
      <ri.Pinlet> = <ro.Poutlet> + <cd:CONDENSER-DP>                            CndRfg 459
c                                                                               CndRfg 460
c              Suction side of HX                                               CndRfg 461
      Kri = <cd;SupInNode>                                                      CndRfg 462
      Xri = <ri;Xnode>                                                          CndRfg 463
      Kro = <cd;SupOutNode>                                                     CndRfg 464
      Xro = <ro;Xnode>                                                          CndRfg 465
c                                                                               CndRfg 466
c              Refrigerant conditions at outlet to suction                      CndRfg 467
      Pctrl        = RefgP_fT(JreS, <cd.SSTreqd>)                               CndRfg 468
      <ro.Houtlet> = RefgH_Vapor_fSP(JreS, <cd:SUPERHEAT-DT>, Pctrl)            CndRfg 469
      dHsuction    = MAX(20., <ro.Houtlet> - <Xri.Hinlet>)                      CndRfg 470
      <ro.Moutlet> = MAX(1., <cd;Capacity>/dHsuction)                           CndRfg 471
      <ro.Mreqd>   = <ro.Moutlet>                                               CndRfg 472
c              effect of control valve                                          CndRfg 473
      dPctrl = Pctrl - RefgP_fT(JreS, <cd.SSTreqd>-<cd:CTRL-VALVE-DT>)          CndRfg 474
      IF (<cd:SUCTION-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)               CndRfg 475
     &  dPctrl = dPctrl * (<ro.Mreqd>/<cd:SUCTION-FLOW>)**1.87                  CndRfg 476
      <cd;CtrlValveDP> = dPctrl                                                 CndRfg 477
      <ro.Preqd>       = Pctrl - dPctrl                                         CndRfg 478
c                                                                               CndRfg 479
c              Check for convergence on outlet conditions                       CndRfg 480
      CALL CnvgCheck(1, <cd;EnergyHsty>)                                        CndRfg 481
c                                                                               CndRfg 482
      <ri.Qinlet>  = <ro.Moutlet> * (<Xri.Hinlet>-AA(<cd;SucHrefPtr>))          CndRfg 483
      <ro.Qoutlet> = <ri.Qinlet> + <cd;Capacity>                                CndRfg 484
                                                                                CndRfg 485
c              Refrigerant conditions at inlet from liquid                      CndRfg 486
      <ri.Minlet> = <ro.Moutlet>                                                CndRfg 487
      <ri.Mreqd>  = <ro.Moutlet>                                                CndRfg 488
      IF (<cd:SUCTION-FLOW> .GT. 0.  .AND.  <ri.Mreqd> .GT. 0.)  THEN           CndRfg 489
        dP = <cd:SUCTION-DP> * (<ri.Mreqd>/<cd:SUCTION-FLOW>)**1.87             CndRfg 490
      ELSE                                                                      CndRfg 491
        dP = <cd:SUCTION-DP>                                                    CndRfg 492
      ENDIF                                                                     CndRfg 493
      <ri.Preqd> = Pctrl + dP                                                   CndRfg 494
c              Liquid should be delivered no warmer than saturation             CndRfg 495
      IF (<Xri.Pinlet> .GT. 0.)  THEN                                           CndRfg 496
        <ri.Treqd> = RefgT_fP(JreS, <Xri.Pinlet>)                               CndRfg 497
      ELSE                                                                      CndRfg 498
        <ri.Treqd> = 105.                                                       CndRfg 499
      ENDIF                                                                     CndRfg 500
c                                                                               CndRfg 501
c              Store electrical consumption                                     CndRfg 502
      IF (<cd:AUX-METER> .GT. 0)  THEN                                          CndRfg 503
        Kmd       = <cd:AUX-METER>                                              CndRfg 504
        <md.Elec> = <cd:AUX-KW>                                                 CndRfg 505
      ENDIF                                                                     CndRfg 506
c                                                                               CndRfg 507
c                                                                               CndRfg 508
c ============ DESIGN RECONCILIATION ========================================== CndRfg 509
      CASE (119)                                                                CndRfg 510
                                                                                CndRfg 511
      ErrorMaxT = <sp:ERROR-T> * 0.2                                            CndRfg 512
c                                                                               CndRfg 513
      IF (<cd;Capacity> .EQ. 0.)  THEN                                          CndRfg 514
        CALL MSGSIM(-2,II,II,II,II)                                             CndRfg 515
        WRITE (IOUTPT,9002)  (<cd:NAME>,II=1,8)                                 CndRfg 516
        RETURN                                                                  CndRfg 517
      ENDIF                                                                     CndRfg 518
c                                                                               CndRfg 519
c              Suction side of HX                                               CndRfg 520
      Kro          = <cd;SupOutNode>                                            CndRfg 521
      Xro          = <ro;Xnode>                                                 CndRfg 522
      <cd;Msupply> = <ro.Moutlet>                                               CndRfg 523
c              Design suction volume and density at outlet                      CndRfg 524
      <cd;SuctionV> = RefgV_fPH(JreS, <Xro.Poutlet>, <ro.Houtlet>)              CndRfg 525
      <cd;SuctionD> = 1.0 / <cd;SuctionV>                                       CndRfg 526
                                                                                CndRfg 527
c              Capacity w/o subcooling                                          CndRfg 528
      Kro       = <cd;OutletNode>                                               CndRfg 529
      dTsubcool = Max(0.,<cd:SUBCOOL-EFF>*(<cd.Tsetpt>-<cd.SSTreqd>))           CndRfg 530
      dHsubcool = dTsubcool * RefgCp_Liquid_fT(JreD, <cd.Tsetpt>)               CndRfg 531
      Qsubcool  = <ro.Moutlet> * dHsubcool                                      CndRfg 532
      Qsat      = <cd;Capacity> - Qsubcool                                      CndRfg 533
                                                                                CndRfg 534
c              Design the heat exchanger - assumes that all heat                CndRfg 535
c              rejection can be treated as latent (ignores effect               CndRfg 536
c              of superheat).  HX UA is based on saturated heat;                CndRfg 537
c              subcooling will be added separately                              CndRfg 538
      CALL HX_Design(Khx,          Qsat,                                        CndRfg 539
     &                     <cd;Msupply>,  1.E20, <cd.SSTreqd>,                  CndRfg 540
     &                     <ro.Moutlet>,     1.,  <cd.Tsetpt>)                  CndRfg 541
      <hx;CpDemand>   = 1.E20                                                   CndRfg 542
      <ro;DesMoutlet> = <ro.Moutlet>                                            CndRfg 543
c                                                                               CndRfg 544
      <cd;1/Mtotal>     = 1. / <ro.Moutlet>                                     CndRfg 545
      <cd;1/Msupply>    = 1. / <cd;Msupply>                                     CndRfg 546
      <cd;1/dPsupply>   = 1. / (<cd:SUCTION-DP>+<cd:CTRL-VALVE-DT>)             CndRfg 547
      <cd;1/dPsupplyHX> = 1. / <cd:SUCTION-DP>                                  CndRfg 548
c                                                                               CndRfg 549
c              Total electrical consumption                                     CndRfg 550
      <cd;DesignKW> = <cd;FanKWdes> + <cd:AUX-KW>                               CndRfg 551
c                                                                               CndRfg 552
c              For EPR, offset between chw setpoint and SST                     CndRfg 553
      SELECT CASE (<cd:TEMP-CTRL>)                                              CndRfg 554
        CASE (2)  ! Local EPR                                                   CndRfg 555
          <cd;EPRoffset> = <cd:RATED-TD>                                        CndRfg 556
      END SELECT  ! sc:TEMP-CTRL                                                CndRfg 557
c                                                                               CndRfg 558
c                                                                               CndRfg 559
c ============ ATTACHMENTS ==================================================== CndRfg 560
c                                                                               CndRfg 561
c              Initial attachments                                              CndRfg 562
      CASE (201)                                                                CndRfg 563
c              Component pointers, schedules, and curves                        CndRfg 564
        <cd:REFG-SYSTEM>   = Jcomponent(29, <cd:REFG-SYSTEM>)                   CndRfg 565
        <cd:LIQUID-CKT>    = Jcomponent(22, <cd:LIQUID-CKT>)                    CndRfg 566
        <cd:SUCTION-CKT>   = Jcomponent(22, <cd:SUCTION-CKT>)                   CndRfg 567
        <cd:ELEC-METER>    = Jcomponent(13, <cd:ELEC-METER>)                    CndRfg 568
        <cd:AUX-METER>     = Jcomponent(13, <cd:AUX-METER>)                     CndRfg 569
        <cd:COST-DATA>     = Jcomponent(18, <cd:COST-DATA>)                     CndRfg 570
        <cd:AUX-SCH>       = Jsched(<cd:AUX-SCH>)                               CndRfg 571
c                                                                               CndRfg 572
c              Fluid properties subcomponent                                    CndRfg 573
        <cd;SupFluidProp> = NewFluidProperties(Jcd,<cd:REFG-SYSTEM>,32,         CndRfg 574
     &                      0., 0., 0., 0.,                                     CndRfg 575
     &                      0., 0., 0., 0.,                                     CndRfg 576
     &                      0., 0., 0., 0., 0.)                                 CndRfg 577
        <cd;RfgFluidProp> = NewFluidProperties(Jcd,<cd:REFG-SYSTEM>,34,         CndRfg 578
     &                      0., 0., 0., 0.,                                     CndRfg 579
     &                      0., 0., 0., 0.,                                     CndRfg 580
     &                      0., 0., 0., 0., 0.)                                 CndRfg 581
c                                                                               CndRfg 582
c              Heat-exchanger subcomponent                                      CndRfg 583
        <cd;HX> = NewHX(Jcd, -1, 0.,                                            CndRfg 584
     &                  <cd;SupFluidProp>,  <cd:SUPPLY-FILM-R>,                 CndRfg 585
     &                  <cd;RfgFluidProp>,  <cd:COND-FILM-RES>)                 CndRfg 586
c                                                                               CndRfg 587
c              Create nodes                                                     CndRfg 588
      CASE (203)                                                                CndRfg 589
c              Outlet interface (supply to liquid)                              CndRfg 590
        Jrs = <cd:REFG-SYSTEM>                                                  CndRfg 591
        <cd;InletNode>  = NewNode(1,   0,Jrs,Jcd,Jrs,     65,1,  0, 1.)         CndRfg 592
        <cd;OutletNode> = NewNode(1,   0,Jrs,Jcd,Jrs,     65,2,  0, 1.)         CndRfg 593
        <cd;SupInNode>  = NewNode(1, Jrs,Jrs,Jcd,<cd:LIQUID-CKT>,               CndRfg 594
     &                                                    61,1,Jrs, 1.)         CndRfg 595
        <cd;SupOutNode> = NewNode(1, Jrs,Jrs,Jcd,<cd:SUCTION-CKT>,              CndRfg 596
     &                                                    62,2,Jrs, 1.)         CndRfg 597
c                                                                               CndRfg 598
c              Electric and auxiliary meter                                     CndRfg 599
        Jme = <cd:ELEC-METER>                                                   CndRfg 600
        <cd:ELEC-METER> = NewNode(1, Jrs,Jrs,Jcd,Jme, 11,2,6, 1.)               CndRfg 601
        IF (<cd:AUX-METER> .GT. 0)  THEN                                        CndRfg 602
          Jme = <cd:AUX-METER>                                                  CndRfg 603
          <cd:AUX-METER> = NewNode(1, Jrs,Jrs,Jcd,Jme, 11,2,6, 1.)              CndRfg 604
        ENDIF                                                                   CndRfg 605
c                                                                               CndRfg 606
c              Links, lists                                                     CndRfg 607
      CASE (205)                                                                CndRfg 608
c              Get refrigerant pointer from refg plant                          CndRfg 609
        Jrs = <cd:REFG-SYSTEM>                                                  CndRfg 610
        <cd;Refrigerant> = <rs:REFRIGERANT>                                     CndRfg 611
c              Get pointer to reference enthalpy from liquid trunk              CndRfg 612
c                                                                               CndRfg 613
c              Suction side refrigerant                                         CndRfg 614
        Jrc             = <cd:SUCTION-CKT>                                      CndRfg 615
        Jrs             = <rc:/RefgSystem/>                                     CndRfg 616
        <cd;SucRefg>    = <rs:REFRIGERANT>                                      CndRfg 617
        <cd;SucHrefPtr> = IA_RefgHRef(Jrs)                                      CndRfg 618
c                                                                               CndRfg 619
c              Histories                                                        CndRfg 620
      CASE (208)                                                                CndRfg 621
c              Set up history on outlet conditions                              CndRfg 622
        Kri = <cd;SupInNode>                                                    CndRfg 623
        Kro = <cd;SupOutNode>                                                   CndRfg 624
        Kli = 0                                                                 CndRfg 625
        CALL ListAdd(Kli, Kri)                                                  CndRfg 626
        CALL ListAdd(Kli, Kro)                                                  CndRfg 627
        CALL ListAdd(Kli, <cd:AUX-METER>)                                       CndRfg 628
        KliX = 0                                                                CndRfg 629
        CALL ListXNodes(Kli, KliX)                                              CndRfg 630
        <cd;EnergyHsty> = NewHistory(Jrs,Jrs,Jcd, KliX, Kli,                    CndRfg 631
     &                      5, 3, 1.5,                                          CndRfg 632
     &                      <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                  CndRfg 633
     &                      <#ro.Houtlet>,    <sp:ERROR-H>, 1,                  CndRfg 634
     &                      <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                  CndRfg 635
     &                      <#ro.Preqd>  , <sp:ERROR-P>   , 1,                  CndRfg 636
     &                      0,0.,0, 0,0.,0)                                     CndRfg 637
c                                                                               CndRfg 638
c              History on mass flow, internal use only                          CndRfg 639
        Msuction = <#ro.Moutlet>                                                CndRfg 640
        Kro      = <cd;OutletNode>                                              CndRfg 641
        <cd;FlowsHsty> = NewHistory(0,0,Jcd, 0, 0,                              CndRfg 642
     &                     0, 3, 1.5,                                           CndRfg 643
     &                     Msuction     , <sp:ERROR-FLOW>/5., 2,                CndRfg 644
     &                     <#ro.Moutlet>, <sp:ERROR-FLOW>/5., 2,                CndRfg 645
     &                     0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                      CndRfg 646
c                                                                               CndRfg 647
c              Dump pointers                                                    CndRfg 648
      CASE (210)                                                                CndRfg 649
        Kri = <cd;InletNode>               ! refrigerant inlet                  CndRfg 650
        Xri = <ri;Xnode>                   ! refrigerant Xinlet                 CndRfg 651
        Kro = <cd;OutletNode>              ! refrigerant outlet                 CndRfg 652
        Xro = <ro;Xnode>                   ! refrigerant Xoutlet                CndRfg 653
        IF (<cd;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         CndRfg 654
        WRITE (IOUTPT, 9202)  (<cd:NAME>,II=1,8),                               CndRfg 655
     &    Jcd, Xri, Kro, Xro, <cd;SupInNode>, <cd;SupOutNode>                   CndRfg 656
c                                                                               CndRfg 657
c                                                                               CndRfg 658
      END SELECT  ! Mode                                                        CndRfg 659
c                                                                               CndRfg 660
      RETURN                                                                    CndRfg 661
c                                                                               CndRfg 662
c              Message formats                                                  CndRfg 663
 9002 FORMAT(14x,'Condenser: ',8A4,' has no design load'               )        CndRfg 664
 9003 FORMAT(14x,'Condenser: ',8A4,' must have a 2-speed or'           /        CndRfg 665
     &       14x,'variable-speed fan for the condenser loop LOAD-RESET'/        CndRfg 666
     &       14x,'temperature control strategy to work.  The control'  /        CndRfg 667
     &       14x,'strategy has been changed to FIXED.'                 )        CndRfg 668
 9201 FORMAT(/' CONDENSERs                             Jcd       Xri',          CndRfg 669
     &'       Kro       Xro     HW In    HW Out'                       /        CndRfg 670
     &1x,32('-'),6('  --------'))                                               CndRfg 671
 9202 FORMAT(1x,8A4,6I10)                                                       CndRfg 672
c                                                                               CndRfg 673
c                                                                               CndRfg 674
      CONTAINS                                                                  CndRfg 675
c ============== RefgFloatingSCT ============================================== CndRfg 676
      Subroutine RefgFloatingSCT                                                CndRfg 677
c                                                                               CndRfg 678
c              Calculates condenser load and suction conditions when            CndRfg 679
c              condensing temperature is floating                               CndRfg 680
                                                                                CndRfg 681
c              Solve for the SCT and the suction flow                           CndRfg 682
      Error     = 1.E20                                                         CndRfg 683
      ErrorMult = 1.                                                            CndRfg 684
      IterQ     = 0                                                             CndRfg 685
      DO                                                                        CndRfg 686
c              Condenser load and suction flow                                  CndRfg 687
        <cd.Qrej>  = Max(1., Mcycle * (HrefgIn-<ro.Houtlet>))                   CndRfg 688
        <rx.Mrefg> = <cd.Qrej> / (<rx.Hrefg>-<Xri.Hinlet>)                      CndRfg 689
                                                                                CndRfg 690
        IF (Abs(Error) .lt. ErrorMaxT)  Exit                                    CndRfg 691
        Error1 = Error                                                          CndRfg 692
                                                                                CndRfg 693
c              Available suction pressure, adjusted for control valve           CndRfg 694
        Voutlet  = RefgV_fPH(JreS, <Xro.Poutlet>, <rx.Hrefg>)                   CndRfg 695
        dPctrl   = (<rx.Mrefg> * <cd;1/Msupply>)**1.87                          CndRfg 696
     &           * (   Voutlet * <cd;SuctionD> )**1.6                           CndRfg 697
        dPctrl   = dPctrl * <cd;CtrlValveDP>                                    CndRfg 698
        Pctrl    = <Xro.Poutlet> + dPctrl                                       CndRfg 699
c              suction temperature                                              CndRfg 700
        SST = Max(SSTset, RefgT_fP(JreS, Pctrl))                                CndRfg 701
                                                                                CndRfg 702
c              Get condensing temperature                                       CndRfg 703
        Qsat = Qsct(<cd.SCT>)                                                   CndRfg 704
        CALL HX(4, Khx, Qsat,                   ! exclude subcooling            CndRfg 705
     &            <rx.Mrefg>,    SST, xSupTo,   ! suction flow                  CndRfg 706
     &                Mcycle, xDemTi,    SCT)   ! condenser flow                CndRfg 707
                                                                                CndRfg 708
c              Convergence error                                                CndRfg 709
        Error = SCT - <cd.SCT>                                                  CndRfg 710
        IF (Error/Error1 .lt. -0.5)  ! oscillating strongly                     CndRfg 711
     &    ErrorMult = ErrorMult * 0.5                                           CndRfg 712
        <cd.SCT> = <cd.SCT> + Error * ErrorMult                                 CndRfg 713
                                                                                CndRfg 714
c              Suction enthalpy                                                 CndRfg 715
        dTinlets   = <cd.SCT> - SST                                             CndRfg 716
        dTsuper    = Min(dTinlets, <cd:SUPERHEAT-DT>)                           CndRfg 717
        <rx.Hrefg> = RefgH_Vapor_fTS(JreS, SST, dTsuper)                        CndRfg 718
c              condenser enthalpy                                               CndRfg 719
        <cd.dTsubcool> = <cd:SUBCOOL-EFF> * dTinlets                            CndRfg 720
        <ro.Houtlet> = RefgH_Liquid_fTS(JreD, <cd.SCT>, <cd.dTsubcool>)         CndRfg 721
                                                                                CndRfg 722
        IterQ = IterQ + 1                                                       CndRfg 723
        IF (IterQ .eq. 100)  THEN                                               CndRfg 724
          CALL CnvgMsg2(1, Routine, Jcd)                                        CndRfg 725
          Error = 0.                                                            CndRfg 726
        ENDIF                                                                   CndRfg 727
      ENDDO                                                                     CndRfg 728
                                                                                CndRfg 729
      <rx.Mreqd> = <rx.Mrefg>    ! required suction flow                        CndRfg 730
                                                                                CndRfg 731
      End Subroutine RefgFloatingSCT                                            CndRfg 732
c                                                                               CndRfg 733
c                                                                               CndRfg 734
c ============== ReqdSST ====================================================== CndRfg 735
      Subroutine ReqdSST                                                        CndRfg 736
c                                                                               CndRfg 737
c              Calculates suction conditions for a given load                   CndRfg 738
                                                                                CndRfg 739
c              Heat rejection at saturation (for HX calc)                       CndRfg 740
      <cd.SCT> = <cd.Tsetpt>                                                    CndRfg 741
      Qsat     = Qsct(<cd.Tsetpt>)                                              CndRfg 742
                                                                                CndRfg 743
c              Solve for the SST and the suction flow                           CndRfg 744
      Error     = 1.E20                                                         CndRfg 745
      ErrorMult = 1.                                                            CndRfg 746
      IterQ     = 0                                                             CndRfg 747
      DO                                                                        CndRfg 748
c              Condenser load and suction flow                                  CndRfg 749
        <cd.Qrej>  = Max(1., Mcycle * (HrefgIn-<ro.Houtlet>))                   CndRfg 750
        <rx.Mrefg> = <cd.Qrej> / (<rx.Hrefg>-<Xri.Hinlet>)                      CndRfg 751
                                                                                CndRfg 752
        IF (Abs(Error) .lt. ErrorMaxT)  Exit                                    CndRfg 753
        Error1 = Error                                                          CndRfg 754
                                                                                CndRfg 755
c              Get required SST                                                 CndRfg 756
        CALL HX(2, Khx, Qsat,                     ! no subcool                  CndRfg 757
     &            <rx.Mrefg>,  SSTreqd, xSupTo,   ! suction                     CndRfg 758
     &                Mcycle, <cd.SCT>, xDemTo)   ! condenser                   CndRfg 759
                                                                                CndRfg 760
c              Convergence error                                                CndRfg 761
        Error = SSTreqd - <cd.SSTreqd>                                          CndRfg 762
        IF (Error/Error1 .lt. -0.5)  ! oscillating strongly                     CndRfg 763
     &    ErrorMult = ErrorMult * 0.5                                           CndRfg 764
        <cd.SSTreqd> = <cd.SSTreqd> + Error * ErrorMult                         CndRfg 765
                                                                                CndRfg 766
c              Suction enthalpy                                                 CndRfg 767
        dTinlets   = <cd.SCT> - <cd.SSTreqd>                                    CndRfg 768
        dTsuper    = Min(dTinlets, <cd:SUPERHEAT-DT>)                           CndRfg 769
        <rx.Hrefg> = RefgH_Vapor_fTS(JreS, <cd.SSTreqd>, dTsuper)               CndRfg 770
c              condenser enthalpy                                               CndRfg 771
        <cd.dTsubcool> = <cd:SUBCOOL-EFF> * dTinlets                            CndRfg 772
        <ro.Houtlet> = RefgH_Liquid_fTS(JreD, <cd.SCT>, <cd.dTsubcool>)         CndRfg 773
                                                                                CndRfg 774
        IterQ = IterQ + 1                                                       CndRfg 775
        IF (IterQ .eq. 100)  THEN                                               CndRfg 776
          CALL CnvgMsg2(1, Routine, Jcd)                                        CndRfg 777
          Error = 0.                                                            CndRfg 778
        ENDIF                                                                   CndRfg 779
      ENDDO                                                                     CndRfg 780
                                                                                CndRfg 781
c              Required suction conditions                                      CndRfg 782
      <rx.Mreqd> = <rx.Mrefg>                                                   CndRfg 783
      Pctrl      = RefgP_fT(JreS, <cd.SSTreqd>)                                 CndRfg 784
c              adjust for effect of control valve                               CndRfg 785
      Voutlet    = RefgV_fPH(JreS, <Xro.Poutlet>, <rx.Hrefg>)                   CndRfg 786
      dPctrl     = (<rx.Mrefg> * <cd;1/Msupply>)**1.87                          CndRfg 787
     &           * (   Voutlet * <cd;SuctionD> )**1.6                           CndRfg 788
      dPctrl     = dPctrl * <cd;CtrlValveDP>                                    CndRfg 789
      <rx.Preqd> = Pctrl - dPctrl                                               CndRfg 790
c                                                                               CndRfg 791
      End Subroutine ReqdSST                                                    CndRfg 792
c                                                                               CndRfg 793
      END                                                                       CndRfg 794
C ##############################################################################DSAlgs   2
C ##############################################################################DSAlgs   3
C ##############################################################################DSAlgs   4
C ##############################################################################DSAlgs   5
C ##########                                                          ##########DSAlgs   6
C ##########                  DESUPERHEATER ROUTINES                  ##########DSAlgs   7
C ##########                                                          ##########DSAlgs   8
C ##############################################################################DSAlgs   9
C ##############################################################################DSAlgs  10
C ##############################################################################DSAlgs  11
C ##############################################################################DSAlgs  12
c                                                                               DSAlgs  13
      SUBROUTINE Desuperheater_Injection(Mode, Jds)                             DSInj    2
c                                                                               DSInj    3
c              Simulates a desuperheater using direct injection of              DSInj    4
c              liquid refrigerant into a suction line.                          DSInj    5
c                                                                               DSInj    6
c              A desuperheater is always located at the outlet end of a         DSInj    7
c              suction refrigerant circuit.                                     DSInj    8
c                                                                               DSInj    9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               DSInj   17
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               DSInj   19
      INTEGER  Xri, Xro, rH                                                     DSInj   20
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             DSInj   21
      REAL     Mdesuper, Msupply                                                DSInj   22
c                                                                               DSInj   23
c                                                                               DSInj   24
c              Pointer to refrigerant                                           DSInj   25
      Jre = <ds;Refrigerant>                                                    DSInj   26
c                                                                               DSInj   27
      SELECT CASE (Mode)                                                        DSInj   28
c                                                                               DSInj   29
c                                                                               DSInj   30
c ============ HOURLY SIMULATION - LOADS TO SUCTION-GROUP ===================== DSInj   31
      CASE (31)                                                                 DSInj   32
c                                                                               DSInj   33
c              This call calculates the outlet mass flow rate,                  DSInj   34
c              temperature, required pressure, and enthalpy as a                DSInj   35
c              function of the inlet conditions                                 DSInj   36
                                                                                DSInj   37
c******** Note: RunFrac not debugged ?? ***************                         DSInj   38
c                                                                               DSInj   39
c              Check if iteration required                                      DSInj   40
      IterNode = IterReqdNode(1, <ds;Nodes>)                                    DSInj   41
      IF (.NOT. IterNode  .AND.                                                 DSInj   42
     &    .NOT. IterReqdHsty(<ds;Hstys>))  RETURN                               DSInj   43
c                                                                               DSInj   44
c              Desuperheated flow                                               DSInj   45
      Kri = <ds;DesupInNode>                                                    DSInj   46
      Kro = <ds;DesupOutNode>                                                   DSInj   47
      Xro = <ro;Xnode>                                                          DSInj   48
c                                                                               DSInj   49
c              Get the desuperheater inlet loads.  Note that the pressure       DSInj   50
c              is the required pressure that will be passed downstream,         DSInj   51
c              not the actual inlet pressure                                    DSInj   52
      CALL RefgNode(Kri, <ri.Minlet>,<ri.Mreqd>, <ri.Hinlet>, xTreqd,           DSInj   53
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     DSInj   54
c                                                                               DSInj   55
      <ri.Qinlet> = <ri.Minlet> * (<ri.Hinlet>-AA(<ds;RefgHrefPtr>))            DSInj   56
      RunFrac     = <ri.RunFrac>                                                DSInj   57
c                                                                               DSInj   58
c              skip if no mass flow                                             DSInj   59
      IF (<ri.Minlet> .EQ. 0.)  THEN                                            DSInj   60
        <ds;Qdesuper> = 0.                                                      DSInj   61
        Kri           = <ds;SupplyInNode>                                       DSInj   62
        Xri           = <ri;Xnode>                                              DSInj   63
        Kro           = <ds;SupplyOutNode>                                      DSInj   64
        <ro.Mreqd>    = 0.                                                      DSInj   65
        Msupply       = 0.                                                      DSInj   66
        GOTO 3190                                                               DSInj   67
      ENDIF                                                                     DSInj   68
c                                                                               DSInj   69
c              Condenser is operating. If cycling, convert hourly               DSInj   70
c              average refrigerant flow to flow when cycled on                  DSInj   71
      Mdesuper = <ri.Minlet> / RunFrac                                          DSInj   72
                                                                                DSInj   73
c              Superheated refrigerant conditions at inlet and outlet           DSInj   74
      TdesuperIn    = RefgT_fPH(Jre, <Xro.Poutlet>,<ri.Hinlet>)                 DSInj   75
      dTsuper       = RefgSuper_fPH(Jre, <Xro.Poutlet>,<ri.Hinlet>)             DSInj   76
      dT            = MAX(0., dTsuper - <ds:SUPERHEAT-SET>)                     DSInj   77
      Toutlet       = TdesuperIn - dT                                           DSInj   78
      Cp            = RefgCp_Vapor_fP(Jre, <Xro.Poutlet>)                       DSInj   79
      dQ            = Cp * dT                                                   DSInj   80
      Houtlet       = <ri.Hinlet> - dQ                                          DSInj   81
      Poutlet       = <Xro.Poutlet>                                             DSInj   82
      <ds;Qdesuper> = dQ * Mdesuper                                             DSInj   83
c                                                                               DSInj   84
c                                                                               DSInj   85
c              Now injected flow                                                DSInj   86
      Kri     = <ds;SupplyInNode>                                               DSInj   87
      Xri     = <ri;Xnode>                                                      DSInj   88
      Kro     = <ds;SupplyOutNode>                                              DSInj   89
      dH      = MAX(0., Houtlet - <Xri.Hinlet>)                                 DSInj   90
      Msupply = <ds;Qdesuper> / dH                                              DSInj   91
c              required properties                                              DSInj   92
      <ro.Mreqd> = Msupply                                                      DSInj   93
      IF (Msupply .GT. 0.)  THEN                                                DSInj   94
c              pressure and temperature                                         DSInj   95
        dP         = <ds:LIQUID-DP> * (Msupply*<ds;1/Msupply>)**1.87            DSInj   96
        <ri.Preqd> = MIN(<re;Pmax>, Poutlet+dP)                                 DSInj   97
        <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                DSInj   98
c              adjust mass flow if pressure insufficient                        DSInj   99
        IF (<ri.Preqd> .GT. <Xri.Pinlet>)  THEN                                 DSInj  100
          dPmax = <Xri.Pinlet> - Poutlet                                        DSInj  101
          IF (dPmax .GT. 0.)  THEN                                              DSInj  102
            Msupply = EXP(LOG(dPmax/<ds:LIQUID-DP>)/1.87                        DSInj  103
     &                                           - LOG(<ds;1/Msupply>))         DSInj  104
          ELSE                                                                  DSInj  105
            Msupply = 0.                                                        DSInj  106
          ENDIF                                                                 DSInj  107
          Houtlet = (Mdesuper*HdesuperIn + Msupply*<Xri.Hinlet>)                DSInj  108
     &                                            / (Mdesuper + Msupply)        DSInj  109
          Toutlet = RefgT_fPH(Jre, Poutlet,Houtlet)                             DSInj  110
        ENDIF                                                                   DSInj  111
      ENDIF  ! Msupply .gt. 0                                                   DSInj  112
      <ro.Houtlet> = Houtlet                                                    DSInj  113
      <ro.Preqd>   = -88888.                                                    DSInj  114
                                                                                DSInj  115
c              Re-entry point for no load (pointers are injection gas)          DSInj  116
 3190 <ds;Qdesuper> = <ds;Qdesuper> * RunFrac                                   DSInj  117
      <ro.RunFrac>  = RunFrac                                                   DSInj  118
      <ro.Mreqd>    = <ro.Mreqd>    * RunFrac                                   DSInj  119
      <ro.Moutlet>  = Msupply       * RunFrac                                   DSInj  120
      <ro.Qoutlet>  = <ro.Moutlet>  * (Houtlet-AA(<ds;RefgHrefPtr>))            DSInj  121
c              check for convergence of injected gas                            DSInj  122
      CALL CnvgCheck(1, <ds;SupplyHsty>)                                        DSInj  123
      <ri.RunFrac> = RunFrac                                                    DSInj  124
      <ri.Minlet>  = <ro.Moutlet>                                               DSInj  125
      <ri.Mreqd>   = <ro.Mreqd>                                                 DSInj  126
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<ds;RefgHrefPtr>))          DSInj  127
c                                                                               DSInj  128
c              Desuperheated gas                                                DSInj  129
      Kri = <ds;DesupInNode>                                                    DSInj  130
      Kro = <ds;DesupOutNode>                                                   DSInj  131
      Xro = <ro;Xnode>                                                          DSInj  132
      <ro.RunFrac> = <ri.RunFrac>                                               DSInj  133
      <ro.Moutlet> = <ri.Minlet>                                                DSInj  134
      IF (<ro.Moutlet> .GT. 0.)  THEN                                           DSInj  135
        <ro.Toutlet> = Toutlet                                                  DSInj  136
        <ro.Houtlet> = Houtlet                                                  DSInj  137
      ENDIF                                                                     DSInj  138
c              Pass along the required pressure of the upstream loads           DSInj  139
      <ro.Mreqd> = <ri.Mreqd>                                                   DSInj  140
      IF (<ro.Mreqd> .GT. 0.  .AND.  <ri.Preqd> .GT. -888.)  THEN               DSInj  141
        Voutlet = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                   DSInj  142
        dP      = <ds:DESUPER-DP>                                               DSInj  143
     &          * (<ro.Mreqd>/RunFrac*<ds;1/Mdesuper>)**1.87                    DSInj  144
     &          * (Voutlet*<ds;DesuperOutD>)**1.6                               DSInj  145
        <ro.Preqd> = MAX(<re;Pmin>, <ri.Preqd>-dP)                              DSInj  146
      ELSE                                                                      DSInj  147
        <ro.Preqd> = -88888.                                                    DSInj  148
      ENDIF                                                                     DSInj  149
c              check for convergence of desuperheated gas                       DSInj  150
      CALL CnvgCheck(1, <ds;DesupOutHsty>)                                      DSInj  151
      <ro.Qoutlet> = <ro.Moutlet> * (<ro.Houtlet>-AA(<ds;RefgHrefPtr>))         DSInj  152
c                                                                               DSInj  153
c              Auxiliary power                                                  DSInj  154
      IF (<ds:AUX-KW> .GT. 0.)  THEN                                            DSInj  155
        SELECT CASE (<ds:AUX-MODE>)                                             DSInj  156
          CASE (1)  ! Always                                                    DSInj  157
            AuxKW = <ds:AUX-KW>                                                 DSInj  158
          CASE (2)  ! When on                                                   DSInj  159
            IF (Msupply .GT. 0.)  THEN                                          DSInj  160
              AuxKW = <ds:AUX-KW> * RunFrac                                     DSInj  161
            ELSE                                                                DSInj  162
              AuxKW = 0.                                                        DSInj  163
            ENDIF                                                               DSInj  164
          CASE (3)  ! When off                                                  DSInj  165
            IF (Msupply .EQ. 0.)  THEN                                          DSInj  166
              AuxKW = <ds:AUX-KW> * (1.-RunFrac)                                DSInj  167
            ELSE                                                                DSInj  168
              AuxKW = 0.                                                        DSInj  169
            ENDIF                                                               DSInj  170
          CASE (4)  ! Scheduled                                                 DSInj  171
            AuxKW = <ds:AUX-KW> * SchVal(<ds:AUX-SCH>)                          DSInj  172
        END SELECT                                                              DSInj  173
        Kmd = <ds:AUX-METER>                                                    DSInj  174
        Kmx = <md;Xnode>                                                        DSInj  175
        IF (AuxKW .GT. 0.)  THEN                                                DSInj  176
          IF (ABS(1. - <md.Elec>/AuxKW) .GT. <sp:ERROR-LOAD>)                   DSInj  177
     &      <mx.IterFlag> = Jds                                                 DSInj  178
        ELSE                                                                    DSInj  179
          IF (<md.Elec> .GT. 0.)  <mx.IterFlag> = Jds                           DSInj  180
        ENDIF                                                                   DSInj  181
        <md.Elec> = AuxKW                                                       DSInj  182
      ENDIF                                                                     DSInj  183
c                                                                               DSInj  184
c                                                                               DSInj  185
c ============ HOURLY SIMULATION - SUCTION-GROUP TO LOADS ===================== DSInj  186
      CASE (32)                                                                 DSInj  187
c                                                                               DSInj  188
c              Check if iteration required                                      DSInj  189
      IterNode = IterReqdNode(1, <ds;Nodes>)                                    DSInj  190
      IF (.NOT. IterNode  .AND.                                                 DSInj  191
     &    .NOT. IterReqdHsty(<ds;Hstys>))  RETURN                               DSInj  192
c                                                                               DSInj  193
c              Desuperheated flow                                               DSInj  194
      Kri = <ds;DesupInNode>                                                    DSInj  195
      Kro = <ds;DesupOutNode>                                                   DSInj  196
      Xro = <ro;Xnode>                                                          DSInj  197
c                                                                               DSInj  198
c              Pressure at outlet                                               DSInj  199
      <ri.Pinlet> = <Xro.Poutlet>                                               DSInj  200
      IF (<ro.Moutlet> .gt. 0.) THEN                                            DSInj  201
        Voutlet = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                   DSInj  202
        dP = <ds:DESUPER-DP>                                                    DSInj  203
     &     * (<ro.Moutlet>/<ro.RunFrac>*<ds;1/Mdesuper>)**1.87                  DSInj  204
     &     * (Voutlet*<ds;DesuperOutD>)**1.6                                    DSInj  205
        <ri.Pinlet> = <ri.Pinlet> + dP                                          DSInj  206
      ENDIF                                                                     DSInj  207
c                                                                               DSInj  208
c              Check for convergence on inlet pressure                          DSInj  209
      CALL CnvgCheck(1, <ds;DesupInHsty>)                                       DSInj  210
c                                                                               DSInj  211
c                                                                               DSInj  212
c ============ REPORT CREATION ================================================ DSInj  213
      CASE (50)                                                                 DSInj  214
c                                                                               DSInj  215
c              statistics blocks                                                DSInj  216
      Ks2Load      = NewStat2(Jds, <+ds;Qdesuper>, 0, 1.)                       DSInj  217
      Ks5LoadBin   = NewStat5(Jds, <+ds;Qdesuper>, 0, 1.)                       DSInj  218
      Ks2Msply     = NewStat2(<ds;SupplyInNode>,  <+ri.Minlet>, 0, 1.)          DSInj  219
      Ks5MsplyBin  = NewStat5(<ds;SupplyInNode>,  <+ri.Minlet>, 0, 1.)          DSInj  220
      Ks2Mdesuper  = NewStat2(<ds;DesupInNode>,   <+ri.Minlet>, 0, 1.)          DSInj  221
      Ks5MdesupBin = NewStat5(<ds;DesupInNode>,   <+ri.Minlet>, 0, 1.)          DSInj  222
      Ks2Aux       = NewStat2(<ds:AUX-METER>,       <+md.Elec>, 0, 1.)          DSInj  223
c                                                                               DSInj  224
c              Create the type "H" report                                       DSInj  225
      IF (<ds:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      DSInj  226
     &  <ds;PS-H> = NewReport_H(Jds, 138,                                       DSInj  227
     &                          4, 5, 6,                                        DSInj  228
     &                          Ks2Load, Ks2Mdesuper, Ks2Msply,Ks2Aux,          DSInj  229
     &                          Ks5LoadBin, Ks5MdesupBin, Ks5MsplyBin,          DSInj  230
     &                          0, 0, 0)                                        DSInj  231
c                                                                               DSInj  232
c                                                                               DSInj  233
c ============ REPORT ORDER =================================================== DSInj  234
      CASE (52)                                                                 DSInj  235
c                                                                               DSInj  236
      Call Report_H(Mode, <ds;PS-H>)                                            DSInj  237
c                                                                               DSInj  238
c                                                                               DSInj  239
c ============ REPORTS - VERIFICATION DATA ==================================== DSInj  240
      CASE (54)                                                                 DSInj  241
c                                                                               DSInj  242
c              Output design information                                        DSInj  243
      IF (<ds;PS-H> .ne. 0)  THEN                                               DSInj  244
        rH = <ds;PS-H>                                                          DSInj  245
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       DSInj  246
        CALL GetAttachments(Jds, 2)                                             DSInj  247
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   DSInj  248
     &    (NameAttachments(II,1,1),II=1,8),                                     DSInj  249
     &    (NameAttachments(II,1,2),II=1,8),                                     DSInj  250
     &    <ds;Capacity>,<ds;Mdesuper>,<ds;Msupply>,<ds:SUPERHEAT-SET>,          DSInj  251
     &    <ds;DesignUA>                                                         DSInj  252
        DO  Irow=2,NumRowsOfAttachments                                         DSInj  253
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 DSInj  254
     &      (NameAttachments(II,Irow,1),II=1,8),                                DSInj  255
     &      (NameAttachments(II,Irow,2),II=1,8)                                 DSInj  256
        ENDDO                                                                   DSInj  257
      ENDIF                                                                     DSInj  258
c                                                                               DSInj  259
c                                                                               DSInj  260
c ============ HOURLY REPORTS - HOURLY DATA =================================== DSInj  261
      CASE (62)                                                                 DSInj  262
c                                                                               DSInj  263
c              Hourly-report variables                                          DSInj  264
      IF (<ds;HourRepBuf> .EQ. 0)  RETURN                                       DSInj  265
c                                                                               DSInj  266
      IAptr        = <ds;HourRepBuf> - 1                                        DSInj  267
      AA(IAptr+1)  = <ds;Qdesuper>                                              DSInj  268
c              desuperheated inlet                                              DSInj  269
      Kri          = <ds;DesupInNode>                                           DSInj  270
      AA(IAptr+2)  = <ri.Qinlet>                                                DSInj  271
      AA(IAptr+3)  = <ri.Minlet>                                                DSInj  272
      AA(IAptr+4)  = RefgT_fPH(Jre, <ri.Pinlet>,<ri.Hinlet>)                    DSInj  273
      AA(IAptr+5)  = <ri.Pinlet>                                                DSInj  274
      AA(IAptr+6)  = <ri.Preqd>                                                 DSInj  275
      AA(IAptr+7)  = <ri.Hinlet>                                                DSInj  276
c              desuperheated outlet                                             DSInj  277
      Kro          = <ds;DesupOutNode>                                          DSInj  278
      Xro          = <ro;Xnode>                                                 DSInj  279
      AA(IAptr+8)  = <ro.Qoutlet>                                               DSInj  280
      AA(IAptr+9)  = <ro.Moutlet>                                               DSInj  281
c     AA(IAptr+10) = unused                                                     DSInj  282
      AA(IAptr+11) = <ro.Toutlet>                                               DSInj  283
c     AA(IAptr+12) = unused                                                     DSInj  284
      AA(IAptr+13) = <Xro.Poutlet>                                              DSInj  285
      AA(IAptr+14) = <ro.Preqd>                                                 DSInj  286
      AA(IAptr+15) = <ro.Houtlet>                                               DSInj  287
c              liquid supply inlet                                              DSInj  288
      Kri          = <ds;SupplyInNode>                                          DSInj  289
      Xri          = <ri;Xnode>                                                 DSInj  290
      AA(IAptr+16) = <ri.Qinlet>                                                DSInj  291
      AA(IAptr+17) = <ri.Minlet>                                                DSInj  292
      AA(IAptr+18) = <Xri.Pinlet>                                               DSInj  293
      AA(IAptr+19) = <ri.Preqd>                                                 DSInj  294
      AA(IAptr+20) = <Xri.Hinlet>                                               DSInj  295
c              suction supply outlet                                            DSInj  296
      AA(IAptr+21) = <ro.Qoutlet>                                               DSInj  297
      AA(IAptr+22) = <ro.Moutlet>                                               DSInj  298
      AA(IAptr+23) = <Xro.Poutlet>                                              DSInj  299
      AA(IAptr+24) = <ro.Preqd>                                                 DSInj  300
      AA(IAptr+25) = <ro.Houtlet>                                               DSInj  301
c                                                                               DSInj  302
      AA(IAptr+26) = <ds;Tsetpt>                                                DSInj  303
      AA(IAptr+27) = <ds;UA>                                                    DSInj  304
c                                                                               DSInj  305
c                                                                               DSInj  306
c ============ DESIGN CALCULATIONS - LOADS TO SUCTION-GROUP =================== DSInj  307
      CASE (111)                                                                DSInj  308
c                                                                               DSInj  309
c              This call calculates the design outlet mass flow rate,           DSInj  310
c              temperature, required pressure, and enthalpy as a                DSInj  311
c              function of the inlet conditions                                 DSInj  312
c                                                                               DSInj  313
c              Desuperheated flow                                               DSInj  314
      Kri = <ds;DesupInNode>                                                    DSInj  315
      Kro = <ds;DesupOutNode>                                                   DSInj  316
      Xro = <ro;Xnode>                                                          DSInj  317
c                                                                               DSInj  318
c              Set iteration flag on outlet                                     DSInj  319
      <Xro.IterFlag> = Jds                                                      DSInj  320
c                                                                               DSInj  321
c              Design quantities from suppliers (at inlet)                      DSInj  322
      CALL RefgNode(Kri, <ri.Minlet>,xMreqd, <ri.Hinlet>, xTreqd,               DSInj  323
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     DSInj  324
c                                                                               DSInj  325
c              Design flow                                                      DSInj  326
      IF (<ds:DESUPER-FLOW> .GT. 0.)  THEN                                      DSInj  327
        <ds;Mdesuper> = <ds:DESUPER-FLOW>                                       DSInj  328
      ELSE                                                                      DSInj  329
        <ds;Mdesuper> = <ri.Minlet>                                             DSInj  330
      ENDIF                                                                     DSInj  331
      <ro.Moutlet> = <ri.Minlet>                                                DSInj  332
      <ro.Mreqd>   = <ri.Minlet>                                                DSInj  333
      <ro.Preqd>   = <ri.Preqd> - <ds:DESUPER-DP>                               DSInj  334
c                                                                               DSInj  335
c              Skip if outlet pressure not yet known (first pass)               DSInj  336
      IF (<Xro.Poutlet> .EQ. 0.)  RETURN                                        DSInj  337
c                                                                               DSInj  338
c              Adjust outlet enthalpy for desuperheating effect                 DSInj  339
      TdesuperIn  = RefgT_fPH(Jre, <Xro.Poutlet>,<ri.Hinlet>)                   DSInj  340
      dTsuper     = RefgSuper_fPH(Jre, <Xro.Poutlet>,<ri.Hinlet>)               DSInj  341
      dT          = MAX(0., dTsuper - <ds:SUPERHEAT-SET>)                       DSInj  342
      Toutlet     = TdesuperIn - dT                                             DSInj  343
      Cp          = RefgCp_Vapor_fP(Jre, <Xro.Poutlet>)                         DSInj  344
      dQ          = Cp * dT                                                     DSInj  345
      HdesuperIn  = <ri.Hinlet>                                                 DSInj  346
      Houtlet     = HdesuperIn - dQ                                             DSInj  347
      <ro.Houtlet> = Houtlet                                                    DSInj  348
c              required outlet pressure                                         DSInj  349
      IF (<ds:DESUPER-FLOW> .GT. 0.  .AND.  <ro.Mreqd> .GT. 0.)  THEN           DSInj  350
        dP = <ds:DESUPER-DP> * (<ro.Mreqd>/<ds:DESUPER-FLOW>)**1.87             DSInj  351
      ELSE                                                                      DSInj  352
        dP = <ds:DESUPER-DP>                                                    DSInj  353
      ENDIF                                                                     DSInj  354
      <ro.Preqd> = <ri.Preqd> - dP                                              DSInj  355
c                                                                               DSInj  356
c              Capacity                                                         DSInj  357
      IF (<ds:CAPACITY> .NE. 0.)  THEN                                          DSInj  358
        <ds;Capacity> = <ds:CAPACITY>                                           DSInj  359
      ELSE                                                                      DSInj  360
        <ds;Capacity> = <ri.Minlet> * dQ                                        DSInj  361
      ENDIF                                                                     DSInj  362
c                                                                               DSInj  363
c              Now liquid feed                                                  DSInj  364
      Kri          = <ds;SupplyInNode>                                          DSInj  365
      Xri          = <ri;Xnode>                                                 DSInj  366
      Kro          = <ds;SupplyOutNode>                                         DSInj  367
      Xro          = <ro;Xnode>                                                 DSInj  368
      <ro.Moutlet> = <ds;Capacity> / (Houtlet - <Xri.Hinlet>)                   DSInj  369
      <ro.Mreqd>   = <ro.Moutlet>                                               DSInj  370
      <ro.Houtlet> = Houtlet                                                    DSInj  371
      <ro.Preqd>   = -88888.                                                    DSInj  372
c              Check for convergence on outlet conditions                       DSInj  373
      CALL CnvgCheck(1, <ds;SupplyHsty>)                                        DSInj  374
      <ri.Minlet> = <ro.Moutlet>                                                DSInj  375
      <ri.Mreqd>  = <ro.Moutlet>                                                DSInj  376
c                                                                               DSInj  377
c              Required supply pressure and temperature                         DSInj  378
      IF (<ds:LIQUID-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)  THEN          DSInj  379
        dP = <ds:LIQUID-DP> * (<ro.Moutlet>/<ds:LIQUID-FLOW>)**1.87             DSInj  380
      ELSE                                                                      DSInj  381
        dP = <ds:LIQUID-DP>                                                     DSInj  382
      ENDIF                                                                     DSInj  383
      <ri.Preqd> = <Xro.Poutlet> + dP                                           DSInj  384
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  DSInj  385
c                                                                               DSInj  386
      IF (<ds:LIQUID-FLOW> .GT. 0.)  THEN                                       DSInj  387
        <ds;Msupply> = <ds:LIQUID-FLOW>                                         DSInj  388
      ELSE                                                                      DSInj  389
        <ds;Msupply> = <ro.Moutlet>                                             DSInj  390
      ENDIF                                                                     DSInj  391
c                                                                               DSInj  392
c              Auxiliary power                                                  DSInj  393
      IF (<ds:AUX-METER> .GT. 0.)  THEN                                         DSInj  394
        Kmd       = <ds:AUX-METER>                                              DSInj  395
        <md.Elec> = <ds:AUX-KW>                                                 DSInj  396
      ENDIF                                                                     DSInj  397
c                                                                               DSInj  398
c                                                                               DSInj  399
c ============ DESIGN CALCULATIONS - SUCTION-GROUP TO LOADS =================== DSInj  400
      CASE (112)                                                                DSInj  401
c                                                                               DSInj  402
c              Desuperheated flow                                               DSInj  403
      Kri = <ds;DesupInNode>                                                    DSInj  404
      Kro = <ds;DesupOutNode>                                                   DSInj  405
      Xro = <ro;Xnode>                                                          DSInj  406
c                                                                               DSInj  407
c              Adjust for pressure loss thru desuperheater                      DSInj  408
      IF (<ds:DESUPER-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)  THEN         DSInj  409
        dP = <ds:DESUPER-DP> * (<ro.Moutlet>/<ds:DESUPER-FLOW>)**1.87           DSInj  410
      ELSE                                                                      DSInj  411
        dP = <ds:DESUPER-DP>                                                    DSInj  412
      ENDIF                                                                     DSInj  413
      <ri.Pinlet> = <Xro.Poutlet> + dP                                          DSInj  414
c                                                                               DSInj  415
c                                                                               DSInj  416
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== DSInj  417
      CASE (119)                                                                DSInj  418
c                                                                               DSInj  419
      IF (<ds;Mdesuper> .GT. 0.)  <ds;1/Mdesuper> = 1.0 / <ds;Mdesuper>         DSInj  420
      IF (<ds;Msupply>  .GT. 0.)  <ds;1/Msupply>  = 1.0 / <ds;Msupply>          DSInj  421
c                                                                               DSInj  422
c              Desuperheated flow                                               DSInj  423
      Kri = <ds;DesupInNode>                                                    DSInj  424
      Kro = <ds;DesupOutNode>                                                   DSInj  425
      Xro = <ro;Xnode>                                                          DSInj  426
      Hdesuper = <ro.Houtlet>                                                   DSInj  427
c              warn if insufficient mass flow capacity                          DSInj  428
      IF (<ri.Minlet> .GT. <ds;Mdesuper>*1.01)  THEN                            DSInj  429
        CALL MSGSIM(-2,II,II,II,II)                                             DSInj  430
        WRITE (IOUTPT, 9001)  (<ds:NAME>,II=1,8),                               DSInj  431
     &                         <ri.Minlet>, <ds;Mdesuper>                       DSInj  432
      ENDIF                                                                     DSInj  433
c                                                                               DSInj  434
c              Design volume and density at outlet                              DSInj  435
      <ds;DesuperOutV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)            DSInj  436
      <ds;DesuperOutD> = 1.0 / <ds;DesuperOutV>                                 DSInj  437
c                                                                               DSInj  438
c              Liquid flow                                                      DSInj  439
      Kri = <ds;SupplyInNode>                                                   DSInj  440
      Xri = <ri;Xnode>                                                          DSInj  441
c              warn if insufficient capacity                                    DSInj  442
      CapLiquid = <ds;Msupply> * (Hdesuper - <Xri.Hinlet>)                      DSInj  443
      IF (<ds;Capacity> .GT. CapLiquid*1.01)  THEN                              DSInj  444
        CALL MSGSIM(-2,II,II,II,II)                                             DSInj  445
        WRITE (IOUTPT, 9002)  (<ds:NAME>,II=1,8),                               DSInj  446
     &                         CapLiquid, <ds;Capacity>                         DSInj  447
      ENDIF                                                                     DSInj  448
      <ds;Qdesuper> = <ds;Capacity>                                             DSInj  449
c                                                                               DSInj  450
c                                                                               DSInj  451
c ============ ATTACHMENTS ==================================================== DSInj  452
c                                                                               DSInj  453
c              Initial attachments                                              DSInj  454
      CASE (201)                                                                DSInj  455
c              Component pointers, schedules, and curves                        DSInj  456
        <ds:LIQUID-CKT>    = Jcomponent(22, <ds:LIQUID-CKT>)                    DSInj  457
        <ds:SUCTION-GROUP> = Jcomponent(25, <ds:SUCTION-GROUP>)                 DSInj  458
        <ds:/SuctionGroup> = Jcomponent(25, <ds:/SuctionGroup>)                 DSInj  459
        <ds:/RefgSystem/>  = Jcomponent(29, <ds:/RefgSystem/>)                  DSInj  460
        <ds:AUX-METER>     = Jcomponent(13, <ds:AUX-METER>)                     DSInj  461
        <ds:COST-DATA>     = Jcomponent(18, <ds:COST-DATA>)                     DSInj  462
        <ds:AUX-SCH>       = Jsched(<ds:AUX-SCH>)                               DSInj  463
c              desuperheated attachment                                         DSInj  464
        SELECT CASE (<ds:ATTACH-TO>)                                            DSInj  465
          CASE (2)  ! Suction-group                                             DSInj  466
            <ds:DESUPER-CKT> = <ds:SUCTION-GROUP>                               DSInj  467
          CASE (6)  ! Refg-circuit                                              DSInj  468
            <ds:DESUPER-CKT> = Jcomponent(22, <ds:DESUPER-CKT>)                 DSInj  469
        END SELECT                                                              DSInj  470
c                                                                               DSInj  471
c              Second level of attachments                                      DSInj  472
      CASE (202)                                                                DSInj  473
        Jrs = <ds:/RefgSystem/>                                                 DSInj  474
        <ds;Refrigerant> = <rs:REFRIGERANT>                                     DSInj  475
c                                                                               DSInj  476
c              Create nodes                                                     DSInj  477
      CASE (203)                                                                DSInj  478
c              Check for cross-connected systems                                DSInj  479
        CALL RefgX(Jds, <ds:DESUPER-CKT>,<ds:LIQUID-CKT>,0)                     DSInj  480
c              Create the attachments; inlet, outlet, and liquid                DSInj  481
        Jrs = <ds:/RefgSystem/>                                                 DSInj  482
        Jsg = <ds:/SuctionGroup>                                                DSInj  483
        <ds;DesupInNode>   = NewNode(1, Jrs,-Jsg,Jds,0,    62,1,Jrc, 1.)        DSInj  484
        <ds;DesupOutNode>  = NewNode(1, Jrs,-Jsg,Jds,<ds:DESUPER-CKT>,          DSInj  485
     &                                                     62,2,Jrc, 1.)        DSInj  486
        <ds;SupplyInNode>  = NewNode(1, Jrs,-Jsg,Jds,<ds:LIQUID-CKT>,           DSInj  487
     &                                                     61,1,Jrc, 1.)        DSInj  488
        <ds;SupplyOutNode> = NewNode(1, Jrs,-Jsg,Jds,<ds:DESUPER-CKT>,          DSInj  489
     &                                                     62,2,Jrc, 1.)        DSInj  490
c              Auxiliary meter                                                  DSInj  491
        Jme            = <ds:AUX-METER>                                         DSInj  492
        <ds:AUX-METER> = NewNode(1, Jrs,-Jsg,Jds,Jme, 11,2,7, 1.)               DSInj  493
c                                                                               DSInj  494
c              Links, lists                                                     DSInj  495
      CASE (205)                                                                DSInj  496
c              Check if no attachments                                          DSInj  497
        Kri = <ds;DesupInNode>                                                  DSInj  498
        IF (<ri;Xnode> .EQ. 0)  THEN                                            DSInj  499
          CALL MSGSIM(-1,II,II,II,II)                                           DSInj  500
          WRITE (IOUTPT,9003) (<ds:NAME>,II=1,8)                                DSInj  501
          CALL MessageBox( NULL,                                                DSInj  502
     &      'A desuperheater must be fed by at'//char(10)//char(13)//           DSInj  503
     &      'least one suction circuit'//char(0),                               DSInj  504
     &      'DESUPERHEATER Errors'//char(0),                                    DSInj  505
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                DSInj  506
          IwinReturn = 1                                                        DSInj  507
          RETURN                                                                DSInj  508
        ENDIF                                                                   DSInj  509
c              Get pointer to reference enthalpy                                DSInj  510
        <ds;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     DSInj  511
c                                                                               DSInj  512
        CALL ListNodes(<ds;Nodes>, 0,0,Jds,0, 0,0)                              DSInj  513
c                                                                               DSInj  514
c              Histories                                                        DSInj  515
      CASE (208)                                                                DSInj  516
        Jrs = <ds:/RefgSystem/>                                                 DSInj  517
        Jsg = <ds:/SuctionGroup>                                                DSInj  518
c              desuperheated inlet pressure                                     DSInj  519
        Kri = <ds;DesupInNode>                                                  DSInj  520
        <ds;DesupInHsty> = NewHistory(Jrs,-Jsg,Jds, <ri;Xnode>, Kri,            DSInj  521
     &                       0, 0, 1.,                                          DSInj  522
     &                       <#ri.Pinlet>, <sp:ERROR-P>, 1,                     DSInj  523
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)            DSInj  524
c              desuperheated outlet enthalpy                                    DSInj  525
        Kro = <ds;DesupOutNode>                                                 DSInj  526
        <ds;DesupOutHsty> = NewHistory(Jrs,-Jsg,Jds, <ro;Xnode>, Kro,           DSInj  527
     &                        0, 7, 1.25,                                       DSInj  528
     &                        <#ro.Qoutlet>, <sp:ERROR-LOAD>, 2,                DSInj  529
     &                        <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                DSInj  530
     &                        <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                DSInj  531
     &                        0,0.,0, 0,0.,0, 0,0.,0)                           DSInj  532
c              injected history                                                 DSInj  533
        Kli = 0                                                                 DSInj  534
        Kri = <ds;SupplyInNode>                                                 DSInj  535
        Kro = <ds;SupplyOutNode>                                                DSInj  536
        CALL ListAdd(Kli, <ri;Xnode>)                                           DSInj  537
        CALL ListAdd(Kli, <ro;Xnode>)                                           DSInj  538
        <ds;SupplyHsty> = NewHistory(Jrs,-Jsg,Jds, Kli, Kro,                    DSInj  539
     &                      5, 3, 1.,                                           DSInj  540
     &                      <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                  DSInj  541
     &                      <#ro.Houtlet>, <sp:ERROR-H>   , 1,                  DSInj  542
     &                      <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                  DSInj  543
     &                      <#ro.Preqd>  , <sp:ERROR-P>   , 1,                  DSInj  544
     &                      0,0.,0, 0,0.,0)                                     DSInj  545
c                                                                               DSInj  546
c              History lists                                                    DSInj  547
      CASE (209)                                                                DSInj  548
c              All histories associated with this component                     DSInj  549
        CALL ListHstys(<ds;Hstys>, 0, 0, Jds)                                   DSInj  550
c                                                                               DSInj  551
c              Dump pointers                                                    DSInj  552
      CASE (210)                                                                DSInj  553
        IF (<ds;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         DSInj  554
        WRITE (IOUTPT, 9202)  (<ds:NAME>,II=1,8),                               DSInj  555
     &    Jds, <ds:DESUPER-CKT>, <ds;DesupInNode>, <ds;DesupOutNode>,           DSInj  556
     &    <ds;SupplyInNode>, <ds;SupplyOutNode>                                 DSInj  557
c                                                                               DSInj  558
c                                                                               DSInj  559
      END SELECT  ! Mode                                                        DSInj  560
c                                                                               DSInj  561
c                                                                               DSInj  562
      RETURN                                                                    DSInj  563
c                                                                               DSInj  564
c              Message formats                                                  DSInj  565
 9001 FORMAT(14x,'Desuperheater: ',8A4,' has a mass'                   /        DSInj  566
     &       14x,'capacity smaller than the design flow.'              /        DSInj  567
     &       14x,'Flow: ',F10.1,'  Capacity: ',F10.1                   )        DSInj  568
 9002 FORMAT(14x,'Desuperheater: ',8A4,' has a liquid'                 /        DSInj  569
     &       14x,'capacity smaller than required.'                     /        DSInj  570
     &       14x,'Capacity: ',F10.0,'  Required Capacity: ',F10.0      )        DSInj  571
 9003 FORMAT(                                                                   DSInj  572
     &14x,'Desuperheater: ',8A4,' has no attached suction'             /        DSInj  573
     &14x,'circuits. At least one circuit must be attached to the'     /        DSInj  574
     &14x,'desuperheater inlet, or the desuperheater must be removed.' )        DSInj  575
 9201 FORMAT(/' DESUPERHEATERs                         Jds       Jrc',          DSInj  576
     &'       Kri       Kro   Sup Kri   Sup Kro'                       /        DSInj  577
     &1x,32('-'),6('  --------'))                                               DSInj  578
 9202 FORMAT(1x,8A4,6I10)                                                       DSInj  579
      END                                                                       DSInj  580
      SUBROUTINE Desuperheater_RefgCooled(Mode, Jds)                            DSRfgC   2
c                                                                               DSRfgC   3
c              Simulates a desuperheater using a refrigerant-cooled             DSRfgC   4
c              heat exchanger.                                                  DSRfgC   5
c                                                                               DSRfgC   6
c              A desuperheater is always located at the outlet end of a         DSRfgC   7
c              suction refrigerant circuit.                                     DSRfgC   8
c                                                                               DSRfgC   9
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               DSRfgC  17
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               DSRfgC  19
C ??       NOT DEBUGGED                                                         DSRfgC  20
C                                                                               DSRfgC  21
      INTEGER  Xri, Xro, rH                                                     DSRfgC  22
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             DSRfgC  23
      REAL     Mdesuper, Msupply, MreqdSupply, NTU                              DSRfgC  24
c                                                                               DSRfgC  25
c                                                                               DSRfgC  26
      SELECT CASE (Mode)                                                        DSRfgC  27
c                                                                               DSRfgC  28
c                                                                               DSRfgC  29
c ============ HOURLY SIMULATION - LOADS TO SUCTION-GROUP ===================== DSRfgC  30
      CASE (31)                                                                 DSRfgC  31
c                                                                               DSRfgC  32
c              This call calculates the outlet mass flow rate,                  DSRfgC  33
c              temperature, required pressure, and enthalpy as a                DSRfgC  34
c              function of the inlet conditions                                 DSRfgC  35
                                                                                DSRfgC  36
c******** Note: RunFrac not debugged ?? ***************                         DSRfgC  37
c                                                                               DSRfgC  38
c              Check if iteration required                                      DSRfgC  39
      IterNode = IterReqdNode(1, <ds;Nodes>)                                    DSRfgC  40
      IF (.NOT. IterNode  .AND.                                                 DSRfgC  41
     &    .NOT. IterReqdHsty(<ds;Hstys>))  RETURN                               DSRfgC  42
c                                                                               DSRfgC  43
c              Desuperheated side of HX                                         DSRfgC  44
      Kri = <ds;DesupInNode>                                                    DSRfgC  45
      Kro = <ds;DesupOutNode>                                                   DSRfgC  46
      Xro = <ro;Xnode>                                                          DSRfgC  47
      Jre = <ds;Refrigerant>                                                    DSRfgC  48
c                                                                               DSRfgC  49
c              Get the loads on this circuit.  Note that the pressure           DSRfgC  50
c              is the required pressure that will be passed downstream,         DSRfgC  51
c              not the actual inlet pressure                                    DSRfgC  52
      CALL RefgNode(Kri, <ri.Minlet>,<ri.Mreqd>, <ri.Hinlet>, xTreqd,           DSRfgC  53
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     DSRfgC  54
c                                                                               DSRfgC  55
      RunFrac = <ri.RunFrac>                                                    DSRfgC  56
c                                                                               DSRfgC  57
c              skip if no mass flow                                             DSRfgC  58
      IF (<ri.Minlet> .EQ. 0.)  THEN                                            DSRfgC  59
        <ds;Qdesuper> = 0.                                                      DSRfgC  60
        Kri           = <ds;SupplyInNode>                                       DSRfgC  61
        Xri           = <ri;Xnode>                                              DSRfgC  62
        Kro           = <ds;SupplyOutNode>                                      DSRfgC  63
        Xro           = <ro;Xnode>                                              DSRfgC  64
        <ri.Mreqd>    = 0.                                                      DSRfgC  65
        Msupply       = 0.                                                      DSRfgC  66
        MreqdSupply   = 0.                                                      DSRfgC  67
        GOTO 3190                                                               DSRfgC  68
      ENDIF                                                                     DSRfgC  69
                                                                                DSRfgC  70
c              Condenser is operating. If cycling, convert hourly               DSRfgC  71
c              average refrigerant flow to flow when cycled on                  DSRfgC  72
      Mdesuper = <ri.Minlet> / RunFrac                                          DSRfgC  73
                                                                                DSRfgC  74
c                                                                               DSRfgC  75
c              Superheated refrigerant conditions at inlet to HX                DSRfgC  76
      TdesuperIn  = RefgT_fPH(Jre, <ri.Pinlet>,<ri.Hinlet>)                     DSRfgC  77
      <ri.Tinlet> = TdesuperIn                                                  DSRfgC  78
      SST         = RefgT_fP(Jre, <Xro.Poutlet>)                                DSRfgC  79
      <ds;Tsetpt> = MIN(TdesuperIn, SST + <ds:SUPERHEAT-SET>)                   DSRfgC  80
      Cp          = RefgCp_Vapor_fP(Jre, <Xro.Poutlet>)                         DSRfgC  81
c                                                                               DSRfgC  82
c              Heat exchanger efficacy                                          DSRfgC  83
c              calculate the UA from the film resistances                       DSRfgC  84
      Rdesuper = <ds;DesuperFilmR>                                              DSRfgC  85
     &         * (Mdesuper*<ds;1/Mdesuper>)**<ds;DesuperFilmE>                  DSRfgC  86
      <ds;UA>  = 1. / (Rdesuper + <ds;HtExchR> + <ds;SupplyFilmR>)              DSRfgC  87
      Cmin     = Mdesuper * Cp                                                  DSRfgC  88
      NTU      = <ds;UA> / Cmin                                                 DSRfgC  89
      eff      = 1.0 - EXP(-NTU)                                                DSRfgC  90
c                                                                               DSRfgC  91
c                                                                               DSRfgC  92
c              Now supply side of heat exchanger                                DSRfgC  93
      Kri = <ds;SupplyInNode>                                                   DSRfgC  94
      Xri = <ri;Xnode>                                                          DSRfgC  95
      Kro = <ds;SupplyOutNode>                                                  DSRfgC  96
      Xro = <ro;Xnode>                                                          DSRfgC  97
      Jre = <ds;SupplyRefg>                                                     DSRfgC  98
c                                                                               DSRfgC  99
c              saturated-suction temperature, supply-side outlet                DSRfgC 100
      SST = RefgT_fP(Jre, <Xro.Poutlet>)                                        DSRfgC 101
c                                                                               DSRfgC 102
c              Heat transferred and leaving temperature, desuperheat            DSRfgC 103
c              side of HX                                                       DSRfgC 104
      IF (<ds;Tsetpt> .LT. TdesuperIn)  THEN                                    DSRfgC 105
        <ds;Qdesuper> = eff * Cmin * (TdesuperIn-SST)                           DSRfgC 106
        TdesuperOut   = MAX(<ds;Tsetpt>, TdesuperIn-<ds;Qdesuper>/Cmin)         DSRfgC 107
        <ds;Qdesuper> = Cmin * (TdesuperIn - TdesuperOut)                       DSRfgC 108
      ELSE                                                                      DSRfgC 109
        TdesuperOut   = TdesuperIn                                              DSRfgC 110
        <ds;Qdesuper> = 0.                                                      DSRfgC 111
      ENDIF                                                                     DSRfgC 112
c                                                                               DSRfgC 113
c              Outlet enthalpy and mass flow rate, supply-side of HX            DSRfgC 114
      <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SST, <ds:SUPERHEAT-DT>)               DSRfgC 115
      dH           = (<ro.Houtlet> - <Xri.Hinlet>)                              DSRfgC 116
      Msupply      = <ds;Qdesuper> / dH                                         DSRfgC 117
      MreqdSupply  = Msupply                                                    DSRfgC 118
c                                                                               DSRfgC 119
      IF (Msupply .GT. 0.)  THEN                                                DSRfgC 120
c              Required suction pressure                                        DSRfgC 121
        QhxReqd    = Cmin * (TdesuperIn - <ds;Tsetpt>)                          DSRfgC 122
        SSTreqd    = TdesuperIn - QhxReqd/(eff * Cmin)                          DSRfgC 123
        <ro.Preqd> = RefgP_fT(Jre, SSTreqd)                                     DSRfgC 124
c                                                                               DSRfgC 125
c              Required liquid pressure and temperature                         DSRfgC 126
        dP         = <ds:LIQUID-DP> * ((Msupply*<ds;1/Msupply>)**1.87)          DSRfgC 127
c ?? Xro,Poutlet is not correct? - should be SST adjusted for ctrl valve        DSRfgC 128
        <ri.Preqd> = MIN(<re;Pmax>, <Xro.Poutlet> + dP)                         DSRfgC 129
        <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                DSRfgC 130
c              adjust mass flow if pressure insufficient                        DSRfgC 131
        IF (<ri.Preqd> .GT. <Xri.Pinlet>)  THEN                                 DSRfgC 132
          dPmax  = <Xri.Pinlet> - <Xro.Poutlet>                                 DSRfgC 133
          IF (dPmax .GT. 0.)  THEN                                              DSRfgC 134
            Msupply = EXP(LOG(dPmax/<ds:LIQUID-DP>)/1.87                        DSRfgC 135
     &                                           - LOG(<ds;1/Msupply>))         DSRfgC 136
          ELSE                                                                  DSRfgC 137
            Msupply = 0.                                                        DSRfgC 138
          ENDIF                                                                 DSRfgC 139
          <ds;Qdesuper> = Msupply * dH                                          DSRfgC 140
          TdesuperOut   = TdesuperIn - <ds;Qdesuper>/Cmin                       DSRfgC 141
        ENDIF                                                                   DSRfgC 142
      ENDIF  ! Msupply .gt. 0                                                   DSRfgC 143
c                                                                               DSRfgC 144
 3190 <ds;Qdesuper> = <ds;Qdesuper> * RunFrac                                   DSRfgC 145
      <ro.RunFrac>  = RunFrac                                                   DSRfgC 146
      <ro.Mreqd>    = <ro.Mreqd>    * RunFrac                                   DSRfgC 147
      <ro.Moutlet>  = Msupply       * RunFrac                                   DSRfgC 148
c              check for convergence on supply gas                              DSRfgC 149
      CALL CnvgCheck(1, <ds;SupplyHsty>)                                        DSRfgC 150
      <ri.Minlet>  = <ro.Moutlet>                                               DSRfgC 151
      <ri.Mreqd>   = <ro.Mreqd>                                                 DSRfgC 152
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<ds;SuRefgHrefPtr>))        DSRfgC 153
      <ro.Qoutlet> = <ri.Qinlet> + <ds;Qdesuper>                                DSRfgC 154
c                                                                               DSRfgC 155
c              Desuperheated gas                                                DSRfgC 156
      Kri = <ds;DesupInNode>                                                    DSRfgC 157
      Kro = <ds;DesupOutNode>                                                   DSRfgC 158
      Xro = <ro;Xnode>                                                          DSRfgC 159
      Jre = <ds;Refrigerant>                                                    DSRfgC 160
      <ro.RunFrac> = RunFrac                                                    DSRfgC 161
      <ro.Moutlet> = <ri.Minlet>                                                DSRfgC 162
      IF (<ro.Moutlet> .GT. 0.)  THEN                                           DSRfgC 163
        <ro.Toutlet> = TdesuperOut                                              DSRfgC 164
        <ro.Houtlet> = <ri.Hinlet> - <ds;Qdesuper> / <ro.Moutlet>               DSRfgC 165
      ENDIF                                                                     DSRfgC 166
c              Pass along the required pressure of the upstream loads           DSRfgC 167
      IF (<ri.Mreqd> .EQ. 0.)  THEN                                             DSRfgC 168
        <ro.Mreqd> = 0.                                                         DSRfgC 169
      ELSE                                                                      DSRfgC 170
        <ro.Mreqd> = <ri.Mreqd> + MreqdSupply*RunFrac                           DSRfgC 171
      ENDIF                                                                     DSRfgC 172
      IF (<ro.Mreqd> .GT. 0.  .AND.  <ri.Preqd> .GT. -888.)  THEN               DSRfgC 173
        Voutlet = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                   DSRfgC 174
        dP      = <ds:DESUPER-DP>                                               DSRfgC 175
     &          * (<ro.Mreqd>/RunFrac*<ds;1/Mdesuper>)**1.87                    DSRfgC 176
     &          * (Voutlet*<ds;DesuperOutD>)**1.6                               DSRfgC 177
        <ro.Preqd> = MAX(<re;Pmin>, <ri.Preqd>-dP)                              DSRfgC 178
      ELSE                                                                      DSRfgC 179
        <ro.Preqd> = -88888.                                                    DSRfgC 180
      ENDIF                                                                     DSRfgC 181
c              check for convergence on desuperheated gas                       DSRfgC 182
      CALL CnvgCheck(1, <ds;DesupOutHsty>)                                      DSRfgC 183
      <ri.Qinlet>  = <ri.Minlet> * (<ri.Hinlet>-AA(<ds;RefgHrefPtr>))           DSRfgC 184
      <ro.Qoutlet> = <ri.Qinlet> - <ds;Qdesuper>                                DSRfgC 185
c                                                                               DSRfgC 186
c                                                                               DSRfgC 187
c              Auxiliary power                                                  DSRfgC 188
      IF (<ds:AUX-KW> .GT. 0.)  THEN                                            DSRfgC 189
        SELECT CASE (<ds:AUX-MODE>)                                             DSRfgC 190
          CASE (1)  ! Always                                                    DSRfgC 191
            AuxKW = <ds:AUX-KW>                                                 DSRfgC 192
          CASE (2)  ! When on                                                   DSRfgC 193
            IF (Msupply .GT. 0.)  THEN                                          DSRfgC 194
              AuxKW = <ds:AUX-KW> * RunFrac                                     DSRfgC 195
            ELSE                                                                DSRfgC 196
              AuxKW = 0.                                                        DSRfgC 197
            ENDIF                                                               DSRfgC 198
          CASE (3)  ! When off                                                  DSRfgC 199
            IF (Msupply .EQ. 0.)  THEN                                          DSRfgC 200
              AuxKW = <ds:AUX-KW> * (1.-RunFrac)                                DSRfgC 201
            ELSE                                                                DSRfgC 202
              AuxKW = 0.                                                        DSRfgC 203
            ENDIF                                                               DSRfgC 204
          CASE (4)  ! Scheduled                                                 DSRfgC 205
            AuxKW = <ds:AUX-KW> * SchVal(<ds:AUX-SCH>)                          DSRfgC 206
        END SELECT                                                              DSRfgC 207
        Kmd = <ds:AUX-METER>                                                    DSRfgC 208
        Kmx = <md;Xnode>                                                        DSRfgC 209
        IF (AuxKW .GT. 0.)  THEN                                                DSRfgC 210
          IF (ABS(1. - <md.Elec>/AuxKW) .GT. <sp:ERROR-LOAD>)                   DSRfgC 211
     &      <mx.IterFlag> = Jds                                                 DSRfgC 212
        ELSE                                                                    DSRfgC 213
          IF (<md.Elec> .GT. 0.)  <mx.IterFlag> = Jds                           DSRfgC 214
        ENDIF                                                                   DSRfgC 215
        <md.Elec> = AuxKW                                                       DSRfgC 216
      ENDIF                                                                     DSRfgC 217
c                                                                               DSRfgC 218
c                                                                               DSRfgC 219
c ============ HOURLY SIMULATION - SUCTION-GROUP TO LOADS ===================== DSRfgC 220
      CASE (32)                                                                 DSRfgC 221
c                                                                               DSRfgC 222
c              Check if iteration required                                      DSRfgC 223
      IterNode = IterReqdNode(1, <ds;Nodes>)                                    DSRfgC 224
      IF (.NOT. IterNode  .AND.                                                 DSRfgC 225
     &    .NOT. IterReqdHsty(<ds;Hstys>))  RETURN                               DSRfgC 226
c                                                                               DSRfgC 227
c              Desuperheated side of HX                                         DSRfgC 228
      Kri = <ds;DesupInNode>                                                    DSRfgC 229
      Kro = <ds;DesupOutNode>                                                   DSRfgC 230
      Xro = <ro;Xnode>                                                          DSRfgC 231
      Jre = <ds;Refrigerant>                                                    DSRfgC 232
c                                                                               DSRfgC 233
c              Pressure at outlet                                               DSRfgC 234
      <ri.Pinlet> = <Xro.Poutlet>                                               DSRfgC 235
      IF (<ro.Moutlet> .gt. 0.) THEN                                            DSRfgC 236
        Voutlet = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)                   DSRfgC 237
        dP = <ds:DESUPER-DP>                                                    DSRfgC 238
     &     * (<ro.Moutlet>/<ro.RunFrac>*<ds;1/Mdesuper>)**1.87                  DSRfgC 239
     &     * (Voutlet*<ds;DesuperOutD>)**1.6                                    DSRfgC 240
        <ri.Pinlet> = <ri.Pinlet> + dP                                          DSRfgC 241
      ENDIF                                                                     DSRfgC 242
c                                                                               DSRfgC 243
c              Check for convergence on inlet pressure                          DSRfgC 244
      CALL CnvgCheck(1, <ds;DesupInHsty>)                                       DSRfgC 245
c                                                                               DSRfgC 246
c                                                                               DSRfgC 247
c ============ REPORT CREATION ================================================ DSRfgC 248
      CASE (50)                                                                 DSRfgC 249
c                                                                               DSRfgC 250
c              statistics blocks                                                DSRfgC 251
      Kro          = <ds;SupplyOutNode>                                         DSRfgC 252
      Ks2Load      = NewStat2(Jds, <+ds;Qdesuper>, 0, 1.)                       DSRfgC 253
      Ks5LoadBin   = NewStat5(Jds, <+ds;Qdesuper>, 0, 1.)                       DSRfgC 254
      Ks2Msuct     = NewStat2(<ds;SupplyOutNode>, <+ro.Moutlet>, 0, 1.)         DSRfgC 255
      Ks5MsuctBin  = NewStat5(<ds;SupplyOutNode>, <+ro.Moutlet>, 0, 1.)         DSRfgC 256
      Ks2Mdesuper  = NewStat2(<ds;DesupOutNode>,  <+ro.Moutlet>, 0, 1.)         DSRfgC 257
      Ks5MdesupBin = NewStat5(<ds;DesupOutNode>,  <+ro.Moutlet>, 0, 1.)         DSRfgC 258
      Ks2Aux       = NewStat2(<ds:AUX-METER>,        <+md.Elec>, 0, 1.)         DSRfgC 259
c                                                                               DSRfgC 260
c              Create the type "H" report                                       DSRfgC 261
      IF (<ds:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      DSRfgC 262
     &  <ds;PS-H> = NewReport_H(Jds, 138,                                       DSRfgC 263
     &                          4, 5, 6,                                        DSRfgC 264
     &                          Ks2Load, Ks2Mdesuper, Ks2Msuct,Ks2Aux,          DSRfgC 265
     &                          Ks5LoadBin, Ks5MdesupBin, Ks5MsuctBin,          DSRfgC 266
     &                          0, 0, 0)                                        DSRfgC 267
c                                                                               DSRfgC 268
c                                                                               DSRfgC 269
c ============ REPORT ORDER =================================================== DSRfgC 270
      CASE (52)                                                                 DSRfgC 271
c                                                                               DSRfgC 272
      Call Report_H(Mode, <ds;PS-H>)                                            DSRfgC 273
c                                                                               DSRfgC 274
c                                                                               DSRfgC 275
c ============ REPORTS - VERIFICATION DATA ==================================== DSRfgC 276
      CASE (54)                                                                 DSRfgC 277
c                                                                               DSRfgC 278
c              Output design information                                        DSRfgC 279
      IF (<ds;PS-H> .ne. 0)  THEN                                               DSRfgC 280
        rH = <ds;PS-H>                                                          DSRfgC 281
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       DSRfgC 282
        CALL GetAttachments(Jds, 2)                                             DSRfgC 283
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   DSRfgC 284
     &    (NameAttachments(II,1,1),II=1,8),                                     DSRfgC 285
     &    (NameAttachments(II,1,2),II=1,8),                                     DSRfgC 286
     &    <ds;Capacity>,<ds;Mdesuper>,<ds;Msupply>,<ds:SUPERHEAT-SET>,          DSRfgC 287
     &    <ds;DesignUA>                                                         DSRfgC 288
        DO  Irow=2,NumRowsOfAttachments                                         DSRfgC 289
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 DSRfgC 290
     &      (NameAttachments(II,Irow,1),II=1,8),                                DSRfgC 291
     &      (NameAttachments(II,Irow,2),II=1,8)                                 DSRfgC 292
        ENDDO                                                                   DSRfgC 293
      ENDIF                                                                     DSRfgC 294
c                                                                               DSRfgC 295
c                                                                               DSRfgC 296
c ============ HOURLY REPORTS - HOURLY DATA =================================== DSRfgC 297
      CASE (62)                                                                 DSRfgC 298
c                                                                               DSRfgC 299
c              Hourly-report variables                                          DSRfgC 300
      IF (<ds;HourRepBuf> .EQ. 0)  RETURN                                       DSRfgC 301
c                                                                               DSRfgC 302
      IAptr        = <ds;HourRepBuf> - 1                                        DSRfgC 303
      AA(IAptr+1)  = <ds;Qdesuper>                                              DSRfgC 304
c              desuperheated inlet                                              DSRfgC 305
      Kri          = <ds;DesupInNode>                                           DSRfgC 306
      AA(IAptr+2)  = <ri.Qinlet>                                                DSRfgC 307
      AA(IAptr+3)  = <ri.Minlet>                                                DSRfgC 308
      AA(IAptr+4)  = RefgT_fPH(Jre, <ri.Pinlet>,<ri.Hinlet>)                    DSRfgC 309
      AA(IAptr+5)  = <ri.Pinlet>                                                DSRfgC 310
      AA(IAptr+6)  = <ri.Preqd>                                                 DSRfgC 311
      AA(IAptr+7)  = <ri.Hinlet>                                                DSRfgC 312
c              desuperheated outlet                                             DSRfgC 313
      Kro          = <ds;DesupOutNode>                                          DSRfgC 314
      Xro          = <ro;Xnode>                                                 DSRfgC 315
      AA(IAptr+8)  = <ro.Qoutlet>                                               DSRfgC 316
      AA(IAptr+9)  = <ro.Moutlet>                                               DSRfgC 317
c     AA(IAptr+10) = unused                                                     DSRfgC 318
      AA(IAptr+11) = <ro.Toutlet>                                               DSRfgC 319
c     AA(IAptr+12) = unused                                                     DSRfgC 320
      AA(IAptr+13) = <Xro.Poutlet>                                              DSRfgC 321
      AA(IAptr+14) = <ro.Preqd>                                                 DSRfgC 322
      AA(IAptr+15) = <ro.Houtlet>                                               DSRfgC 323
c              liquid supply inlet                                              DSRfgC 324
      Kri          = <ds;SupplyInNode>                                          DSRfgC 325
      Xri          = <ri;Xnode>                                                 DSRfgC 326
      AA(IAptr+16) = <ri.Qinlet>                                                DSRfgC 327
      AA(IAptr+17) = <ri.Minlet>                                                DSRfgC 328
      AA(IAptr+18) = <Xri.Pinlet>                                               DSRfgC 329
      AA(IAptr+19) = <ri.Preqd>                                                 DSRfgC 330
      AA(IAptr+20) = <Xri.Hinlet>                                               DSRfgC 331
c              suction supply outlet                                            DSRfgC 332
      Kro          = <ds;SupplyOutNode>                                         DSRfgC 333
      Xro          = <ro;Xnode>                                                 DSRfgC 334
      AA(IAptr+21) = <ro.Qoutlet>                                               DSRfgC 335
      AA(IAptr+22) = <ro.Moutlet>                                               DSRfgC 336
      AA(IAptr+23) = <Xro.Poutlet>                                              DSRfgC 337
      AA(IAptr+24) = <ro.Preqd>                                                 DSRfgC 338
      AA(IAptr+25) = <ro.Houtlet>                                               DSRfgC 339
c                                                                               DSRfgC 340
      AA(IAptr+26) = <ds;Tsetpt>                                                DSRfgC 341
      AA(IAptr+27) = <ds;UA>                                                    DSRfgC 342
c                                                                               DSRfgC 343
c                                                                               DSRfgC 344
c ============ DESIGN CALCULATIONS - LOADS TO SUCTION-GROUP =================== DSRfgC 345
      CASE (111)                                                                DSRfgC 346
c                                                                               DSRfgC 347
c              This call calculates the design outlet mass flow rate,           DSRfgC 348
c              temperature, required pressure, and enthalpy as a                DSRfgC 349
c              function of the inlet conditions                                 DSRfgC 350
c                                                                               DSRfgC 351
c              Desuperheated side of HX                                         DSRfgC 352
      Kri = <ds;DesupInNode>                                                    DSRfgC 353
      Kro = <ds;DesupOutNode>                                                   DSRfgC 354
      Xro = <ro;Xnode>                                                          DSRfgC 355
      Jre = <ds;Refrigerant>                                                    DSRfgC 356
c                                                                               DSRfgC 357
c              Set iteration flag on outlet                                     DSRfgC 358
      <Xro.IterFlag> = Jds                                                      DSRfgC 359
c                                                                               DSRfgC 360
c              Design quantities from suppliers (at inlet)                      DSRfgC 361
      CALL RefgNode(Kri, <ri.Minlet>,xMreqd, <ri.Hinlet>, xTreqd,               DSRfgC 362
     &                   xPmin,xPmax, <ri.Preqd>,xPmaxReqd)                     DSRfgC 363
c                                                                               DSRfgC 364
c              Design flow                                                      DSRfgC 365
      IF (<ds:DESUPER-FLOW> .GT. 0.)  THEN                                      DSRfgC 366
        <ds;Mdesuper> = <ds:DESUPER-FLOW>                                       DSRfgC 367
      ELSE                                                                      DSRfgC 368
        <ds;Mdesuper> = <ri.Minlet>                                             DSRfgC 369
      ENDIF                                                                     DSRfgC 370
      <ro.Moutlet> = <ri.Minlet>                                                DSRfgC 371
      <ro.Mreqd>   = <ri.Minlet>                                                DSRfgC 372
c                                                                               DSRfgC 373
c              Adjust for pressure loss thru HX                                 DSRfgC 374
      IF (<ds:DESUPER-FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN          DSRfgC 375
        dP = <ds:DESUPER-DP> * (<ri.Minlet>/<ds:DESUPER-FLOW>)**1.87            DSRfgC 376
      ELSE                                                                      DSRfgC 377
        dP = <ds:DESUPER-DP>                                                    DSRfgC 378
      ENDIF                                                                     DSRfgC 379
      <ro.Preqd> = <ri.Preqd> - dP                                              DSRfgC 380
c                                                                               DSRfgC 381
c              Skip if outlet pressure not yet known (first pass)               DSRfgC 382
      IF (<Xro.Poutlet> .EQ. 0.)  RETURN                                        DSRfgC 383
c                                                                               DSRfgC 384
c              Adjust outlet enthalpy for desuperheating effect                 DSRfgC 385
      <ri.Tinlet>  = RefgT_fPH(Jre, <Xro.Poutlet>,<ri.Hinlet>)                  DSRfgC 386
      dTsuper      = RefgSuper_fPH(Jre, <Xro.Poutlet>,<ri.Hinlet>)              DSRfgC 387
      dT           = MAX(0., dTsuper - <ds:SUPERHEAT-SET>)                      DSRfgC 388
      <ro.Toutlet> = TdesuperIn - dT                                            DSRfgC 389
      dQ           = RefgCp_Vapor_fP(Jre, <Xro.Poutlet>) * dT                   DSRfgC 390
      <ro.Houtlet> = <ri.Hinlet> - dQ                                           DSRfgC 391
c                                                                               DSRfgC 392
c              Capacity                                                         DSRfgC 393
      IF (<ds:CAPACITY> .NE. 0.)  THEN                                          DSRfgC 394
        <ds;Capacity> = <ds:CAPACITY>                                           DSRfgC 395
      ELSE                                                                      DSRfgC 396
        <ds;Capacity> = <ri.Minlet> * dQ                                        DSRfgC 397
      ENDIF                                                                     DSRfgC 398
c                                                                               DSRfgC 399
c                                                                               DSRfgC 400
c              Now supply side of heat exchanger                                DSRfgC 401
      Kri = <ds;SupplyInNode>                                                   DSRfgC 402
      Xri = <ri;Xnode>                                                          DSRfgC 403
      Kro = <ds;SupplyOutNode>                                                  DSRfgC 404
      Xro = <ro;Xnode>                                                          DSRfgC 405
      Jre = <ds;SupplyRefg>                                                     DSRfgC 406
c                                                                               DSRfgC 407
c              Required SST and inlet temperature diffferential                 DSRfgC 408
      SST = <ds:SUPERHEAT-SET> - <ds:SST-DESUPER-T>                             DSRfgC 409
      <ds;InletsDT> = MAX(0., TdesuperIn-SST)                                   DSRfgC 410
c                                                                               DSRfgC 411
c              Refrigerant conditions at outlet to suction                      DSRfgC 412
      SSTreqd      = TdesuperIn - <ds;InletsDT>                                 DSRfgC 413
      <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SSTreqd, <ds:SUPERHEAT-DT>)           DSRfgC 414
      <ro.Moutlet> = <ds;Capacity> / (<ro.Houtlet> - <Xri.Hinlet>)              DSRfgC 415
      <ro.Mreqd>   = <ro.Moutlet>                                               DSRfgC 416
      <ri.Minlet>  = <ro.Moutlet>                                               DSRfgC 417
      <ri.Mreqd>   = <ro.Moutlet>                                               DSRfgC 418
      <ro.Preqd>   = RefgP_fT(Jre, SSTreqd)                                     DSRfgC 419
c                                                                               DSRfgC 420
c              Check for convergence on outlet conditions                       DSRfgC 421
      CALL CnvgCheck(1, <ds;SupplyHsty>)                                        DSRfgC 422
c                                                                               DSRfgC 423
c              Refrigerant conditions at inlet from liquid                      DSRfgC 424
      IF (<ds:LIQUID-FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN           DSRfgC 425
        dP = <ds:LIQUID-DP> * (<ri.Minlet>/<ds:LIQUID-FLOW>)**1.87              DSRfgC 426
      ELSE                                                                      DSRfgC 427
        dP = <ds:LIQUID-DP>                                                     DSRfgC 428
      ENDIF                                                                     DSRfgC 429
      <ri.Preqd> = <ro.Preqd> + dP                                              DSRfgC 430
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  DSRfgC 431
c                                                                               DSRfgC 432
      IF (<ds:LIQUID-FLOW> .GT. 0.)  THEN                                       DSRfgC 433
        <ds;Msupply> = <ds:LIQUID-FLOW>                                         DSRfgC 434
      ELSE                                                                      DSRfgC 435
        <ds;Msupply> = <ro.Moutlet>                                             DSRfgC 436
      ENDIF                                                                     DSRfgC 437
c                                                                               DSRfgC 438
c              Auxiliary power                                                  DSRfgC 439
      IF (<ds:AUX-METER> .GT. 0.)  THEN                                         DSRfgC 440
        Kmd       = <ds:AUX-METER>                                              DSRfgC 441
        <md.Elec> = <ds:AUX-KW>                                                 DSRfgC 442
      ENDIF                                                                     DSRfgC 443
c                                                                               DSRfgC 444
c                                                                               DSRfgC 445
c ============ DESIGN CALCULATIONS - SUCTION-GROUP TO LOADS =================== DSRfgC 446
      CASE (112)                                                                DSRfgC 447
c                                                                               DSRfgC 448
c              Desuperheated side of HX                                         DSRfgC 449
      Kri = <ds;DesupInNode>                                                    DSRfgC 450
      Kro = <ds;DesupOutNode>                                                   DSRfgC 451
      Xro = <ro;Xnode>                                                          DSRfgC 452
      Jre = <ds;Refrigerant>                                                    DSRfgC 453
c                                                                               DSRfgC 454
c              Adjust for pressure loss thru HX                                 DSRfgC 455
      IF (<ds:DESUPER-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)  THEN         DSRfgC 456
        dP = <ds:DESUPER-DP> * (<ro.Moutlet>/<ds:DESUPER-FLOW>)**1.87           DSRfgC 457
      ELSE                                                                      DSRfgC 458
        dP = <ds:DESUPER-DP>                                                    DSRfgC 459
      ENDIF                                                                     DSRfgC 460
      <ri.Pinlet> = <Xro.Poutlet> + dP                                          DSRfgC 461
c                                                                               DSRfgC 462
c                                                                               DSRfgC 463
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== DSRfgC 464
      CASE (119)                                                                DSRfgC 465
c                                                                               DSRfgC 466
      IF (<ds;Mdesuper> .GT. 0.)  <ds;1/Mdesuper> = 1.0 / <ds;Mdesuper>         DSRfgC 467
      IF (<ds;Msupply>  .GT. 0.)  <ds;1/Msupply>  = 1.0 / <ds;Msupply>          DSRfgC 468
c                                                                               DSRfgC 469
c              Desuperheated side of HX                                         DSRfgC 470
      Kri = <ds;DesupInNode>                                                    DSRfgC 471
      Kro = <ds;DesupOutNode>                                                   DSRfgC 472
      Xro = <ro;Xnode>                                                          DSRfgC 473
      Jre = <ds;Refrigerant>                                                    DSRfgC 474
c              warn if insufficient mass flow capacity                          DSRfgC 475
      IF (<ro.Moutlet> .GT. <ds;Mdesuper>*1.01)  THEN                           DSRfgC 476
        CALL MSGSIM(-2,II,II,II,II)                                             DSRfgC 477
        WRITE (IOUTPT, 9001)  (<ds:NAME>,II=1,8),                               DSRfgC 478
     &                         <ro.Moutlet>, <ds;Mdesuper>                      DSRfgC 479
      ENDIF                                                                     DSRfgC 480
      Mdesuper  = <ro.Moutlet>                                                  DSRfgC 481
      dT        = <ri.Tinlet> - <ro.Toutlet>                                    DSRfgC 482
      CpDesuper = <ds;Capacity> / (Mdesuper * dT)                               DSRfgC 483
c                                                                               DSRfgC 484
c              warn if insufficient thermal capacity                            DSRfgC 485
      Qhx = <ro.Moutlet> * (<ri.Hinlet>-<ro.Houtlet>)                           DSRfgC 486
      IF (Qhx .GT. <ds;Capacity>*1.01)  THEN                                    DSRfgC 487
        CALL MSGSIM(-2,II,II,II,II)                                             DSRfgC 488
        WRITE (IOUTPT, 9002)  (<ds:NAME>,II=1,8),                               DSRfgC 489
     &                         Qhx, <ds;Capacity>                               DSRfgC 490
      ENDIF                                                                     DSRfgC 491
c                                                                               DSRfgC 492
c              Design volume and density at outlet                              DSRfgC 493
      <ds;DesuperOutV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)            DSRfgC 494
      <ds;DesuperOutD> = 1.0 / <ds;DesuperOutV>                                 DSRfgC 495
c                                                                               DSRfgC 496
c                                                                               DSRfgC 497
c              Supply side of HX                                                DSRfgC 498
      Kri = <ds;SupplyInNode>                                                   DSRfgC 499
      Xri = <ri;Xnode>                                                          DSRfgC 500
      Kro = <ds;SupplyOutNode>                                                  DSRfgC 501
      Xro = <ro;Xnode>                                                          DSRfgC 502
      Jre = <ds;SupplyRefg>                                                     DSRfgC 503
c                                                                               DSRfgC 504
c              Design the heat exchanger                                        DSRfgC 505
      IF (<ds:HX-UA>  .NE. 0.)  THEN                                            DSRfgC 506
        <ds;DesignUA> = <ds:HX-UA>                                              DSRfgC 507
      ELSE                                                                      DSRfgC 508
c              check if inlet temperature differential reasonable               DSRfgC 509
        IF (<ds;InletsDT> .LT. 10.)  THEN                                       DSRfgC 510
          CALL MSGSIM(-2,II,II,II,II)                                           DSRfgC 511
          WRITE (IOUTPT,9003)  (<ds:NAME>,II=1,8), <ds;InletsDT>                DSRfgC 512
          <ds;InletsDT> = 10.                                                   DSRfgC 513
        ENDIF                                                                   DSRfgC 514
c              initialize the UA to the ideal                                   DSRfgC 515
        <ds;DesignUA> = <ds;Capacity> / <ds;InletsDT>                           DSRfgC 516
c              minimum capacity rate                                            DSRfgC 517
        Cmin = Mdesuper * CpDesuper                                             DSRfgC 518
c              iterate to solve for UA                                          DSRfgC 519
        DO  Iter=1,100                                                          DSRfgC 520
c              transfer units, effectiveness (phase change one side), and       DSRfgC 521
c              heat transfer for this size hx                                   DSRfgC 522
          NTU   = <ds;DesignUA> / Cmin                                          DSRfgC 523
          eff   = 1.0 - EXP(-NTU)                                               DSRfgC 524
          Qhx   = eff * Cmin * <ds;InletsDT>                                    DSRfgC 525
c              see if converged on UA                                           DSRfgC 526
          Error = (Qhx-<ds;Capacity>) / <ds;Capacity>                           DSRfgC 527
          IF (ABS(Error) .LT. 0.001)  EXIT                                      DSRfgC 528
c              solution not converged yet - make new estimate                   DSRfgC 529
          <ds;DesignUA> = <ds;DesignUA> * <ds;Capacity>/Qhx                     DSRfgC 530
          IF (Iter .EQ. 100)  THEN                                              DSRfgC 531
c              convergence has failed after 100 iterations                      DSRfgC 532
            CALL MSGSIM(-1,II,II,II,II)                                         DSRfgC 533
            WRITE (IOUTPT, 9004)  (<ds:NAME>,II=1,8)                            DSRfgC 534
            CALL MessageBox( NULL,                                              DSRfgC 535
     &        'Convergence failure in UA calculation'//char(0),                 DSRfgC 536
     &        'DESUPERHEATER Errors'//char(0),                                  DSRfgC 537
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              DSRfgC 538
            IwinReturn = 1                                                      DSRfgC 539
            RETURN                                                              DSRfgC 540
          ENDIF                                                                 DSRfgC 541
        ENDDO                                                                   DSRfgC 542
      ENDIF                                                                     DSRfgC 543
c                                                                               DSRfgC 544
c              Break down UA into its components                                DSRfgC 545
      Resistance = 1. / <ds;DesignUA>                                           DSRfgC 546
      <ds;DesuperFilmR> = Resistance * <ds:DESUPER-FILM>                        DSRfgC 547
      <ds;SupplyFilmR>  = Resistance * <ds:SUPPLY-FILM>                         DSRfgC 548
      <ds;HtExchR>      = Resistance                                            DSRfgC 549
     &                           - (<ds;DesuperFilmR>+<ds;SupplyFilmR>)         DSRfgC 550
c              check resistances for consistency                                DSRfgC 551
      IF (<ds;HtExchR> .LT. 0.)  THEN                                           DSRfgC 552
        CALL MSGSIM(-1,II,II,II,II)                                             DSRfgC 553
        WRITE (IOUTPT, 9005)  (<ds:NAME>,II=1,8)                                DSRfgC 554
        CALL MessageBox( NULL,                                                  DSRfgC 555
     &    'Inconsistent internal/external resistances'//char(0),                DSRfgC 556
     &    'DESUPERHEATER Errors'//char(0),                                      DSRfgC 557
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  DSRfgC 558
        IwinReturn = 1                                                          DSRfgC 559
        RETURN                                                                  DSRfgC 560
      ENDIF                                                                     DSRfgC 561
c              make film resistance coefs negative for faster                   DSRfgC 562
c              hourly computation (can multiply instead of divide)              DSRfgC 563
      <ds;DesuperFilmE> = -<ds:DESUPER-EXP>                                     DSRfgC 564
c                                                                               DSRfgC 565
      <ds;Qdesuper> = <ds;Capacity>                                             DSRfgC 566
c                                                                               DSRfgC 567
c                                                                               DSRfgC 568
c ============ ATTACHMENTS ==================================================== DSRfgC 569
c                                                                               DSRfgC 570
c              Initial attachments                                              DSRfgC 571
      CASE (201)                                                                DSRfgC 572
c              Component pointers, schedules, and curves                        DSRfgC 573
        <ds:SUCTION-CKT>   = Jcomponent(22, <ds:SUCTION-CKT>)                   DSRfgC 574
        <ds:LIQUID-CKT>    = Jcomponent(22, <ds:LIQUID-CKT>)                    DSRfgC 575
        <ds:SUCTION-GROUP> = Jcomponent(25, <ds:SUCTION-GROUP>)                 DSRfgC 576
        <ds:/SuctionGroup> = Jcomponent(25, <ds:/SuctionGroup>)                 DSRfgC 577
        <ds:/RefgSystem/>  = Jcomponent(29, <ds:/RefgSystem/>)                  DSRfgC 578
        <ds:AUX-METER>     = Jcomponent(13, <ds:AUX-METER>)                     DSRfgC 579
        <ds:COST-DATA>     = Jcomponent(18, <ds:COST-DATA>)                     DSRfgC 580
        <ds:AUX-SCH>       = Jsched(<ds:AUX-SCH>)                               DSRfgC 581
c              desuperheated attachment                                         DSRfgC 582
        SELECT CASE (<ds:ATTACH-TO>)                                            DSRfgC 583
          CASE (2)  ! Suction-group                                             DSRfgC 584
            <ds:DESUPER-CKT> = Jcomponent(25, <ds:SUCTION-GROUP>)               DSRfgC 585
          CASE (6)  ! Refg-circuit                                              DSRfgC 586
            <ds:DESUPER-CKT> = Jcomponent(22, <ds:DESUPER-CKT>)                 DSRfgC 587
        END SELECT                                                              DSRfgC 588
c                                                                               DSRfgC 589
c              Second level of attachments                                      DSRfgC 590
      CASE (202)                                                                DSRfgC 591
        Jrs = <ds:/RefgSystem/>                                                 DSRfgC 592
        <ds;Refrigerant> = <rs:REFRIGERANT>                                     DSRfgC 593
c                                                                               DSRfgC 594
c              Default suction circuit to same as desuperheated                 DSRfgC 595
        IF (<ds:SUCTION-CKT> .EQ. 0) <ds:SUCTION-CKT> = <ds:DESUPER-CKT>        DSRfgC 596
        Jrc                = <ds:SUCTION-CKT>                                   DSRfgC 597
        Jrs                = <rc:/RefgSystem/>                                  DSRfgC 598
        <ds;SupplyRefg>    = <rs:REFRIGERANT>                                   DSRfgC 599
        <ds;SuRefgHrefPtr> = IA_RefgHRef(Jrs)                                   DSRfgC 600
c                                                                               DSRfgC 601
c              Create nodes                                                     DSRfgC 602
      CASE (203)                                                                DSRfgC 603
c              Check for cross-connected systems                                DSRfgC 604
        CALL RefgX(Jds, <ds:SUCTION-CKT>,<ds:LIQUID-CKT>,0)                     DSRfgC 605
c              If desuperheater suction circuit is same circuit as the          DSRfgC 606
c              desuperheater gas, re-assign to be downstream circuit or         DSRfgC 607
c              suction-group                                                    DSRfgC 608
        Jrc = <ds:DESUPER-CKT>                                                  DSRfgC 609
        IF (<ds:SUCTION-CKT> .EQ. Jrc) <ds:SUCTION-CKT> = <rc:TRUNK-CKT>        DSRfgC 610
c              Create the attachments                                           DSRfgC 611
        Jrs = <ds:/RefgSystem/>                                                 DSRfgC 612
        Jsg = <ds:/SuctionGroup>                                                DSRfgC 613
c              desuperheated circuit, inlet and outlet                          DSRfgC 614
        Krx = <ds:DESUPER-CKT>                                                  DSRfgC 615
        <ds;DesupInNode>   = NewNode(1, Jrs,-Jsg,Jds,0,    62,1,Jrc, 1.)        DSRfgC 616
        <ds;DesupOutNode>  = NewNode(1, Jrs,-Jsg,Jds,<ds:DESUPER-CKT>,          DSRfgC 617
     &                                                     62,2,Jrc, 1.)        DSRfgC 618
c              liquid and suction attachments, supply-side of HX                DSRfgC 619
        <ds;SupplyInNode>  = NewNode(1, Jrs,-Jsg,Jds,<ds:LIQUID-CKT>,           DSRfgC 620
     &                                                     61,1,Jrc, 1.)        DSRfgC 621
        <ds;SupplyOutNode> = NewNode(1, Jrs,-Jsg,Jds,<ds:SUCTION-CKT>,          DSRfgC 622
     &                                                     62,2,Jrc, 1.)        DSRfgC 623
c                                                                               DSRfgC 624
c              Auxiliary meter                                                  DSRfgC 625
        Jme = <ds:AUX-METER>                                                    DSRfgC 626
        <ds:AUX-METER>= NewNode(1, Jrs,-Jsg,Jds,Jme, 11,2,7, 1.)                DSRfgC 627
c                                                                               DSRfgC 628
c              Links, lists                                                     DSRfgC 629
      CASE (205)                                                                DSRfgC 630
c              Check if no attachments                                          DSRfgC 631
        Kri = <ds;DesupInNode>                                                  DSRfgC 632
        IF (<ri;Xnode> .EQ. 0)  THEN                                            DSRfgC 633
          CALL MSGSIM(-1,II,II,II,II)                                           DSRfgC 634
          WRITE (IOUTPT,9006) (<ds:NAME>,II=1,8)                                DSRfgC 635
          CALL MessageBox( NULL,                                                DSRfgC 636
     &      'A desuperheater must be fed by at'//char(10)//char(13)//           DSRfgC 637
     &      'least one suction circuit'//char(0),                               DSRfgC 638
     &      'DESUPERHEATER Errors'//char(0),                                    DSRfgC 639
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                DSRfgC 640
          IwinReturn = 1                                                        DSRfgC 641
          RETURN                                                                DSRfgC 642
        ENDIF                                                                   DSRfgC 643
c              Get pointer to reference enthalpy                                DSRfgC 644
        <ds;RefgHrefPtr> = IA_RefgHRef(Jrs)                                     DSRfgC 645
c                                                                               DSRfgC 646
        CALL ListNodes(<ds;Nodes>, 0,0,Jds,0, 0,0)                              DSRfgC 647
c                                                                               DSRfgC 648
c              Histories                                                        DSRfgC 649
      CASE (208)                                                                DSRfgC 650
        Jrs = <ds:/RefgSystem/>                                                 DSRfgC 651
        Jsg = <ds:/SuctionGroup>                                                DSRfgC 652
c              desuperheated inlet pressure                                     DSRfgC 653
        Kri = <ds;DesupInNode>                                                  DSRfgC 654
        <ds;DesupInHsty> = NewHistory(Jrs,-Jsg,Jds, <ri;Xnode>, Kri,            DSRfgC 655
     &                       0, 0, 1.,                                          DSRfgC 656
     &                       <#ri.Pinlet>, <sp:ERROR-P>, 1,                     DSRfgC 657
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)            DSRfgC 658
c              desuperheated outlet enthalpy                                    DSRfgC 659
        Kro = <ds;DesupOutNode>                                                 DSRfgC 660
        <ds;DesupOutHsty> = NewHistory(Jrs,-Jsg,Jds, <ro;Xnode>, Kro,           DSRfgC 661
     &                        0, 7, 1.25,                                       DSRfgC 662
     &                        <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                DSRfgC 663
     &                        <#ro.Houtlet>, <sp:ERROR-H>   , 1,                DSRfgC 664
     &                        <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                DSRfgC 665
     &                        <#ro.Preqd>  , <sp:ERROR-P>   , 1,                DSRfgC 666
     &                        0,0.,0, 0,0.,0)                                   DSRfgC 667
c              supply history                                                   DSRfgC 668
        Kli = 0                                                                 DSRfgC 669
        Kri = <ds;SupplyInNode>                                                 DSRfgC 670
        Kro = <ds;SupplyOutNode>                                                DSRfgC 671
        CALL ListAdd(Kli, <ri;Xnode>)                                           DSRfgC 672
        CALL ListAdd(Kli, <ro;Xnode>)                                           DSRfgC 673
        <ds;SupplyHsty> = NewHistory(Jrs-Jsg,Jds, Kli, Kro,                     DSRfgC 674
     &                      5, 3, 1.,                                           DSRfgC 675
     &                      <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                  DSRfgC 676
     &                      <#ro.Houtlet>, <sp:ERROR-H>   , 1,                  DSRfgC 677
     &                      <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                  DSRfgC 678
     &                      <#ro.Preqd>  , <sp:ERROR-P>   , 1,                  DSRfgC 679
     &                      0,0.,0, 0,0.,0)                                     DSRfgC 680
c                                                                               DSRfgC 681
c              History lists                                                    DSRfgC 682
      CASE (209)                                                                DSRfgC 683
c              All histories associated with this component                     DSRfgC 684
        CALL ListHstys(<ds;Hstys>, 0, 0, Jds)                                   DSRfgC 685
c                                                                               DSRfgC 686
c              Dump pointers                                                    DSRfgC 687
      CASE (210)                                                                DSRfgC 688
        IF (<ds;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         DSRfgC 689
        WRITE (IOUTPT, 9202)  (<ds:NAME>,II=1,8),                               DSRfgC 690
     &    Jds, <ds:DESUPER-CKT>, <ds;DesupInNode>, <ds;DesupOutNode>,           DSRfgC 691
     &    <ds;SupplyInNode>, <ds;SupplyOutNode>                                 DSRfgC 692
c                                                                               DSRfgC 693
c                                                                               DSRfgC 694
      END SELECT  ! Mode                                                        DSRfgC 695
c                                                                               DSRfgC 696
c                                                                               DSRfgC 697
      RETURN                                                                    DSRfgC 698
c                                                                               DSRfgC 699
c              Message formats                                                  DSRfgC 700
 9001 FORMAT(14x,'Desuperheater: ',8A4,' has a mass'                   /        DSRfgC 701
     &       14x,'capacity smaller than the design flow.'              /        DSRfgC 702
     &       14x,'Flow: ',F10.1,'  Capacity: ',F10.1                   )        DSRfgC 703
 9002 FORMAT(14x,'Desuperheater: ',8A4,' has a thermal'                /        DSRfgC 704
     &       14x,'capacity smaller than required.'                     /        DSRfgC 705
     &       14x,'Capacity: ',F10.0,'  Design Capacity: ',F10.0        )        DSRfgC 706
 9003 FORMAT(14x,'Desuperheater: ',8A4,' has a design '                /        DSRfgC 707
     &       14x,'temperature differential between the entering liquid'/        DSRfgC 708
     &       14x,'and suction gas of only',F4.1,'F.  Will use 10F in'  /        DSRfgC 709
     &       14x,'the heat-exchanger design calculations.'             )        DSRfgC 710
 9004 FORMAT(14x,'Desuperheater: ',8A4,' heat exchanger design '       /        DSRfgC 711
     &       14x,'calculations failed to converge in 100 iterations.'  )        DSRfgC 712
 9005 FORMAT(14x,'Desuperheater: ',8A4,' has subcool side'             /        DSRfgC 713
     &       14x,'and suction side film resistances > 1.0'             )        DSRfgC 714
 9006 FORMAT(                                                                   DSRfgC 715
     &14x,'Desuperheater: ',8A4,' has no attached suction'             /        DSRfgC 716
     &14x,'circuits. At least one circuit must be attached to the'     /        DSRfgC 717
     &14x,'desuperheater inlet, or the desuperheater must be removed.' )        DSRfgC 718
 9201 FORMAT(/' DESUPERHEATERs                         Jds       Jrc',          DSRfgC 719
     &'       Kri       Kro   Sup Kri   Sup Kro'                       /        DSRfgC 720
     &1x,32('-'),6('  --------'))                                               DSRfgC 721
 9202 FORMAT(1x,8A4,6I10)                                                       DSRfgC 722
      END                                                                       DSRfgC 723
C ##############################################################################SCAlgs   2
C ##############################################################################SCAlgs   3
C ##############################################################################SCAlgs   4
C ##############################################################################SCAlgs   5
C ##########                                                          ##########SCAlgs   6
C ##########                    SUBCOOLER ROUTINES                    ##########SCAlgs   7
C ##########                                                          ##########SCAlgs   8
C ##############################################################################SCAlgs   9
C ##############################################################################SCAlgs  10
C ##############################################################################SCAlgs  11
C ##############################################################################SCAlgs  12
c                                                                               SCAlgs  13
      SUBROUTINE Subcooler_Economizer(Mode, Jsc)                                SCEcon   2
c                                                                               SCEcon   3
c              Simulates a flash subcooler that feeds into the                  SCEcon   4
c              economizer port of a group of compressors.                       SCEcon   5
c              A subcooler is always located at the inlet end of a              SCEcon   6
c              liquid refrigerant circuit.                                      SCEcon   7
c                                                                               SCEcon   8
c ??           TEMPORARY ALGORITHM - remove once economizer REFG-CIRCUITS       SCEcon   9
c              implemented, as FLASH economizer will be able to attach          SCEcon  10
c              to an economizer REFG-CIRCUIT.                                   SCEcon  11
c ??           Since the program does not yet simulate compressors with         SCEcon  12
c              economizers, this algorithm dumps the flashed liquid             SCEcon  13
c              directly into the discharge circuit of the compressors.          SCEcon  14
c              The performance curves of the compressors must take into         SCEcon  15
c              account the kW consumption of the assumed economizer flow.       SCEcon  16
c                                                                               SCEcon  17
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               SCEcon  25
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               SCEcon  27
      INTEGER  Xri, Xro, rH                                                     SCEcon  28
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             SCEcon  29
      REAL     Mliquid, Msuction                                                SCEcon  30
                                                                                SCEcon  31
c                                                                               SCEcon  32
c ?? NOT DEBUGGED SINCE UPGRADED FOR NEW REQUIRED VARIABLES ??                  SCEcon  33
c ?? AND SINCE SUBCOOLER BROKEN AWAY FROM LIQUID CIRCUIT                        SCEcon  34
                                                                                SCEcon  35
c******** Note: RunFrac not debugged ?? ***************                         SCEcon  36
                                                                                SCEcon  37
c                                                                               SCEcon  38
      Jre = <sc;Refrigerant>           ! refrigerant                            SCEcon  39
c                                                                               SCEcon  40
      SELECT CASE (Mode)                                                        SCEcon  41
c                                                                               SCEcon  42
c                                                                               SCEcon  43
c ============ HOURLY SIMULATION - LOADS TO PLANT ============================= SCEcon  44
      CASE (31)                                                                 SCEcon  45
c                                                                               SCEcon  46
c              Check if iteration required                                      SCEcon  47
      IterNode = IterReqdNode(1, <sc;Nodes>)                                    SCEcon  48
      IF (.NOT. IterNode  .AND.                                                 SCEcon  49
     &    .NOT. IterReqdHsty(<sc;Hstys>))  RETURN                               SCEcon  50
c                                                                               SCEcon  51
c              Subcooled liquid                                                 SCEcon  52
      Kri = <sc;SubInNode>                                                      SCEcon  53
      Xri = <ri;Xnode>                                                          SCEcon  54
      Kro = <sc;SubOutNode>                                                     SCEcon  55
c                                                                               SCEcon  56
c              Get the demands on this circuit                                  SCEcon  57
      CALL RefgNode(Kro, <ro.Moutlet>,<ro.Mreqd>, xH, <ro.Treqd>,               SCEcon  58
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     SCEcon  59
      <ri.Minlet>  = <ro.Moutlet>                                               SCEcon  60
      <ri.RunFrac> = <ro.RunFrac>                                               SCEcon  61
c                                                                               SCEcon  62
c              Requested properties                                             SCEcon  63
      <ri.Mreqd>  = <ro.Mreqd>                                                  SCEcon  64
      IF (<ri.Mreqd> .GT. 0.)  THEN                                             SCEcon  65
c              pressure                                                         SCEcon  66
        IF (<ro.Preqd> .LT. -888.)  THEN                                        SCEcon  67
          <ri.Preqd> = -88888.                                                  SCEcon  68
        ELSE                                                                    SCEcon  69
          dP = <sc:SUBCOOL-DP>                                                  SCEcon  70
     &       * (<ri.Mreqd>/<ri.RunFrac>*<sc;1/Mliquid>)**1.87                   SCEcon  71
          <ri.Preqd> = MIN(<re;Pmax>, <ro.Preqd>+dP)                            SCEcon  72
        ENDIF                                                                   SCEcon  73
c              temperature - currently modeled as fixed                         SCEcon  74
        IF (<ro.Treqd> .LT. -888.)  THEN                                        SCEcon  75
          <ri.Treqd> = -88888.                                                  SCEcon  76
        ELSE                                                                    SCEcon  77
          <ri.Treqd> = MIN(<re;Tmax>, <ro.Treqd>,                               SCEcon  78
     &                     RefgT_fP(Jre, <Xri.Pinlet>))                         SCEcon  79
        ENDIF                                                                   SCEcon  80
      ENDIF                                                                     SCEcon  81
c                                                                               SCEcon  82
      CALL CnvgCheck(1, <sc;PlantHsty>)                                         SCEcon  83
c                                                                               SCEcon  84
c                                                                               SCEcon  85
c ============ HOURLY SIMULATION - PLANT TO LOADS ============================= SCEcon  86
      CASE (32)                                                                 SCEcon  87
c                                                                               SCEcon  88
c              Check if iteration required                                      SCEcon  89
      IterNode = IterReqdNode(1, <sc;Nodes>)                                    SCEcon  90
      IF (.NOT. IterNode  .AND.                                                 SCEcon  91
     &    .NOT. IterReqdHsty(<sc;Hstys>))  RETURN                               SCEcon  92
c                                                                               SCEcon  93
c              Subcooled liquid                                                 SCEcon  94
      Kri = <sc;SubInNode>                                                      SCEcon  95
      Xri = <ri;Xnode>                                                          SCEcon  96
      Kro = <sc;SubOutNode>                                                     SCEcon  97
c                                                                               SCEcon  98
c              Pressure entering subcooler                                      SCEcon  99
      <ri.Pinlet> = <Xri.Pinlet>                                                SCEcon 100
      PliquidOut  = <Xri.Pinlet>                                                SCEcon 101
c              Temperature and enthalpy entering subcooler                      SCEcon 102
      <ri.Tinlet> = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                   SCEcon 103
      TliquidIn   = <ri.Tinlet>                                                 SCEcon 104
      HliquidIn   = <Xri.Hinlet>                                                SCEcon 105
c                                                                               SCEcon 106
c              Skip if no mass flow                                             SCEcon 107
      IF (<ro.Moutlet> .EQ. 0.)  THEN                                           SCEcon 108
        Kri = <sc;SucInNode>                                                    SCEcon 109
        Xri = <ri;Xnode>                                                        SCEcon 110
        Kro = <sc;SucOutNode>                                                   SCEcon 111
        Xro = <ro;Xnode>                                                        SCEcon 112
        Call EconoNoLoad                                                        SCEcon 113
        <ro.Mreqd> = 0.                                                         SCEcon 114
        RunFrac    = 0.                                                         SCEcon 115
        GOTO 3290                                                               SCEcon 116
      ENDIF                                                                     SCEcon 117
                                                                                SCEcon 118
c              Subcooler is operating. If cycling, convert hourly               SCEcon 119
c              average refrigerant flow to flow when cycled on                  SCEcon 120
      RunFrac = <ro.RunFrac>                                                    SCEcon 121
      Mliquid = <ro.Moutlet> / RunFrac                                          SCEcon 122
                                                                                SCEcon 123
c              Pressure drop through subcooler if no flashing                   SCEcon 124
      dP = <sc:SUBCOOL-DP> * (Mliquid*<sc;1/Mliquid>)**1.87                     SCEcon 125
      PliquidOut = PliquidOut - dP                                              SCEcon 126
c                                                                               SCEcon 127
c              Suction side of HX                                               SCEcon 128
      Kri = <sc;SucInNode>                                                      SCEcon 129
      Xri = <ri;Xnode>                                                          SCEcon 130
      Kro = <sc;SucOutNode>                                                     SCEcon 131
      Xro = <ro;Xnode>                                                          SCEcon 132
c                                                                               SCEcon 133
c              Start of iterative loop                                          SCEcon 134
      Msuction     = <ro.Moutlet> / RunFrac                                     SCEcon 135
      <ro.Moutlet> = Msuction                                                   SCEcon 136
      ErrorLast    = 0.                                                         SCEcon 137
      Damp         = 1.                                                         SCEcon 138
 3210 CONTINUE                                                                  SCEcon 139
c                                                                               SCEcon 140
c              Available suction pressure                                       SCEcon 141
      Psuction = <Xro.Poutlet>                                                  SCEcon 142
c              Adjust for effect of control valve                               SCEcon 143
      Voutlet  = RefgV_fPH(Jre, Psuction, <ro.Houtlet>)                         SCEcon 144
      dPctrl   = (Msuction * <sc;1/Msuction>)**1.87                             SCEcon 145
     &         * ( Voutlet * <sc;DesignOutletD>)**1.6                           SCEcon 146
      dPctrl   = dPctrl * <sc;CtrlValveDP>                                      SCEcon 147
      Psuction = Psuction + dPctrl                                              SCEcon 148
c              minimum possible suction T at given suction flow                 SCEcon 149
      SSTmin   = RefgT_fP(Jre, Psuction)                                        SCEcon 150
c                                                                               SCEcon 151
c              Outlet temperature and load                                      SCEcon 152
      SELECT CASE (<sc:TEMP-CTRL>)                                              SCEcon 153
c                                                                               SCEcon 154
        CASE (1)    ! Floating                                                  SCEcon 155
          <sc;Tsetpt> = -888.                                                   SCEcon 156
          IF (TliquidIn .LE. SSTmin)  THEN                                      SCEcon 157
c              entering liquid is colder than suction - no load                 SCEcon 158
            <ro.Mreqd> = 0.                                                     SCEcon 159
            Call EconoNoLoad                                                    SCEcon 160
          ELSE                                                                  SCEcon 161
c              subcooler load and subcooled liquid T                            SCEcon 162
            SST = SSTmin                                                        SCEcon 163
            Call EconoLoad                                                      SCEcon 164
c              required suction flow and pressure                               SCEcon 165
            <ro.Mreqd> = Msuction                                               SCEcon 166
            <ro.Preqd> = RefgP_fT(Jre, <sc:DES-SUBCOOL-T>)                      SCEcon 167
          ENDIF  ! TliquidIn                                                    SCEcon 168
c                                                                               SCEcon 169
        CASE (4:5)  ! Local EPR                                                 SCEcon 170
c              get desired liquid setpoint                                      SCEcon 171
          SELECT CASE (<sc:TEMP-CTRL>)                                          SCEcon 172
            CASE (4)  ! Local EPR                                               SCEcon 173
              <sc;Tsetpt> = <sc:TEMP-SETPT>                                     SCEcon 174
            CASE (5)  ! Local EPR w/ schedule                                   SCEcon 175
              <sc;Tsetpt> = SchVal(<sc:TEMP-SETPT-SC>)                          SCEcon 176
          END SELECT                                                            SCEcon 177
c              Given the setpoint, see if subcooling necessary                  SCEcon 178
          IF (TliquidIn .LE. <sc;Tsetpt>)  THEN                                 SCEcon 179
c              entering liquid is colder than suction setpoint - no load        SCEcon 180
            <ro.Mreqd> = 0.                                                     SCEcon 181
            Call EconoNoLoad                                                    SCEcon 182
          ELSE                                                                  SCEcon 183
c                 required suction conditions                                   SCEcon 184
            Call EconoReqdLoad                                                  SCEcon 185
            IF (SSTmin .GE. TliquidIn)  THEN                                    SCEcon 186
c                 suction is warmer than entering liquid - no load              SCEcon 187
              Call EconoNoLoad                                                  SCEcon 188
            ELSE                                                                SCEcon 189
c                 subcooler load and subcooled liquid T                         SCEcon 190
              SST = MAX(SSTmin, <sc;Tsetpt>)                                    SCEcon 191
              Call EconoLoad                                                    SCEcon 192
            ENDIF  ! SSTmin                                                     SCEcon 193
          ENDIF  ! TliquidIn                                                    SCEcon 194
      END SELECT  ! sc:TEMP-CTRL                                                SCEcon 195
c                                                                               SCEcon 196
c              Check if converged                                               SCEcon 197
      Error = <ro.Moutlet> - Msuction                                           SCEcon 198
      IF (Error*ErrorLast .lt. 0.) THEN  ! oscillating                          SCEcon 199
        IF (Error/ErrorLast .lt. -0.5) THEN  ! slow convergence                 SCEcon 200
          Damp = Damp * 0.7                                                     SCEcon 201
        ENDIF                                                                   SCEcon 202
      ENDIF                                                                     SCEcon 203
      Error        = Error * Damp                                               SCEcon 204
      <ro.Moutlet> = <ro.Moutlet> - Error                                       SCEcon 205
      ErrorLast    = Error                                                      SCEcon 206
      IF (Msuction .GT. 0.000001)  THEN                                         SCEcon 207
        IF (ABS(Error/Msuction) .GT. <sp:ERROR-FLOW>)  GOTO 3210                SCEcon 208
      ENDIF                                                                     SCEcon 209
c              Pressure as regulated by temperature control valve               SCEcon 210
      Pctrl = RefgP_fT(Jre, MAX(SST, SSTmin))                                   SCEcon 211
c                                                                               SCEcon 212
c              Liquid inlet requirements                                        SCEcon 213
 3290 <sc;Qsubcool> = <sc;Qsubcool> * RunFrac                                   SCEcon 214
      <ro.Moutlet>  = Msuction      * RunFrac                                   SCEcon 215
      <ri.Minlet>   = <ro.Moutlet>                                              SCEcon 216
      dP         = <sc:SUCTION-DP> * (<ro.Mreqd>*<sc;1/Msuction>)**1.87         SCEcon 217
      <ri.Preqd> = MIN(<re;Pmax>, Pctrl + dP)                                   SCEcon 218
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCEcon 219
      <ro.Mreqd> = <ro.Mreqd> * RunFrac                                         SCEcon 220
      <ri.Mreqd> = <ro.Mreqd>                                                   SCEcon 221
c                                                                               SCEcon 222
      CALL CnvgCheck(1, <sc;SuctionHsty>)                                       SCEcon 223
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<sc;SuRefgHrefPtr>))        SCEcon 224
      <ro.Qoutlet> = <ri.Qinlet> + <sc;Qsubcool>                                SCEcon 225
c                                                                               SCEcon 226
c              Subcooled liquid                                                 SCEcon 227
      Kri = <sc;SubInNode>                                                      SCEcon 228
      Xri = <ri;Xnode>                                                          SCEcon 229
      Kro = <sc;SubOutNode>                                                     SCEcon 230
      IF (<ro.Moutlet> .GT. 0.)  THEN                                           SCEcon 231
        <ro.Toutlet> = TliquidOut                                               SCEcon 232
        <ro.Poutlet> = PliquidOut                                               SCEcon 233
        <ro.Houtlet> = HliquidOut                                               SCEcon 234
      ENDIF                                                                     SCEcon 235
      CALL CnvgCheck(1, <sc;SubcoolHsty>)                                       SCEcon 236
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<sc;RefgHrefPtr>))          SCEcon 237
      <ro.Qoutlet> = <ri.Qinlet> - <sc;Qsubcool>                                SCEcon 238
c                                                                               SCEcon 239
c                                                                               SCEcon 240
c ============ REPORT CREATION ================================================ SCEcon 241
      CASE (50)                                                                 SCEcon 242
c                                                                               SCEcon 243
c              statistics blocks                                                SCEcon 244
      Ks2Load     = NewStat2(Jsc, <+sc;Qsubcool>, 0, 1.)                        SCEcon 245
      Ks5LoadBin  = NewStat5(Jsc, <+sc;Qsubcool>, 0, 1.)                        SCEcon 246
      Ks2Msubc    = NewStat2(<sc;SubInNode>, <+ri.Minlet>, 0, 1.)               SCEcon 247
      Ks5MsubcBin = NewStat5(<sc;SubInNode>, <+ri.Minlet>, 0, 1.)               SCEcon 248
      Ks2Msuct    = NewStat2(<sc;SucInNode>, <+ri.Minlet>, 0, 1.)               SCEcon 249
      Ks5MsuctBin = NewStat5(<sc;SucInNode>, <+ri.Minlet>, 0, 1.)               SCEcon 250
c                                                                               SCEcon 251
c              Create the type "H" report                                       SCEcon 252
      IF (<sc:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      SCEcon 253
     &  <sc;PS-H> = NewReport_H(Jsc, 137,                                       SCEcon 254
     &                          4, 5, 6,                                        SCEcon 255
     &                          Ks2Load, Ks2Msubc, Ks2Msuct, 0,                 SCEcon 256
     &                          Ks5LoadBin, Ks5MsubcBin, Ks5MsuctBin,           SCEcon 257
     &                          0, 0, 0)                                        SCEcon 258
c                                                                               SCEcon 259
c                                                                               SCEcon 260
c ============ REPORT ORDER =================================================== SCEcon 261
      CASE (52)                                                                 SCEcon 262
c                                                                               SCEcon 263
      Call Report_H(Mode, <sc;PS-H>)                                            SCEcon 264
c                                                                               SCEcon 265
c                                                                               SCEcon 266
c ============ REPORTS - VERIFICATION DATA ==================================== SCEcon 267
      CASE (54)                                                                 SCEcon 268
c                                                                               SCEcon 269
c              Output design information                                        SCEcon 270
      IF (<sc;PS-H> .ne. 0)  THEN                                               SCEcon 271
        rH = <sc;PS-H>                                                          SCEcon 272
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       SCEcon 273
        CALL GetAttachments(Jsc, 2)                                             SCEcon 274
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   SCEcon 275
     &    (NameAttachments(II,1,1),II=1,8),                                     SCEcon 276
     &    (NameAttachments(II,1,2),II=1,8),                                     SCEcon 277
     &    <sc;Capacity>,<sc;Mliquid>,<sc;Msuction>,<sc:DES-SUBCOOL-T>,          SCEcon 278
     &    <sc;DesignUA>                                                         SCEcon 279
        DO  Irow=2,NumRowsOfAttachments                                         SCEcon 280
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 SCEcon 281
     &      (NameAttachments(II,Irow,1),II=1,8),                                SCEcon 282
     &      (NameAttachments(II,Irow,2),II=1,8)                                 SCEcon 283
        ENDDO                                                                   SCEcon 284
      ENDIF                                                                     SCEcon 285
c                                                                               SCEcon 286
c                                                                               SCEcon 287
c ============ HOURLY REPORTS - HOURLY DATA =================================== SCEcon 288
      CASE (62)                                                                 SCEcon 289
c                                                                               SCEcon 290
c              Hourly-report variables                                          SCEcon 291
      IF (<sc;HourRepBuf> .EQ. 0)  RETURN                                       SCEcon 292
c                                                                               SCEcon 293
      IAptr        = <sc;HourRepBuf> - 1                                        SCEcon 294
      AA(IAptr+1)  = <sc;Qsubcool>                                              SCEcon 295
      AA(IAptr+2)  = <sc;Tsetpt>                                                SCEcon 296
      AA(IAptr+3)  = <sc;UA>                                                    SCEcon 297
c              subcooled inlet                                                  SCEcon 298
      Kri          = <sc;SubInNode>                                             SCEcon 299
      Xri          = <ri;Xnode>                                                 SCEcon 300
      AA(IAptr+4)  = <ri.Qinlet>                                                SCEcon 301
      AA(IAptr+5)  = <ri.Minlet>                                                SCEcon 302
      AA(IAptr+6)  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCEcon 303
      AA(IAptr+7)  = <Xri.Pinlet>                                               SCEcon 304
      AA(IAptr+8)  = <ri.Preqd>                                                 SCEcon 305
      AA(IAptr+9)  = <Xri.Hinlet>                                               SCEcon 306
c              subcooled outlet                                                 SCEcon 307
      Kro          = <sc;SubOutNode>                                            SCEcon 308
      AA(IAptr+10) = <ro.Qoutlet>                                               SCEcon 309
      AA(IAptr+11) = <ro.Moutlet>                                               SCEcon 310
c     AA(IAptr+12) = unused                                                     SCEcon 311
      AA(IAptr+13) = <ro.Toutlet>                                               SCEcon 312
      AA(IAptr+14) = <ro.Treqd>                                                 SCEcon 313
      AA(IAptr+15) = <ro.Poutlet>                                               SCEcon 314
      AA(IAptr+16) = <ro.Preqd>                                                 SCEcon 315
      AA(IAptr+17) = <ro.Houtlet>                                               SCEcon 316
c              suction inlet                                                    SCEcon 317
      Kri          = <sc;SucInNode>                                             SCEcon 318
      Xri          = <ri;Xnode>                                                 SCEcon 319
      AA(IAptr+18) = <ri.Qinlet>                                                SCEcon 320
      AA(IAptr+19) = <ri.Minlet>                                                SCEcon 321
      AA(IAptr+20) = <Xri.Pinlet>                                               SCEcon 322
      AA(IAptr+21) = <ri.Preqd>                                                 SCEcon 323
      AA(IAptr+22) = <Xri.Hinlet>                                               SCEcon 324
c              suction outlet                                                   SCEcon 325
      Kro          = <sc;SucOutNode>                                            SCEcon 326
      Xro          = <ro;Xnode>                                                 SCEcon 327
      AA(IAptr+23) = <ro.Qoutlet>                                               SCEcon 328
      AA(IAptr+24) = <ro.Moutlet>                                               SCEcon 329
      AA(IAptr+25) = <Xro.Poutlet>                                              SCEcon 330
      AA(IAptr+26) = <ro.Preqd>                                                 SCEcon 331
      AA(IAptr+27) = <ro.Houtlet>                                               SCEcon 332
c                                                                               SCEcon 333
c                                                                               SCEcon 334
c ============ DESIGN CALCULATIONS - LOADS TO PLANT =========================== SCEcon 335
      CASE (111)                                                                SCEcon 336
c                                                                               SCEcon 337
c              Subcooled liquid side                                            SCEcon 338
      Kri = <sc;SubInNode>                                                      SCEcon 339
      Xri = <ri;Xnode>                                                          SCEcon 340
      Kro = <sc;SubOutNode>                                                     SCEcon 341
c                                                                               SCEcon 342
c              Set iteration flag on inlet                                      SCEcon 343
      <Xri.IterFlag> = Jsc                                                      SCEcon 344
c                                                                               SCEcon 345
c              Design mass flow of demanders                                    SCEcon 346
      CALL RefgNode(Kro, <ro.Moutlet>,xMreqd,xH, <ro.Treqd>,                    SCEcon 347
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     SCEcon 348
c                                                                               SCEcon 349
c              Flow                                                             SCEcon 350
      <ri.Minlet> = <ro.Moutlet>                                                SCEcon 351
      <ri.Mreqd>  = <ro.Moutlet>                                                SCEcon 352
c                                                                               SCEcon 353
c              Capacity                                                         SCEcon 354
      dHliquid = MAX(2., <Xri.Hinlet>-<ro.Houtlet>)                             SCEcon 355
      Qsubcool = <ri.Minlet> * dHliquid                                         SCEcon 356
      IF (<sc:CAPACITY> .NE. 0.)  THEN                                          SCEcon 357
        <sc;Capacity> = <sc:CAPACITY>                                           SCEcon 358
      ELSE                                                                      SCEcon 359
        <sc;Capacity> = Qsubcool                                                SCEcon 360
      ENDIF                                                                     SCEcon 361
c                                                                               SCEcon 362
c              Required inlet pressure, adjusted for HX friction                SCEcon 363
      dP = <sc:SUBCOOL-DP>                                                      SCEcon 364
      IF (<sc:FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)                        SCEcon 365
     &  dP = dP * (<ri.Minlet>/<sc:FLOW>)**1.87                                 SCEcon 366
      <ri.Preqd> = <ro.Preqd> + dP                                              SCEcon 367
c              required inlet temperature                                       SCEcon 368
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCEcon 369
c                                                                               SCEcon 370
c                                                                               SCEcon 371
c              Suction side of HX                                               SCEcon 372
      Kri = <sc;SucInNode>                                                      SCEcon 373
      Xri = <ri;Xnode>                                                          SCEcon 374
      Kro = <sc;SucOutNode>                                                     SCEcon 375
      Xro = <ro;Xnode>                                                          SCEcon 376
c                                                                               SCEcon 377
c              Refrigerant conditions at outlet to suction                      SCEcon 378
      SSTreqd      = <sc:DES-SUBCOOL-T>                                         SCEcon 379
      <ro.Houtlet> = RefgH_Vapor_fT(Jre, SSTreqd)                               SCEcon 380
      dHsuction    = MAX(20., <ro.Houtlet> - <Xri.Hinlet>)                      SCEcon 381
      <ro.Moutlet> = Qsubcool / dHsuction                                       SCEcon 382
      <ri.Minlet>  = <ro.Moutlet>                                               SCEcon 383
      <ri.Mreqd>   = <ro.Moutlet>                                               SCEcon 384
      <ro.Mreqd>   = <ro.Moutlet>                                               SCEcon 385
      <ro.Preqd>   = RefgP_fT(Jre, SSTreqd)                                     SCEcon 386
c              effect of control valve                                          SCEcon 387
      IF (<sc:CTRL-VALVE-DT> .EQ. 0.)  THEN                                     SCEcon 388
        dPctrl = 0.                                                             SCEcon 389
      ELSE                                                                      SCEcon 390
        dPctrl = <ro.Preqd> - RefgP_fT(Jre, SSTreqd-<sc:CTRL-VALVE-DT>)         SCEcon 391
        IF (<sc:SUCTION-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)             SCEcon 392
     &    dPctrl   = dPctrl * (<ro.Moutlet>/<sc:SUCTION-FLOW>)**1.87            SCEcon 393
        <ro.Preqd> = <ro.Preqd> - dPctrl                                        SCEcon 394
        <sc;CtrlValveDP> = dPctrl                                               SCEcon 395
      ENDIF                                                                     SCEcon 396
c              total pressure drop thru suction side                            SCEcon 397
      <sc;1/dPsupply> = 1./ (<sc:SUCTION-DP>+<sc;CtrlValveDP>)                  SCEcon 398
c                                                                               SCEcon 399
c              Check for convergence on outlet conditions                       SCEcon 400
      CALL CnvgCheck(1, <sc;SuctionHsty>)                                       SCEcon 401
c                                                                               SCEcon 402
c              Refrigerant conditions at liquid inlet                           SCEcon 403
      dP          = <sc:SUCTION-DP>                                             SCEcon 404
      IF (<sc:SUCTION-FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)                SCEcon 405
     &  dP = dP * (<ri.Minlet>/<sc:SUCTION-FLOW>)**1.87                         SCEcon 406
      <ri.Preqd> = <ro.Preqd> + dP + dPctrl                                     SCEcon 407
c              Liquid should be delivered no warmer than saturation             SCEcon 408
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCEcon 409
c                                                                               SCEcon 410
      IF (<sc:SUCTION-FLOW> .GT. 0.)  THEN                                      SCEcon 411
        <sc;Msuction> = <sc:SUCTION-FLOW>                                       SCEcon 412
      ELSE                                                                      SCEcon 413
        <sc;Msuction> = <ro.Moutlet>                                            SCEcon 414
      ENDIF                                                                     SCEcon 415
c                                                                               SCEcon 416
c                                                                               SCEcon 417
c ============ DESIGN CALCULATIONS - PLANT TO LOADS =========================== SCEcon 418
      CASE (112)                                                                SCEcon 419
c                                                                               SCEcon 420
c              Subcooled liquid side of HX                                      SCEcon 421
      Kri = <sc;SubInNode>                                                      SCEcon 422
      Xri = <ri;Xnode>                                                          SCEcon 423
      Kro = <sc;SubOutNode>                                                     SCEcon 424
c                                                                               SCEcon 425
c              Adjust for pressure loss, no flashing                            SCEcon 426
      <ri.Pinlet> = <Xri.Pinlet>                                                SCEcon 427
      IF (<sc:FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN                  SCEcon 428
        dP = <sc:SUBCOOL-DP> * (<ri.Minlet>/<sc:FLOW>)**1.87                    SCEcon 429
      ELSE                                                                      SCEcon 430
        dP = <sc:SUBCOOL-DP>                                                    SCEcon 431
      ENDIF                                                                     SCEcon 432
      <ro.Poutlet> = <ri.Pinlet> - dP                                           SCEcon 433
c                                                                               SCEcon 434
c              Adjust outlet conditions for subcooling effect                   SCEcon 435
      <ri.Tinlet>  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCEcon 436
      <ro.Toutlet> = MIN(<sc:DES-SUBCOOL-T>, <ri.Tinlet>)                       SCEcon 437
      <ro.Houtlet> = RefgH_Liquid_fT(Jre, <ro.Toutlet>)                         SCEcon 438
      <ri.Pinlet>  = <Xri.Pinlet>                                               SCEcon 439
c              reduce outlet pressure to flash temperature                      SCEcon 440
      <ro.Poutlet>  = MIN(<ro.Poutlet>, RefgP_fT(Jre, <ro.Toutlet>))            SCEcon 441
c                                                                               SCEcon 442
c              Liquid flow                                                      SCEcon 443
      IF (<sc:FLOW> .GT. 0.)  THEN                                              SCEcon 444
        <sc;Mliquid> = <sc:FLOW>                                                SCEcon 445
      ELSE                                                                      SCEcon 446
        dHliquid     = MAX(1., <Xri.Hinlet>-<ro.Houtlet>)                       SCEcon 447
        <sc;Mliquid> = <sc;Capacity> / dHliquid                                 SCEcon 448
      ENDIF                                                                     SCEcon 449
c                                                                               SCEcon 450
c                                                                               SCEcon 451
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== SCEcon 452
      CASE (119)                                                                SCEcon 453
c                                                                               SCEcon 454
      IF (<sc;Mliquid>  .GT. 0.)  <sc;1/Mliquid>  = 1.0 / <sc;Mliquid>          SCEcon 455
      IF (<sc;Msuction> .GT. 0.)  <sc;1/Msuction> = 1.0 / <sc;Msuction>         SCEcon 456
c                                                                               SCEcon 457
c              Subcooled liquid side of HX                                      SCEcon 458
      Kri = <sc;SubInNode>                                                      SCEcon 459
      Xri = <ri;Xnode>                                                          SCEcon 460
      Kro = <sc;SubOutNode>                                                     SCEcon 461
c              warn if insufficient mass flow capacity                          SCEcon 462
      IF (<ri.Minlet> .GT. <sc;Mliquid>*1.01)  THEN                             SCEcon 463
        CALL MSGSIM(-2,II,II,II,II)                                             SCEcon 464
        WRITE (IOUTPT, 9001)  (<sc:NAME>,II=1,8),                               SCEcon 465
     &                         <ri.Minlet>, <sc;Mliquid>                        SCEcon 466
      ENDIF                                                                     SCEcon 467
      Msubcool = <ri.Minlet>                                                    SCEcon 468
      Cp       = RefgCp_Liquid_fP(Jre, <Xri.Pinlet>)                            SCEcon 469
c                                                                               SCEcon 470
c              warn if insufficient thermal capacity                            SCEcon 471
      Qsubcool = <ri.Minlet> * (<Xri.Hinlet>-<ro.Houtlet>)                      SCEcon 472
      IF (Qsubcool .GT. <sc;Capacity>*1.01)  THEN                               SCEcon 473
        CALL MSGSIM(-2,II,II,II,II)                                             SCEcon 474
        WRITE (IOUTPT, 9002)  (<sc:NAME>,II=1,8),                               SCEcon 475
     &                         Qsubcool, <sc;Capacity>                          SCEcon 476
      ENDIF                                                                     SCEcon 477
      <sc;Qsubcool> = <sc;Capacity>                                             SCEcon 478
c                                                                               SCEcon 479
c              Suction side of HX                                               SCEcon 480
      Kri = <sc;SucInNode>                                                      SCEcon 481
      Xri = <ri;Xnode>                                                          SCEcon 482
      Kro = <sc;SucOutNode>                                                     SCEcon 483
      Xro = <ro;Xnode>                                                          SCEcon 484
c                                                                               SCEcon 485
c              Design volume and density at outlet                              SCEcon 486
      <sc;DesignOutletV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)          SCEcon 487
      <sc;DesignOutletD> = 1.0 / <sc;DesignOutletV>                             SCEcon 488
c              Total pressure drop thru suction side                            SCEcon 489
      <sc;1/dPsupply> = 1. / (<sc:SUCTION-DP>+<sc;CtrlValveDP>)                 SCEcon 490
c                                                                               SCEcon 491
c                                                                               SCEcon 492
c ============ ATTACHMENTS ==================================================== SCEcon 493
c                                                                               SCEcon 494
c              Initial attachments                                              SCEcon 495
      CASE (201)                                                                SCEcon 496
c              Component pointers, schedules, and curves                        SCEcon 497
        <sc:COST-DATA>     = Jcomponent(18, <sc:COST-DATA>)                     SCEcon 498
        <sc:TEMP-SETPT-SC> = Jsched(<sc:TEMP-SETPT-SC>)                         SCEcon 499
        <sc:REFG-SYSTEM>   = Jcomponent(29, <sc:REFG-SYSTEM>)                   SCEcon 500
        <sc:/RefgSystem/>  = Jcomponent(29, <sc:/RefgSystem/>)                  SCEcon 501
        <sc:SUCTION-CKT>   = Jcomponent(22, <sc:SUCTION-CKT>)                   SCEcon 502
c              subcooled attachment                                             SCEcon 503
        SELECT CASE (<sc:ATTACH-TO>)                                            SCEcon 504
          CASE (1)  ! Refg-system                                               SCEcon 505
            <sc:SUBCOOL-CKT> = <sc:REFG-SYSTEM>                                 SCEcon 506
          CASE (6)  ! Refg-circuit                                              SCEcon 507
            <sc:SUBCOOL-CKT> = Jcomponent(22, <sc:SUBCOOL-CKT>)                 SCEcon 508
        END SELECT                                                              SCEcon 509
c              liquid to provide subcooling                                     SCEcon 510
        IF (<sc:LIQUID-CKT> .GT. 0)  THEN                                       SCEcon 511
          <sc:LIQUID-CKT> = Jcomponent(22, <sc:LIQUID-CKT>)                     SCEcon 512
        ELSE                                                                    SCEcon 513
c              Default liquid feed to same circuit as subcooled                 SCEcon 514
          <sc:LIQUID-CKT> = <sc:SUBCOOL-CKT>                                    SCEcon 515
        ENDIF                                                                   SCEcon 516
c                                                                               SCEcon 517
c              Second level of attachments                                      SCEcon 518
      CASE (202)                                                                SCEcon 519
c              Refrigerants                                                     SCEcon 520
c              subcooled liquid                                                 SCEcon 521
        Jrs = <sc:/RefgSystem/>                                                 SCEcon 522
        <sc;Refrigerant> = <rs:REFRIGERANT>                                     SCEcon 523
c                                                                               SCEcon 524
c              Find the discharge circuit of the associated suction-group       SCEcon 525
        Jrc = <sc:SUCTION-CKT>                                                  SCEcon 526
        Jsg = <rc:/SuctionGroup>                                                SCEcon 527
        <sc;DischargeCkt> = <sg:DISCHARGE-CKT>                                  SCEcon 528
c                                                                               SCEcon 529
c              Create nodes                                                     SCEcon 530
      CASE (203)                                                                SCEcon 531
c              Check for cross-connected systems                                SCEcon 532
        CALL RefgX(Jsc, <sc:SUBCOOL-CKT>,<sc:SUCTION-CKT>,0)                    SCEcon 533
c                                                                               SCEcon 534
c              Attachments on both sides of subcooler                           SCEcon 535
        Jrs = <sc:/RefgSystem/>                                                 SCEcon 536
        Keu = NewEndUse(Jsc)                                                    SCEcon 537
        <sc;SubInNode>  = NewNode(1, Jrs,0,Jsc,<sc:SUBCOOL-CKT>,                SCEcon 538
     &                                                     61,1,Keu, 1.)        SCEcon 539
        <sc;SubOutNode> = NewNode(1, Jrs,0,Jsc,0,          61,2,Keu, 1.)        SCEcon 540
        <sc;SucInNode>  = NewNode(1, Jrs,0,Jsc,<sc:LIQUID-CKT>,                 SCEcon 541
     &                                                     61,1,Keu, 1.)        SCEcon 542
c              suction outlet is actually into the compressor discharge         SCEcon 543
        Jrc             = <sc;DischargeCkt>                                     SCEcon 544
        I               = 60 + <rc:TYPE>                                        SCEcon 545
        <sc;SucOutNode> = NewNode(1, Jrs,0,Jsc,Jrc, I,2,Keu, 1.)                SCEcon 546
c                                                                               SCEcon 547
c              Links, lists                                                     SCEcon 548
      CASE (205)                                                                SCEcon 549
c              Check if no attachments                                          SCEcon 550
        Kro = <sc;SubOutNode>                                                   SCEcon 551
        IF (<ro;Xnode> .EQ. 0)  THEN                                            SCEcon 552
          CALL MSGSIM(-1,II,II,II,II)                                           SCEcon 553
          WRITE (IOUTPT,9003) (<sc:NAME>,II=1,8)                                SCEcon 554
          CALL MessageBox( NULL,                                                SCEcon 555
     &      'Subcooler must feed at least one liquid circuit'//char(0),         SCEcon 556
     &      'SUBCOOLER Errors'//char(0),                                        SCEcon 557
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SCEcon 558
          IwinReturn = 1                                                        SCEcon 559
          RETURN                                                                SCEcon 560
        ENDIF                                                                   SCEcon 561
c              Get pointer to reference enthalpy                                SCEcon 562
        <sc;RefgHrefPtr> = IA_RefgHRef(<sc:/RefgSystem/>)                       SCEcon 563
c                                                                               SCEcon 564
c              List of nodes                                                    SCEcon 565
        CALL ListNodes(<sc;Nodes>, 0,0,Jsc,0, 0,0)                              SCEcon 566
c                                                                               SCEcon 567
c              Histories                                                        SCEcon 568
      CASE (208)                                                                SCEcon 569
        Jrs = <sc:/RefgSystem/>                                                 SCEcon 570
c              Set up history on subcool outlet conditions                      SCEcon 571
        Kro = <sc;SubOutNode>                                                   SCEcon 572
        <sc;SubcoolHsty> = NewHistory(Jrs,0,Jsc, <ro;Xnode>, Kro,               SCEcon 573
     &                       5, 12, 1.25,                                       SCEcon 574
     &                       <#ro.Houtlet>, <sp:ERROR-H>, 1,                    SCEcon 575
     &                       <#ro.Poutlet>, <sp:ERROR-P>, 1,                    SCEcon 576
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                    SCEcon 577
c              Inlet history                                                    SCEcon 578
        <sc;PlantHsty> = NewHistory(Jrs,0,Jsc, <ri;Xnode>, Kri,                 SCEcon 579
     &                     0, 0, 1.,                                            SCEcon 580
     &                     <#ri.Minlet>, <sp:ERROR-FLOW>, 2,                    SCEcon 581
     &                     <#ri.Mreqd> , <sp:ERROR-FLOW>, 2,                    SCEcon 582
     &                     <#ri.Preqd> , <sp:ERROR-P>   , 1,                    SCEcon 583
     &                     <#ri.Treqd> , <sp:ERROR-T>   , 1,                    SCEcon 584
     &                     0,0.,0, 0,0.,0)                                      SCEcon 585
c              Suction                                                          SCEcon 586
        Kri = <sc;SucInNode>                                                    SCEcon 587
        Kro = <sc;SucOutNode>                                                   SCEcon 588
        Kli = 0                                                                 SCEcon 589
        CALL ListAdd(Kli, <ri;Xnode>)                                           SCEcon 590
        CALL ListAdd(Kli, <ro;Xnode>)                                           SCEcon 591
        <sc;SuctionHsty> = NewHistory(Jrs,0,Jsc, Kli, Kro,                      SCEcon 592
     &                       5, 3, 1.5,                                         SCEcon 593
     &                       <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                 SCEcon 594
     &                       <#ro.Houtlet>, <sp:ERROR-H>   , 1,                 SCEcon 595
     &                       <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                 SCEcon 596
     &                       <#ro.Preqd>  , <sp:ERROR-P>   , 1,                 SCEcon 597
     &                       0,0.,0, 0,0.,0)                                    SCEcon 598
c                                                                               SCEcon 599
c              History lists                                                    SCEcon 600
      CASE (209)                                                                SCEcon 601
c              All histories associated with this component                     SCEcon 602
        CALL ListHstys(<sc;Hstys>, 0, 0, Jsc)                                   SCEcon 603
c                                                                               SCEcon 604
c              Dump pointers                                                    SCEcon 605
      CASE (210)                                                                SCEcon 606
        IF (<sc;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         SCEcon 607
        WRITE (IOUTPT, 9202)  (<sc:NAME>,II=1,8),                               SCEcon 608
     &    Jsc, <sc:SUBCOOL-CKT>, <sc;SubInNode>, <sc;SubOutNode>,               SCEcon 609
     &    <sc;SucInNode>, <sc;SucOutNode>                                       SCEcon 610
c                                                                               SCEcon 611
c                                                                               SCEcon 612
      END SELECT  ! Mode                                                        SCEcon 613
c                                                                               SCEcon 614
c                                                                               SCEcon 615
      RETURN                                                                    SCEcon 616
c                                                                               SCEcon 617
c              Message formats                                                  SCEcon 618
 9001 FORMAT(                                                                   SCEcon 619
     &14x,'Subcooler: ',8A4,' has a mass capacity'                     /        SCEcon 620
     &14x,'smaller than the design flow. Flow: ',F10.1,'  Capacity: '  ,        SCEcon 621
     &F10.1                                                            )        SCEcon 622
 9002 FORMAT(                                                                   SCEcon 623
     &14x,'Subcooler: ',8A4,' has a thermal'                           /        SCEcon 624
     &14x,'capacity smaller than required.  Capacity: ',F10.0          ,        SCEcon 625
     &'  Design Capacity: ',F10.0                                      )        SCEcon 626
 9003 FORMAT(                                                                   SCEcon 627
     &14x,'Desuperheater: ',8A4,' has no attached suction'             /        SCEcon 628
     &14x,'circuits. At least one circuit must be attached to the'     /        SCEcon 629
     &14x,'desuperheater inlet, or the desuperheater must be removed.' )        SCEcon 630
 9201 FORMAT(/                                                                  SCEcon 631
     &' SUBCOOLERs                             Jsc       Jrc'          ,        SCEcon 632
     &'       Kri       Kro    Suc In   Suc Out'                       /        SCEcon 633
     &1x,32('-'),6('  --------'))                                               SCEcon 634
 9202 FORMAT(1x,8A4,6I10)                                                       SCEcon 635
c                                                                               SCEcon 636
c                                                                               SCEcon 637
      CONTAINS                                                                  SCEcon 638
c ============== EconoLoad ==================================================== SCEcon 639
      Subroutine EconoLoad                                                      SCEcon 640
c                                                                               SCEcon 641
c              Active subcooling                                                SCEcon 642
c                                                                               SCEcon 643
c              Subcooler load and subcooled temperature                         SCEcon 644
      HliquidOut    = RefgH_Liquid_fT(Jre, SST)                                 SCEcon 645
      <sc;Qsubcool> = Mliquid * (HliquidIn - HliquidOut)                        SCEcon 646
      TliquidOut    = SST                                                       SCEcon 647
      PliquidOut    = RefgP_fT(Jre, SST)                                        SCEcon 648
c                                                                               SCEcon 649
c              Suction enthalpy, and mass flow                                  SCEcon 650
      <ro.Houtlet>  = RefgH_Vapor_fT(Jre, SST)                                  SCEcon 651
      dHsuction     = <ro.Houtlet> - <Xri.Hinlet>                               SCEcon 652
      Msuction      = <sc;Qsubcool> / dHsuction                                 SCEcon 653
c                                                                               SCEcon 654
      End Subroutine EconoLoad                                                  SCEcon 655
c                                                                               SCEcon 656
c                                                                               SCEcon 657
c ============== EconoNoLoad ================================================== SCEcon 658
      Subroutine EconoNoLoad                                                    SCEcon 659
c                                                                               SCEcon 660
c              No subcooler load                                                SCEcon 661
c                                                                               SCEcon 662
      <sc;Qsubcool> = 0.               ! subcooler load                         SCEcon 663
      TliquidOut    = TliquidIn        ! leaving liquid T                       SCEcon 664
      HliquidOut    = HliquidIn        ! leaving liquid H                       SCEcon 665
      Msuction      = 0.               ! suction mass flow                      SCEcon 666
c                                                                               SCEcon 667
      End Subroutine EconoNoLoad                                                SCEcon 668
c                                                                               SCEcon 669
c                                                                               SCEcon 670
c ============== EconoReqdLoad ================================================ SCEcon 671
      Subroutine EconoReqdLoad                                                  SCEcon 672
c                                                                               SCEcon 673
c              Required subcooler load                                          SCEcon 674
c                                                                               SCEcon 675
c              Required load, suction temperature & pressure                    SCEcon 676
      HliquidOut = RefgH_Liquid_fT(Jre, <sc;Tsetpt>)                            SCEcon 677
      Qreqd      = Mliquid * (HliquidIn - HliquidOut)                           SCEcon 678
      <ro.Preqd> = MAX(<re;Pmin>, RefgP_fT(Jre, <sc;Tsetpt>) - dPctrl)          SCEcon 679
c                                                                               SCEcon 680
c              Required suction enthalpy, and flow                              SCEcon 681
      Hreqd      = RefgH_Vapor_fT(Jre, <sc;Tsetpt>)                             SCEcon 682
      dHsuction  = Hreqd - <Xri.Hinlet>                                         SCEcon 683
      <ro.Mreqd> = Qreqd / dHsuction                                            SCEcon 684
c                                                                               SCEcon 685
      End Subroutine EconoReqdLoad                                              SCEcon 686
                                                                                SCEcon 687
      END                                                                       SCEcon 688
      SUBROUTINE Subcooler_Flash(Mode, Jsc)                                     SCFlsh   2
c                                                                               SCFlsh   3
c              Simulates a flash subcooler.  A subcooler                        SCFlsh   4
c              is always located at the inlet end of a liquid                   SCFlsh   5
c              refrigerant circuit.                                             SCFlsh   6
c                                                                               SCFlsh   7
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               SCFlsh  15
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               SCFlsh  17
      INTEGER Xri, Xro, rH                                                      SCFlsh  18
      REAL    Msubcool, Msuction                                                SCFlsh  19
c                                                                               SCFlsh  20
c ?? not debugged - implemented as first step to economizer subcooler           SCFlsh  21
c ?? must modify to make similar to economizer subcooler ??                     SCFlsh  22
c ?? RunFrac not implemented ??                                                 SCFlsh  23
c                                                                               SCFlsh  24
      Jre = <sc;Refrigerant>                  ! refrigerant                     SCFlsh  25
c                                                                               SCFlsh  26
      SELECT CASE (Mode)                                                        SCFlsh  27
c                                                                               SCFlsh  28
c                                                                               SCFlsh  29
c ============ HOURLY SIMULATION - LOADS TO PLANT ============================= SCFlsh  30
      CASE (31)                                                                 SCFlsh  31
c                                                                               SCFlsh  32
c              Subcooled liquid                                                 SCFlsh  33
      Kri = <sc;SubInNode>                                                      SCFlsh  34
      Xri = <ri;Xnode>                                                          SCFlsh  35
      Kro = <sc;SubOutNode>                                                     SCFlsh  36
c                                                                               SCFlsh  37
c              Set iteration flag on inlet                                      SCFlsh  38
      <Xri.IterFlag> = Jsc                                                      SCFlsh  39
c                                                                               SCFlsh  40
c              Get the demands on this circuit                                  SCFlsh  41
      CALL RefgNode(Kro, <ro.Moutlet>,<ro.Mreqd>, xH, <ro.Treqd>,               SCFlsh  42
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     SCFlsh  43
      <ri.Minlet> = <ro.Moutlet>                                                SCFlsh  44
      <ri.Mreqd>  = <ro.Mreqd>                                                  SCFlsh  45
c                                                                               SCFlsh  46
c              Requested properties                                             SCFlsh  47
      <ri.Mreqd>  = <ro.Mreqd>                                                  SCFlsh  48
      IF (<ri.Mreqd> .GT. 0.)  THEN                                             SCFlsh  49
c              pressure                                                         SCFlsh  50
        IF (<ro.Preqd> .LT. -888.)  THEN                                        SCFlsh  51
          <ri.Preqd> = -88888.                                                  SCFlsh  52
        ELSE                                                                    SCFlsh  53
          dP = <sc:SUBCOOL-DP> * (<ri.Mreqd>*<sc;1/Mliquid>)**1.87              SCFlsh  54
          <ri.Preqd> = MIN(<re;Pmax>, <ro.Preqd>+dP)                            SCFlsh  55
        ENDIF                                                                   SCFlsh  56
c              temperature - currently modeled as fixed                         SCFlsh  57
        IF (<ro.Treqd> .LT. -888.)  THEN                                        SCFlsh  58
          <ri.Treqd> = -88888.                                                  SCFlsh  59
        ELSE                                                                    SCFlsh  60
          <ri.Treqd> = MIN(<re;Tmax>, <ro.Treqd>,                               SCFlsh  61
     &                     RefgT_fP(Jre, <Xri.Pinlet>))                         SCFlsh  62
        ENDIF                                                                   SCFlsh  63
      ENDIF                                                                     SCFlsh  64
c                                                                               SCFlsh  65
c                                                                               SCFlsh  66
c ============ HOURLY SIMULATION - PLANT TO LOADS ============================= SCFlsh  67
      CASE (32)                                                                 SCFlsh  68
c                                                                               SCFlsh  69
c              Subcooled liquid                                                 SCFlsh  70
      Kri = <sc;SubInNode>                                                      SCFlsh  71
      Xri = <ri;Xnode>                                                          SCFlsh  72
      Kro = <sc;SubOutNode>                                                     SCFlsh  73
c                                                                               SCFlsh  74
c              Pressure drop through subcooler                                  SCFlsh  75
      dP = <sc:SUBCOOL-DP> * (<ro.Moutlet>*<sc;1/Mliquid>)**1.87                SCFlsh  76
      <ri.Pinlet> = <Xri.Pinlet>                                                SCFlsh  77
      PliquidOut = <ri.Pinlet> - dP                                             SCFlsh  78
c                                                                               SCFlsh  79
c              Skip if no mass flow                                             SCFlsh  80
      IF (<ro.Moutlet> .EQ. 0.)  THEN                                           SCFlsh  81
        Kri = <sc;SucInNode>                                                    SCFlsh  82
        Xri = <ri;Xnode>                                                        SCFlsh  83
        Kro = <sc;SucOutNode>                                                   SCFlsh  84
        Xro = <ro;Xnode>                                                        SCFlsh  85
        <ro.Moutlet>  = 0.                                                      SCFlsh  86
        <ro.Mreqd>    = 0.                                                      SCFlsh  87
        <sc;Qsubcool> = 0.                                                      SCFlsh  88
        GOTO 3290                                                               SCFlsh  89
      ENDIF                                                                     SCFlsh  90
c                                                                               SCFlsh  91
c              Temperature entering subcooler                                   SCFlsh  92
      TliquidIn  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                    SCFlsh  93
      <ri.Tinlet> = TliquidIn                                                   SCFlsh  94
c              base specific heat on average temperature                        SCFlsh  95
      Tliquid = (TliquidIn+<ro.Toutlet>) * 0.5                                  SCFlsh  96
      Cp       = RefgCp_Liquid_fT(Jre, Tliquid)                                 SCFlsh  97
      Cmin     = <ri.Minlet> * Cp                                               SCFlsh  98
c                                                                               SCFlsh  99
c                                                                               SCFlsh 100
c              Suction liquid and gas                                           SCFlsh 101
      Kri = <sc;SucInNode>                                                      SCFlsh 102
      Xri = <ri;Xnode>                                                          SCFlsh 103
      Kro = <sc;SucOutNode>                                                     SCFlsh 104
      Xro = <ro;Xnode>                                                          SCFlsh 105
c                                                                               SCFlsh 106
c              Start of iterative loop                                          SCFlsh 107
      ErrorLast = 0.                                                            SCFlsh 108
      Damp      = 1.                                                            SCFlsh 109
 3210 CONTINUE                                                                  SCFlsh 110
c              Available suction pressure                                       SCFlsh 111
      Psuction = <Xro.Poutlet>                                                  SCFlsh 112
c              Adjust for effect of EPR                                         SCFlsh 113
      IF (<sc;CtrlValveDP> .GT. 0.)  THEN                                       SCFlsh 114
c              Adjust for effect of local EPR                                   SCFlsh 115
        Voutlet  = RefgV_fPH(Jre, Psuction, <ro.Houtlet>)                       SCFlsh 116
        dPepr    = (<ro.Moutlet> * <sc;1/Msuction>)**1.87                       SCFlsh 117
     &           * (     Voutlet * <sc;DesignOutletD>)**1.6                     SCFlsh 118
        dPepr    = dPepr * <sc;CtrlValveDP>                                     SCFlsh 119
        Psuction = Psuction + dPepr                                             SCFlsh 120
      ELSE                                                                      SCFlsh 121
        dPepr = 0.                                                              SCFlsh 122
      ENDIF                                                                     SCFlsh 123
      SST = RefgT_fP(Jre, Psuction)                                             SCFlsh 124
c                                                                               SCFlsh 125
c              Outlet temperature and load                                      SCFlsh 126
      SELECT CASE (<sc:TEMP-CTRL>)                                              SCFlsh 127
        CASE (1)    ! Floating                                                  SCFlsh 128
          IF (SST .LT. TliquidIn)  THEN                                         SCFlsh 129
            <sc;Tsetpt>   = -888.                                               SCFlsh 130
            <sc;Qsubcool> = Cmin * (TliquidIn-SST)                              SCFlsh 131
            TliquidOut   = SST                                                  SCFlsh 132
          ELSE                                                                  SCFlsh 133
            TliquidOut   = TliquidIn                                            SCFlsh 134
            <sc;Qsubcool> = 0.                                                  SCFlsh 135
          ENDIF                                                                 SCFlsh 136
        CASE (4:5)  ! Local EPR                                                 SCFlsh 137
          SELECT CASE (<sc:TEMP-CTRL>)                                          SCFlsh 138
            CASE (4)  ! Local EPR                                               SCFlsh 139
              <sc;Tsetpt> = <sc:TEMP-SETPT>                                     SCFlsh 140
            CASE (5)  ! Local EPR w/ schedule                                   SCFlsh 141
              <sc;Tsetpt> = SchVal(<sc:TEMP-SETPT-SC>)                          SCFlsh 142
          END SELECT                                                            SCFlsh 143
          IF (<sc;Tsetpt> .LT. TliquidIn)  THEN                                 SCFlsh 144
            SST           = MAX(<sc;Tsetpt>, SST)                               SCFlsh 145
            Psuction      = RefgP_fT(Jre, SST)                                  SCFlsh 146
            <sc;Qsubcool> = Cmin * (TliquidIn-SST)                              SCFlsh 147
            TliquidOut   = SST                                                  SCFlsh 148
          ELSE                                                                  SCFlsh 149
            TliquidOut   = TliquidIn                                            SCFlsh 150
            <sc;Qsubcool> = 0.                                                  SCFlsh 151
          ENDIF                                                                 SCFlsh 152
        CASE DEFAULT  ! Thermostatic control schemes                            SCFlsh 153
          SELECT CASE (<sc:TEMP-CTRL>)                                          SCFlsh 154
            CASE (2)  ! Thermostat                                              SCFlsh 155
              <sc;Tsetpt> = <sc:TEMP-SETPT>                                     SCFlsh 156
            CASE (3)  ! Thermostat schedule                                     SCFlsh 157
              <sc;Tsetpt> = SchVal(<sc:TEMP-SETPT-SC>)                          SCFlsh 158
            CASE (6)  ! Saturation differential                                 SCFlsh 159
              <sc;Tsetpt> = RefgT_fP(Jre,PliquidOut)-<sc:SATURATION-DT>         SCFlsh 160
            CASE (7)  ! Load reset                                              SCFlsh 161
              <sc;Tsetpt> = <ro.Treqd> - <sc:SATURATION-DT>                     SCFlsh 162
          END SELECT                                                            SCFlsh 163
          IF (<sc;Tsetpt> .LT. TliquidIn                                        SCFlsh 164
     &                                .AND.  SST .LT.  TliquidIn)  THEN         SCFlsh 165
            TliquidOut   = MAX(<sc;Tsetpt>, SST)                                SCFlsh 166
            <sc;Qsubcool> = Cmin * (TliquidIn-TliquidOut)                       SCFlsh 167
          ELSE                                                                  SCFlsh 168
            TliquidOut   = TliquidIn                                            SCFlsh 169
            <sc;Qsubcool> = 0.                                                  SCFlsh 170
          ENDIF                                                                 SCFlsh 171
      END SELECT  ! sc:TEMP-CTRL                                                SCFlsh 172
c                                                                               SCFlsh 173
c              Outlet enthalpy and mass flow rate                               SCFlsh 174
      <ro.Houtlet> = RefgH_Vapor_fT(Jre, TliquidOut)                            SCFlsh 175
      dH           = (<ro.Houtlet> - <Xri.Hinlet>)                              SCFlsh 176
      Msuction     = <sc;Qsubcool> / dH                                         SCFlsh 177
      Error        = <ro.Moutlet> - Msuction                                    SCFlsh 178
      IF (Error*ErrorLast .lt. 0.) THEN  ! oscillating                          SCFlsh 179
        IF (Error/ErrorLast .lt. -0.5) THEN  ! slow convergence                 SCFlsh 180
          Damp = Damp * 0.7                                                     SCFlsh 181
        ENDIF                                                                   SCFlsh 182
      ENDIF                                                                     SCFlsh 183
      Error        = Error * Damp                                               SCFlsh 184
      <ro.Moutlet> = <ro.Moutlet> - Error                                       SCFlsh 185
      ErrorLast    = Error                                                      SCFlsh 186
      IF (Msuction .GT. 0.000001)  THEN                                         SCFlsh 187
        IF (ABS(Error/Msuction) .GT. <sp:ERROR-FLOW>)  GOTO 3210                SCFlsh 188
      ENDIF                                                                     SCFlsh 189
c                                                                               SCFlsh 190
      <ri.Mreqd> = Msuction                                                     SCFlsh 191
      <ro.Mreqd> = Msuction                                                     SCFlsh 192
      IF (Msuction .GT. 0.)  THEN                                               SCFlsh 193
c              required suction pressure                                        SCFlsh 194
         SSTreqd    = <sc;Tsetpt>                                               SCFlsh 195
         <ro.Preqd> = MAX(<re;Pmin>, RefgP_fT(Jre, SSTreqd) - dPepr)            SCFlsh 196
c              required liquid pressure and temperature                         SCFlsh 197
        dP = <sc:SUCTION-DP> * (Msuction*<sc;1/Msuction>)**1.87                 SCFlsh 198
        <ri.Preqd> = MIN(<re;Pmax>, Psuction + dP)                              SCFlsh 199
        <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                SCFlsh 200
c                                                                               SCFlsh 201
c              Adjust mass flow if pressure insufficient                        SCFlsh 202
        IF (<ri.Preqd> .GT. <Xri.Pinlet>)  THEN                                 SCFlsh 203
          SELECT CASE (<sc:TEMP-CTRL>)                                          SCFlsh 204
            CASE (4:5)  ! Local EPR                                             SCFlsh 205
              IF (Psuction .GT. <Xro.Poutlet>)  THEN                            SCFlsh 206
                dPmax = <Xri.Pinlet> - Psuction                                 SCFlsh 207
                IF (dPmax .GT. 0.)  THEN                                        SCFlsh 208
                  <ro.Moutlet> = EXP(LOG(dPmax/<sc:SUCTION-DP>)/1.87            SCFlsh 209
     &                                           - LOG(<sc;1/Msuction>))        SCFlsh 210
                ELSE                                                            SCFlsh 211
                  <ro.Moutlet> = 0.                                             SCFlsh 212
                ENDIF                                                           SCFlsh 213
              ELSE                                                              SCFlsh 214
                dPmax = <Xri.Pinlet> - <Xro.Poutlet>                            SCFlsh 215
                IF (dPmax .GT. 0.)  THEN                                        SCFlsh 216
                  <ro.Moutlet> =                                                SCFlsh 217
     &                EXP(LOG(dPmax                                             SCFlsh 218
     &                         /(<sc;CtrlValveDP>+<sc:SUCTION-DP>))/1.87        SCFlsh 219
     &                                           - LOG(<sc;1/Msuction>))        SCFlsh 220
                ELSE                                                            SCFlsh 221
                  <ro.Moutlet> = 0.                                             SCFlsh 222
                ENDIF                                                           SCFlsh 223
              ENDIF                                                             SCFlsh 224
            CASE DEFAULT                                                        SCFlsh 225
              dPmax = <Xri.Pinlet> - <Xro.Poutlet>                              SCFlsh 226
              IF (dPmax .GT. 0.)  THEN                                          SCFlsh 227
                <ro.Moutlet> = EXP(LOG(dPmax/<sc:SUCTION-DP>)/1.87              SCFlsh 228
     &                                           - LOG(<sc;1/Msuction>))        SCFlsh 229
              ELSE                                                              SCFlsh 230
                <ro.Moutlet> = 0.                                               SCFlsh 231
              ENDIF                                                             SCFlsh 232
          END SELECT                                                            SCFlsh 233
          <sc;Qsubcool> = <ro.Moutlet> * dH                                     SCFlsh 234
          TliquidOut   = TliquidIn - <sc;Qsubcool>/Cmin                         SCFlsh 235
        ENDIF                                                                   SCFlsh 236
      ENDIF  ! ro,Moutlet .gt. 0                                                SCFlsh 237
c                                                                               SCFlsh 238
 3290 CALL CnvgCheck(1, <sc;SuctionHsty>)                                       SCFlsh 239
      <ri.Minlet>  = <ro.Moutlet>                                               SCFlsh 240
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<sc;SuRefgHrefPtr>))        SCFlsh 241
      <ro.Qoutlet> = <ri.Qinlet> + <sc;Qsubcool>                                SCFlsh 242
c                                                                               SCFlsh 243
c              Subcooled liquid                                                 SCFlsh 244
      Kri = <sc;SubInNode>                                                      SCFlsh 245
      Xri = <ri;Xnode>                                                          SCFlsh 246
      Kro = <sc;SubOutNode>                                                     SCFlsh 247
      IF (<ro.Moutlet> .GT. 0.)  THEN                                           SCFlsh 248
        <ro.Toutlet> = TliquidOut                                               SCFlsh 249
        <ro.Houtlet> = <Xri.Hinlet> - <sc;Qsubcool>/<ro.Moutlet>                SCFlsh 250
      ENDIF                                                                     SCFlsh 251
      CALL CnvgCheck(1, <sc;SubcoolHsty>)                                       SCFlsh 252
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<sc;RefgHrefPtr>))          SCFlsh 253
      <ro.Qoutlet> = <ri.Qinlet> - <sc;Qsubcool>                                SCFlsh 254
c              Drop outlet pressure to flash pressure                           SCFlsh 255
      <ro.Poutlet> = RefgP_fT(Jre, TliquidOut)                                  SCFlsh 256
c                                                                               SCFlsh 257
c                                                                               SCFlsh 258
c ============ REPORT CREATION ================================================ SCFlsh 259
      CASE (50)                                                                 SCFlsh 260
c                                                                               SCFlsh 261
c              statistics blocks                                                SCFlsh 262
      Ks2Load     = NewStat2(Jsc, <+sc;Qsubcool>, 0, 1.)                        SCFlsh 263
      Ks5LoadBin  = NewStat5(Jsc, <+sc;Qsubcool>, 0, 1.)                        SCFlsh 264
      Ks2Msubc    = NewStat2(<sc;SubInNode>, <+ri.Minlet>, 0, 1.)               SCFlsh 265
      Ks5MsubcBin = NewStat5(<sc;SubInNode>, <+ri.Minlet>, 0, 1.)               SCFlsh 266
      Ks2Msuct    = NewStat2(<sc;SucInNode>, <+ri.Minlet>, 0, 1.)               SCFlsh 267
      Ks5MsuctBin = NewStat5(<sc;SucInNode>, <+ri.Minlet>, 0, 1.)               SCFlsh 268
c                                                                               SCFlsh 269
c              Create the type "H" report                                       SCFlsh 270
      IF (<sc:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      SCFlsh 271
     &  <sc;PS-H> = NewReport_H(Jsc, 137,                                       SCFlsh 272
     &                          4, 5, 6,                                        SCFlsh 273
     &                          Ks2Load, Ks2Msubc, Ks2Msuct, 0,                 SCFlsh 274
     &                          Ks5LoadBin, Ks5MsubcBin, Ks5MsuctBin,           SCFlsh 275
     &                          0, 0, 0)                                        SCFlsh 276
c                                                                               SCFlsh 277
c                                                                               SCFlsh 278
c ============ REPORT ORDER =================================================== SCFlsh 279
      CASE (52)                                                                 SCFlsh 280
c                                                                               SCFlsh 281
      Call Report_H(Mode, <sc;PS-H>)                                            SCFlsh 282
c                                                                               SCFlsh 283
c                                                                               SCFlsh 284
c ============ REPORTS - VERIFICATION DATA ==================================== SCFlsh 285
      CASE (54)                                                                 SCFlsh 286
c                                                                               SCFlsh 287
c              Output design information                                        SCFlsh 288
      IF (<sc;PS-H> .ne. 0)  THEN                                               SCFlsh 289
        rH = <sc;PS-H>                                                          SCFlsh 290
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       SCFlsh 291
        CALL GetAttachments(Jsc, 2)                                             SCFlsh 292
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   SCFlsh 293
     &    (NameAttachments(II,1,1),II=1,8),                                     SCFlsh 294
     &    (NameAttachments(II,1,2),II=1,8),                                     SCFlsh 295
     &    <sc;Capacity>,<sc;Mliquid>,<sc;Msuction>,<sc:DES-SUBCOOL-T>,          SCFlsh 296
     &    <sc;DesignUA>                                                         SCFlsh 297
        DO  Irow=2,NumRowsOfAttachments                                         SCFlsh 298
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 SCFlsh 299
     &      (NameAttachments(II,Irow,1),II=1,8),                                SCFlsh 300
     &      (NameAttachments(II,Irow,2),II=1,8)                                 SCFlsh 301
        ENDDO                                                                   SCFlsh 302
      ENDIF                                                                     SCFlsh 303
c                                                                               SCFlsh 304
c                                                                               SCFlsh 305
c ============ HOURLY REPORTS - HOURLY DATA =================================== SCFlsh 306
      CASE (62)                                                                 SCFlsh 307
c                                                                               SCFlsh 308
c              Hourly-report variables                                          SCFlsh 309
      IF (<sc;HourRepBuf> .EQ. 0)  RETURN                                       SCFlsh 310
c                                                                               SCFlsh 311
      IAptr        = <sc;HourRepBuf> - 1                                        SCFlsh 312
      AA(IAptr+1)  = <sc;Qsubcool>                                              SCFlsh 313
      AA(IAptr+2)  = <sc;Tsetpt>                                                SCFlsh 314
      AA(IAptr+3)  = <sc;UA>                                                    SCFlsh 315
c              subcooled inlet                                                  SCFlsh 316
      Kri          = <sc;SubInNode>                                             SCFlsh 317
      Xri          = <ri;Xnode>                                                 SCFlsh 318
      AA(IAptr+4)  = <ri.Qinlet>                                                SCFlsh 319
      AA(IAptr+5)  = <ri.Minlet>                                                SCFlsh 320
      AA(IAptr+6)  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCFlsh 321
      AA(IAptr+7)  = <Xri.Pinlet>                                               SCFlsh 322
      AA(IAptr+8)  = <ri.Preqd>                                                 SCFlsh 323
      AA(IAptr+9)  = <Xri.Hinlet>                                               SCFlsh 324
c              subcooled outlet                                                 SCFlsh 325
      Kro          = <sc;SubOutNode>                                            SCFlsh 326
      AA(IAptr+10) = <ro.Qoutlet>                                               SCFlsh 327
      AA(IAptr+11) = <ro.Moutlet>                                               SCFlsh 328
c     AA(IAptr+12) = unused                                                     SCFlsh 329
      AA(IAptr+13) = <ro.Toutlet>                                               SCFlsh 330
      AA(IAptr+14) = <ro.Treqd>                                                 SCFlsh 331
      AA(IAptr+15) = <ro.Poutlet>                                               SCFlsh 332
      AA(IAptr+16) = <ro.Preqd>                                                 SCFlsh 333
      AA(IAptr+17) = <ro.Houtlet>                                               SCFlsh 334
c              suction inlet                                                    SCFlsh 335
      Kri          = <sc;SucInNode>                                             SCFlsh 336
      Xri          = <ri;Xnode>                                                 SCFlsh 337
      AA(IAptr+18) = <ri.Qinlet>                                                SCFlsh 338
      AA(IAptr+19) = <ri.Minlet>                                                SCFlsh 339
      AA(IAptr+20) = <Xri.Pinlet>                                               SCFlsh 340
      AA(IAptr+21) = <ri.Preqd>                                                 SCFlsh 341
      AA(IAptr+22) = <Xri.Hinlet>                                               SCFlsh 342
c              suction outlet                                                   SCFlsh 343
      Kro          = <sc;SucOutNode>                                            SCFlsh 344
      Xro          = <ro;Xnode>                                                 SCFlsh 345
      AA(IAptr+23) = <ro.Qoutlet>                                               SCFlsh 346
      AA(IAptr+24) = <ro.Moutlet>                                               SCFlsh 347
      AA(IAptr+25) = <Xro.Poutlet>                                              SCFlsh 348
      AA(IAptr+26) = <ro.Preqd>                                                 SCFlsh 349
      AA(IAptr+27) = <ro.Houtlet>                                               SCFlsh 350
c                                                                               SCFlsh 351
c                                                                               SCFlsh 352
c ============ DESIGN CALCULATIONS - LOADS TO PLANT =========================== SCFlsh 353
      CASE (111)                                                                SCFlsh 354
c                                                                               SCFlsh 355
c              Subcooled liquid side                                            SCFlsh 356
      Kri = <sc;SubInNode>                                                      SCFlsh 357
      Xri = <ri;Xnode>                                                          SCFlsh 358
      Kro = <sc;SubOutNode>                                                     SCFlsh 359
c                                                                               SCFlsh 360
c              Design mass flow of demanders                                    SCFlsh 361
      CALL RefgNode(Kro, <ro.Moutlet>,xMreqd,xH, <ro.Treqd>,                    SCFlsh 362
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     SCFlsh 363
c                                                                               SCFlsh 364
c              Flow                                                             SCFlsh 365
      <ri.Minlet>  = <ro.Moutlet>                                               SCFlsh 366
      <ri.Mreqd>   = <ro.Moutlet>                                               SCFlsh 367
c                                                                               SCFlsh 368
c              Design flow                                                      SCFlsh 369
      IF (<sc:FLOW> .GT. 0.)  THEN                                              SCFlsh 370
        <sc;Mliquid> = <sc:FLOW>                                                SCFlsh 371
      ELSE                                                                      SCFlsh 372
        <sc;Mliquid> = <ro.Moutlet>                                             SCFlsh 373
      ENDIF                                                                     SCFlsh 374
c                                                                               SCFlsh 375
c              adjust required pressure for subcooler friction                  SCFlsh 376
      IF (<sc:FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN                  SCFlsh 377
        dP = <sc:SUBCOOL-DP> * ((<ri.Minlet>/<sc:FLOW>)**1.87)                  SCFlsh 378
      ELSE                                                                      SCFlsh 379
        dP = <sc:SUBCOOL-DP>                                                    SCFlsh 380
      ENDIF                                                                     SCFlsh 381
      <ri.Preqd> = <ro.Preqd> + dP                                              SCFlsh 382
      <ri.Treqd> = 88888.                                                       SCFlsh 383
c                                                                               SCFlsh 384
c              Capacity                                                         SCFlsh 385
      IF (<sc:CAPACITY> .NE. 0.)  THEN                                          SCFlsh 386
        <sc;Capacity> = <sc:CAPACITY>                                           SCFlsh 387
      ELSE                                                                      SCFlsh 388
        <sc;Capacity> = <ri.Minlet> * MAX(0., <Xri.Hinlet>-<ro.Houtlet>)        SCFlsh 389
      ENDIF                                                                     SCFlsh 390
      TliquidIn  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                    SCFlsh 391
      TliquidSat = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCFlsh 392
c                                                                               SCFlsh 393
c                                                                               SCFlsh 394
c              Now suction side of subcooler                                    SCFlsh 395
      Kri = <sc;SucInNode>                                                      SCFlsh 396
      Xri = <ri;Xnode>                                                          SCFlsh 397
      Kro = <sc;SucOutNode>                                                     SCFlsh 398
      Xro = <ro;Xnode>                                                          SCFlsh 399
c                                                                               SCFlsh 400
c              Required suction temperature                                     SCFlsh 401
      SELECT CASE (<sc:TEMP-CTRL>)                                              SCFlsh 402
        CASE (1:5)  ! float, thermostat, epr                                    SCFlsh 403
          SSTreqd = <sc:TEMP-SETPT>                                             SCFlsh 404
        CASE (6)   ! saturation dT                                              SCFlsh 405
          SSTreqd = TliquidSat - <sc:SATURATION-DT>                             SCFlsh 406
      END SELECT                                                                SCFlsh 407
c                                                                               SCFlsh 408
c              refrigerant conditions at outlet to suction                      SCFlsh 409
      <ro.Houtlet> = RefgH_Vapor_fT(Jre, SSTreqd)                               SCFlsh 410
      <ro.Moutlet> = <sc;Capacity> / (<ro.Houtlet> - <Xri.Hinlet>)              SCFlsh 411
      <ri.Mreqd>   = <ro.Moutlet>                                               SCFlsh 412
      <ro.Mreqd>   = <ro.Moutlet>                                               SCFlsh 413
      <ro.Preqd>   = RefgP_fT(Jre, SSTreqd)                                     SCFlsh 414
c              effect of EPR valve                                              SCFlsh 415
      dPepr = <sc;CtrlValveDP>                                                  SCFlsh 416
      IF (dPepr .GT. 0.)  THEN                                                  SCFlsh 417
        IF (<sc:SUCTION-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)             SCFlsh 418
     &    dPepr = dPepr * (<ro.Moutlet>/<sc:SUCTION-FLOW>)**1.87                SCFlsh 419
        <ro.Preqd> = <ro.Preqd> - dPepr                                         SCFlsh 420
      ENDIF                                                                     SCFlsh 421
c                                                                               SCFlsh 422
c              Check for convergence on outlet conditions                       SCFlsh 423
      CALL CnvgCheck(1, <sc;SuctionHsty>)                                       SCFlsh 424
c                                                                               SCFlsh 425
c              Refrigerant conditions at inlet from liquid                      SCFlsh 426
      dP          = <sc:SUCTION-DP>                                             SCFlsh 427
      IF (<sc:SUCTION-FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)                SCFlsh 428
     &  dP = dP * (<ri.Minlet>/<sc:SUCTION-FLOW>)**1.87                         SCFlsh 429
      <ri.Preqd> = <ro.Preqd> + dP + dPepr                                      SCFlsh 430
c              Liquid should be delivered no warmer than saturation             SCFlsh 431
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCFlsh 432
c                                                                               SCFlsh 433
      IF (<sc:SUCTION-FLOW> .GT. 0.)  THEN                                      SCFlsh 434
        <sc;Msuction> = <sc:SUCTION-FLOW>                                       SCFlsh 435
      ELSE                                                                      SCFlsh 436
        <sc;Msuction> = <ro.Moutlet>                                            SCFlsh 437
      ENDIF                                                                     SCFlsh 438
c                                                                               SCFlsh 439
c                                                                               SCFlsh 440
c ============ DESIGN CALCULATIONS - PLANT TO LOADS =========================== SCFlsh 441
      CASE (112)                                                                SCFlsh 442
c                                                                               SCFlsh 443
c              Suction side of subcooler                                        SCFlsh 444
      Kro = <sc;SucOutNode>                                                     SCFlsh 445
      Xro = <ro;Xnode>                                                          SCFlsh 446
      SST = RefgT_fP(Jre, <Xro.Poutlet>)                                        SCFlsh 447
c                                                                               SCFlsh 448
c              Subcooled liquid side of subcooler                               SCFlsh 449
      Kri = <sc;SubInNode>                                                      SCFlsh 450
      Xri = <ri;Xnode>                                                          SCFlsh 451
      Kro = <sc;SubOutNode>                                                     SCFlsh 452
      Xro = <ro;Xnode>                                                          SCFlsh 453
c                                                                               SCFlsh 454
c              Adjust for pressure loss                                         SCFlsh 455
      <ri.Pinlet> = <Xri.Pinlet>                                                SCFlsh 456
      IF (<sc:FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN                  SCFlsh 457
        dP = <sc:SUBCOOL-DP> * (<ri.Minlet>/<sc:FLOW>)**1.87                    SCFlsh 458
      ELSE                                                                      SCFlsh 459
        dP = <sc:SUBCOOL-DP>                                                    SCFlsh 460
      ENDIF                                                                     SCFlsh 461
      <ro.Poutlet> = <ri.Pinlet> - dP                                           SCFlsh 462
c                                                                               SCFlsh 463
c              Adjust outlet enthalpy for subcooling effect                     SCFlsh 464
      <ri.Tinlet>  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCFlsh 465
      SELECT CASE (<sc:TEMP-CTRL>)                                              SCFlsh 466
        CASE (1:5)  ! Floating, Thermostat, EPR                                 SCFlsh 467
          <ro.Toutlet> = <sc:TEMP-SETPT>                                        SCFlsh 468
        CASE (6)  ! Subcool differential                                        SCFlsh 469
          <ro.Toutlet> = RefgT_fP(Jre,<ro.Poutlet>) - <sc:SATURATION-DT>        SCFlsh 470
        CASE (7)  ! Load reset                                                  SCFlsh 471
c              not implemented                                                  SCFlsh 472
      END SELECT  ! sc:TEMP-CTRL                                                SCFlsh 473
      <ro.Toutlet>  = MIN(<ro.Toutlet>, <ri.Tinlet>)                            SCFlsh 474
      <ro.Houtlet>  = RefgH_Liquid_fTP(Jre, <ro.Toutlet>, <ro.Poutlet>)         SCFlsh 475
c              reduce outlet pressure to flash temperature                      SCFlsh 476
      <ro.Poutlet>  = MIN(<ro.Poutlet>, RefgP_fT(Jre, <ro.Toutlet>))            SCFlsh 477
c                                                                               SCFlsh 478
c                                                                               SCFlsh 479
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== SCFlsh 480
      CASE (119)                                                                SCFlsh 481
c                                                                               SCFlsh 482
      IF (<sc;Mliquid>  .GT. 0.)  <sc;1/Mliquid>  = 1.0 / <sc;Mliquid>          SCFlsh 483
      IF (<sc;Msuction> .GT. 0.)  <sc;1/Msuction> = 1.0 / <sc;Msuction>         SCFlsh 484
c                                                                               SCFlsh 485
c              Subcooled liquid side of HX                                      SCFlsh 486
      Kri = <sc;SubInNode>                                                      SCFlsh 487
      Xri = <ri;Xnode>                                                          SCFlsh 488
      Kro = <sc;SubOutNode>                                                     SCFlsh 489
      Xro = <ro;Xnode>                                                          SCFlsh 490
c              warn if insufficient mass flow capacity                          SCFlsh 491
      IF (<ri.Minlet> .GT. <sc;Mliquid>*1.01)  THEN                             SCFlsh 492
        CALL MSGSIM(-2,II,II,II,II)                                             SCFlsh 493
        WRITE (IOUTPT, 9001)  (<sc:NAME>,II=1,8),                               SCFlsh 494
     &                         <ri.Minlet>, <sc;Mliquid>                        SCFlsh 495
      ENDIF                                                                     SCFlsh 496
      Msubcool = <ri.Minlet>                                                    SCFlsh 497
      Cp       = RefgCp_Liquid_fP(Jre, <Xri.Pinlet>)                            SCFlsh 498
c                                                                               SCFlsh 499
c              warn if insufficient thermal capacity                            SCFlsh 500
      Qhx = <ri.Minlet> * (<Xri.Hinlet>-<ro.Houtlet>)                           SCFlsh 501
      IF (Qhx .GT. <sc;Capacity>*1.01)  THEN                                    SCFlsh 502
        CALL MSGSIM(-2,II,II,II,II)                                             SCFlsh 503
        WRITE (IOUTPT, 9002)  (<sc:NAME>,II=1,8),                               SCFlsh 504
     &                         Qhx, <sc;Capacity>                               SCFlsh 505
      ENDIF                                                                     SCFlsh 506
      <sc;Qsubcool> = <sc;Capacity>                                             SCFlsh 507
c                                                                               SCFlsh 508
c              Suction side of HX                                               SCFlsh 509
      Kri = <sc;SucInNode>                                                      SCFlsh 510
      Xri = <ri;Xnode>                                                          SCFlsh 511
      Kro = <sc;SucOutNode>                                                     SCFlsh 512
      Xro = <ro;Xnode>                                                          SCFlsh 513
c              Design volume and density at outlet                              SCFlsh 514
      <sc;DesignOutletV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)          SCFlsh 515
      <sc;DesignOutletD> = 1.0 / <sc;DesignOutletV>                             SCFlsh 516
c                                                                               SCFlsh 517
c                                                                               SCFlsh 518
c ============ ATTACHMENTS ==================================================== SCFlsh 519
c                                                                               SCFlsh 520
c              Initial attachments                                              SCFlsh 521
      CASE (201)                                                                SCFlsh 522
c              Component pointers, schedules, and curves                        SCFlsh 523
        <sc:COST-DATA>     = Jcomponent(18, <sc:COST-DATA>)                     SCFlsh 524
        <sc:TEMP-SETPT-SC> = Jsched(<sc:TEMP-SETPT-SC>)                         SCFlsh 525
        <sc:REFG-SYSTEM>   = Jcomponent(29, <sc:REFG-SYSTEM>)                   SCFlsh 526
        <sc:/RefgSystem/>  = Jcomponent(29, <sc:/RefgSystem/>)                  SCFlsh 527
        <sc:SUCTION-CKT>   = Jcomponent(22, <sc:SUCTION-CKT>)                   SCFlsh 528
c              subcooled attachment                                             SCFlsh 529
        SELECT CASE (<sc:ATTACH-TO>)                                            SCFlsh 530
          CASE (1)  ! Refg-system                                               SCFlsh 531
            <sc:SUBCOOL-CKT> = <sc:REFG-SYSTEM>                                 SCFlsh 532
          CASE (6)  ! Refg-circuit                                              SCFlsh 533
            <sc:SUBCOOL-CKT> = Jcomponent(22, <sc:SUBCOOL-CKT>)                 SCFlsh 534
        END SELECT                                                              SCFlsh 535
c              liquid to provide subcooling                                     SCFlsh 536
        IF (<sc:LIQUID-CKT> .GT. 0)  THEN                                       SCFlsh 537
          <sc:LIQUID-CKT> = Jcomponent(22, <sc:LIQUID-CKT>)                     SCFlsh 538
        ELSE                                                                    SCFlsh 539
c              Default liquid feed to same circuit as subcooled                 SCFlsh 540
          <sc:LIQUID-CKT> = <sc:SUBCOOL-CKT>                                    SCFlsh 541
        ENDIF                                                                   SCFlsh 542
c                                                                               SCFlsh 543
c              Second level of attachments                                      SCFlsh 544
      CASE (202)                                                                SCFlsh 545
c              Refrigerants                                                     SCFlsh 546
c              subcooled liquid                                                 SCFlsh 547
        Jrs = <sc:/RefgSystem/>                                                 SCFlsh 548
        <sc;Refrigerant> = <rs:REFRIGERANT>                                     SCFlsh 549
c              suction side                                                     SCFlsh 550
        Jrc          = <sc:LIQUID-CKT>                                          SCFlsh 551
        Jrs          = <rc:/RefgSystem/>                                        SCFlsh 552
        <sc;SucRefg> = <rs:REFRIGERANT>                                         SCFlsh 553
c                                                                               SCFlsh 554
c              Create nodes                                                     SCFlsh 555
      CASE (203)                                                                SCFlsh 556
c              Check for cross-connected systems                                SCFlsh 557
        CALL RefgX(Jsc, <sc:SUBCOOL-CKT>,<sc:SUCTION-CKT>,0)                    SCFlsh 558
c                                                                               SCFlsh 559
c              Attachments on both sides of subcooler                           SCFlsh 560
        Jrs = <sc:/RefgSystem/>                                                 SCFlsh 561
        <sc;SubInNode>  =NewNode(1, Jrs,0,Jsc,<sc:SUBCOOL-CKT>,                 SCFlsh 562
     &                                                     61,1,Jrc, 1.)        SCFlsh 563
        <sc;SubOutNode> =NewNode(1, Jrs,0,Jsc,0,           61,2,Jrc, 1.)        SCFlsh 564
        <sc;SucInNode>  =NewNode(1, Jrs,0,Jsc, <sc:LIQUID-CKT>,                 SCFlsh 565
     &                                                     61,1,Jrc, 1.)        SCFlsh 566
        <sc;SucOutNode> =NewNode(1, Jrs,0,Jsc,<sc:SUCTION-CKT>,                 SCFlsh 567
     &                                                     62,2,Jrc, 1.)        SCFlsh 568
c                                                                               SCFlsh 569
c              Links, lists                                                     SCFlsh 570
      CASE (205)                                                                SCFlsh 571
c              Check if no attachments                                          SCFlsh 572
        Kro = <sc;SubOutNode>                                                   SCFlsh 573
        IF (<ro;Xnode> .EQ. 0)  THEN                                            SCFlsh 574
          CALL MSGSIM(-1,II,II,II,II)                                           SCFlsh 575
          WRITE (IOUTPT,9003) (<sc:NAME>,II=1,8)                                SCFlsh 576
          CALL MessageBox( NULL,                                                SCFlsh 577
     &      'Subcooler must feed at least one liquid circuit'//char(0),         SCFlsh 578
     &      'SUBCOOLER Errors'//char(0),                                        SCFlsh 579
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SCFlsh 580
          IwinReturn = 1                                                        SCFlsh 581
          RETURN                                                                SCFlsh 582
        ENDIF                                                                   SCFlsh 583
c              Get pointer to reference enthalpy                                SCFlsh 584
        <sc;RefgHrefPtr> = IA_RefgHRef(<sc:/RefgSystem/>)                       SCFlsh 585
c                                                                               SCFlsh 586
c              List of nodes                                                    SCFlsh 587
        CALL ListNodes(<sc;Nodes>, 0,0,Jsc,0, 0,0)                              SCFlsh 588
c                                                                               SCFlsh 589
c              Histories                                                        SCFlsh 590
      CASE (208)                                                                SCFlsh 591
        Jrs = <sc:/RefgSystem/>                                                 SCFlsh 592
c              Set up history on subcool outlet conditions                      SCFlsh 593
        Kro = <sc;SubOutNode>                                                   SCFlsh 594
        <sc;SubcoolHsty> = NewHistory(Jrs,0,Jsc, <ro;Xnode>, Kro,               SCFlsh 595
     &                       5, 12, 1.25,                                       SCFlsh 596
     &                       <#ro.Houtlet>, <sp:ERROR-H>, 1,                    SCFlsh 597
     &                       <#ro.Poutlet>, <sp:ERROR-P>, 1,                    SCFlsh 598
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                    SCFlsh 599
c              and on suction                                                   SCFlsh 600
        Kri = <sc;SucInNode>                                                    SCFlsh 601
        Kro = <sc;SucOutNode>                                                   SCFlsh 602
        Kli = 0                                                                 SCFlsh 603
        CALL ListAdd(Kli, <ri;Xnode>)                                           SCFlsh 604
        CALL ListAdd(Kli, <ro;Xnode>)                                           SCFlsh 605
        <sc;SuctionHsty> = NewHistory(Jrs,0,Jsc, Kli, Kro,                      SCFlsh 606
     &                       5, 3, 1.5,                                         SCFlsh 607
     &                       <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                 SCFlsh 608
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)            SCFlsh 609
c                                                                               SCFlsh 610
c              History lists                                                    SCFlsh 611
      CASE (209)                                                                SCFlsh 612
c              All histories associated with this component                     SCFlsh 613
        CALL ListHstys(<sc;Hstys>, 0, 0, Jsc)                                   SCFlsh 614
c                                                                               SCFlsh 615
c              Dump pointers                                                    SCFlsh 616
      CASE (210)                                                                SCFlsh 617
        IF (<sc;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         SCFlsh 618
        WRITE (IOUTPT, 9202)  (<sc:NAME>,II=1,8),                               SCFlsh 619
     &    Jsc, <sc:SUBCOOL-CKT>, <sc;SubInNode>, <sc;SubOutNode>,               SCFlsh 620
     &    <sc;SucInNode>, <sc;SucOutNode>                                       SCFlsh 621
c                                                                               SCFlsh 622
c                                                                               SCFlsh 623
      END SELECT  ! Mode                                                        SCFlsh 624
c                                                                               SCFlsh 625
c                                                                               SCFlsh 626
      RETURN                                                                    SCFlsh 627
c                                                                               SCFlsh 628
c              Message formats                                                  SCFlsh 629
 9001 FORMAT(                                                                   SCFlsh 630
     &14x,'Subcooler: ',8A4,' has a mass capacity'                     /        SCFlsh 631
     &14x,'smaller than the design flow. Flow: ',F10.1,'  Capacity: '  ,        SCFlsh 632
     &F10.1                                                            )        SCFlsh 633
 9002 FORMAT(                                                                   SCFlsh 634
     &14x,'Subcooler: ',8A4,' has a thermal'                           /        SCFlsh 635
     &14x,'capacity smaller than required.  Capacity: ',F10.0          ,        SCFlsh 636
     &'  Design Capacity: ',F10.0                                      )        SCFlsh 637
 9003 FORMAT(                                                                   SCFlsh 638
     &14x,'Subcooler: ',8A4,' has no attached liquid'                  /        SCFlsh 639
     &14x,'circuits. At least one circuit must be attached to the'     /        SCFlsh 640
     &14x,'subcooler discharge, or the subcooler must be removed.'     )        SCFlsh 641
 9201 FORMAT(/                                                                  SCFlsh 642
     &' SUBCOOLERs                             Jsc       Jrc'          ,        SCFlsh 643
     &'       Kri       Kro    Suc In   Suc Out'                       /        SCFlsh 644
     &1x,32('-'),6('  --------'))                                               SCFlsh 645
 9202 FORMAT(1x,8A4,6I10)                                                       SCFlsh 646
      END                                                                       SCFlsh 647
      SUBROUTINE Subcooler_Mechanical(Mode, Jsc)                                SCMech   2
c                                                                               SCMech   3
c              Simulates a mechanical subcooler.  A subcooler                   SCMech   4
c              is always located at the inlet end of a liquid                   SCMech   5
c              refrigerant circuit.                                             SCMech   6
c                                                                               SCMech   7
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
c                                                                               SCMech  15
      COMMON  /REFGKY/ Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 2
     &                 Desuperheat, HoldBack                                    /REFGKY/ 3
      INTEGER          Liquid, Suction, Discharge, Trunk, Branch,               /REFGKY/ 4
     &                 Desuperheat, HoldBack                                    /REFGKY/ 5
c                                                                               SCMech  17
      INTEGER  Xri, Xro, rH                                                     SCMech  18
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             SCMech  19
      REAL     NTU, Mliquid, Msuction, MsuctionMax, Mmax1, Mmax2                SCMech  20
c                                                                               SCMech  21
c                                                                               SCMech  22
      SELECT CASE (Mode)                                                        SCMech  23
c                                                                               SCMech  24
c                                                                               SCMech  25
c ============ HOURLY SIMULATION - LOADS TO PLANT ============================= SCMech  26
      CASE (31)                                                                 SCMech  27
c                                                                               SCMech  28
c              Check if iteration required                                      SCMech  29
      IterNode = IterReqdNode(1, <sc;Nodes>)                                    SCMech  30
      IF (.NOT. IterNode  .AND.                                                 SCMech  31
     &    .NOT. IterReqdHsty(<sc;Hstys>))  RETURN                               SCMech  32
c                                                                               SCMech  33
c              Subcooled liquid side of HX                                      SCMech  34
      Kri = <sc;SubInNode>                                                      SCMech  35
      Xri = <ri;Xnode>                                                          SCMech  36
      Kro = <sc;SubOutNode>                                                     SCMech  37
c                                                                               SCMech  38
c              Get the demands on this circuit                                  SCMech  39
      CALL RefgNode(Kro, <ro.Moutlet>,<ro.Mreqd>, xH, <ro.Treqd>,               SCMech  40
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     SCMech  41
      <ri.Minlet>  = <ro.Moutlet>                                               SCMech  42
      <ri.RunFrac> = <ro.RunFrac>                                               SCMech  43
c                                                                               SCMech  44
c              Requested properties                                             SCMech  45
      <ri.Mreqd>  = <ro.Mreqd>                                                  SCMech  46
      IF (<ri.Mreqd> .GT. 0.)  THEN                                             SCMech  47
c              pressure                                                         SCMech  48
        IF (<ro.Preqd> .LT. -888.)  THEN                                        SCMech  49
          <ri.Preqd> = -88888.                                                  SCMech  50
        ELSE                                                                    SCMech  51
          dP = <sc:SUBCOOL-DP>                                                  SCMech  52
     &       * (<ri.Mreqd>/<ri.RunFrac>*<sc;1/Mliquid>)**1.87                   SCMech  53
          <ri.Preqd> = MIN(<re;Pmax>, <ro.Preqd>+dP)                            SCMech  54
        ENDIF                                                                   SCMech  55
c              temperature - currently modeled as fixed                         SCMech  56
        IF (<ro.Treqd> .LT. -888.)  THEN                                        SCMech  57
          <ri.Treqd> = -88888.                                                  SCMech  58
        ELSE                                                                    SCMech  59
          <ri.Treqd> = MIN(<re;Tmax>, <ro.Treqd>,                               SCMech  60
     &                     RefgT_fP(Jre, <Xri.Pinlet>))                         SCMech  61
        ENDIF                                                                   SCMech  62
      ENDIF                                                                     SCMech  63
c                                                                               SCMech  64
      CALL CnvgCheck(1, <sc;PlantHsty>)                                         SCMech  65
c                                                                               SCMech  66
c                                                                               SCMech  67
c ============ HOURLY SIMULATION - PLANT TO LOADS ============================= SCMech  68
      CASE (32)                                                                 SCMech  69
c                                                                               SCMech  70
c              Check if iteration required                                      SCMech  71
      IterNode = IterReqdNode(1, <sc;Nodes>)                                    SCMech  72
      IF (.NOT. IterNode  .AND.                                                 SCMech  73
     &    .NOT. IterReqdHsty(<sc;Hstys>))  RETURN                               SCMech  74
c                                                                               SCMech  75
c              Subcooled liquid side of HX                                      SCMech  76
      Kri = <sc;SubInNode>                                                      SCMech  77
      Xri = <ri;Xnode>                                                          SCMech  78
      Kro = <sc;SubOutNode>                                                     SCMech  79
      Jre = <sc;Refrigerant>                                                    SCMech  80
c                                                                               SCMech  81
c              Pressure drop through subcooler                                  SCMech  82
      <ri.Pinlet>  = <Xri.Pinlet>                                               SCMech  83
      <ro.Poutlet> = <Xri.Pinlet>   ! if no flow                                SCMech  84
      PliquidOut   = <Xri.Pinlet>   ! if no flow                                SCMech  85
c              Temperatures entering and leaving subcooler                      SCMech  86
      <ri.Tinlet>  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCMech  87
      TliquidIn    = <ri.Tinlet>                                                SCMech  88
      TliquidOut   = <ro.Toutlet>      ! initial; modified below                SCMech  89
c                                                                               SCMech  90
c              Skip if no mass flow                                             SCMech  91
      IF (<ro.Moutlet> .EQ. 0.)  THEN                                           SCMech  92
        Kri = <sc;SucInNode>                                                    SCMech  93
        Xri = <ri;Xnode>                                                        SCMech  94
        Kro = <sc;SucOutNode>                                                   SCMech  95
        Xro = <ro;Xnode>                                                        SCMech  96
        Call MechNoLoad                                                         SCMech  97
        <ro.Moutlet> = 0.                                                       SCMech  98
        <ro.Mreqd>   = 0.                                                       SCMech  99
        RunFrac      = 0.                                                       SCMech 100
        GOTO 3290                                                               SCMech 101
      ENDIF                                                                     SCMech 102
                                                                                SCMech 103
c              Subcooler is operating. If cycling, convert hourly               SCMech 104
c              average refrigerant flow to flow when cycled on                  SCMech 105
c******** Note: RunFrac not debugged ?? ***************                         SCMech 106
      RunFrac = <ro.RunFrac>                                                    SCMech 107
      Mliquid = <ro.Moutlet> / RunFrac                                          SCMech 108
                                                                                SCMech 109
c              Pressure drop through subcooler                                  SCMech 110
      dP = <sc:SUBCOOL-DP> * (Mliquid*<sc;1/Mliquid>)**1.87                     SCMech 111
      <ro.Poutlet> = <ri.Pinlet> - dP                                           SCMech 112
      PliquidOut   = <ro.Poutlet>                                               SCMech 113
                                                                                SCMech 114
c              Liquid film resistance and heat-exchanger UA                     SCMech 115
      Rliquid = <sc;SubcoolFilmR>                                               SCMech 116
     &                 * (Mliquid/<sc;Mliquid>)**<sc;SubcoolFilmE>              SCMech 117
      <sc;UA> = 1. / (Rliquid + <sc;HtExchR> + <sc;SucFilmR>)                   SCMech 118
c                                                                               SCMech 119
c                                                                               SCMech 120
c              Suction side of HX                                               SCMech 121
      Kri = <sc;SucInNode>                                                      SCMech 122
      Xri = <ri;Xnode>                                                          SCMech 123
      Kro = <sc;SucOutNode>                                                     SCMech 124
      Xro = <ro;Xnode>                                                          SCMech 125
      Jre = <sc;SucRefg>                                                        SCMech 126
c                                                                               SCMech 127
c              Start of iterative loop                                          SCMech 128
      Msuction     = <ro.Moutlet> / RunFrac                                     SCMech 129
      <ro.Moutlet> = Msuction                                                   SCMech 130
      ErrorLast    = 0.                                                         SCMech 131
      Damp         = 1.                                                         SCMech 132
 3210 CONTINUE                                                                  SCMech 133
c              Heat-exchanger efficacy; base liquid Cp on average T             SCMech 134
      Tliquid  = (TliquidIn+TliquidOut) * 0.5                                   SCMech 135
      Cpliquid = RefgCp_Liquid_fT(Jre, Tliquid)                                 SCMech 136
      Cmin     = Mliquid * Cpliquid                                             SCMech 137
      NTU      = <sc;UA> / Cmin                                                 SCMech 138
      eff      = 1.0 - EXP(-NTU)                                                SCMech 139
c                                                                               SCMech 140
c              Available suction pressure                                       SCMech 141
      Psuction = <Xro.Poutlet>                                                  SCMech 142
c              Adjust for effect of control valve                               SCMech 143
      Voutlet  = RefgV_fPH(Jre, Psuction, <ro.Houtlet>)                         SCMech 144
      dPctrl   = (Msuction * <sc;1/Msuction>)**1.87                             SCMech 145
     &         * ( Voutlet * <sc;DesignOutletD>)**1.6                           SCMech 146
      dPctrl   = dPctrl * <sc;CtrlValveDP>                                      SCMech 147
      Psuction = Psuction + dPctrl                                              SCMech 148
c              minimum possible suction T at given suction flow                 SCMech 149
      SSTmin   = RefgT_fP(Jre, Psuction)                                        SCMech 150
c                                                                               SCMech 151
c              Outlet temperature and load                                      SCMech 152
      SELECT CASE (<sc:TEMP-CTRL>)                                              SCMech 153
c                                                                               SCMech 154
        CASE (1)    ! Floating                                                  SCMech 155
          <sc;Tsetpt> = -888.                                                   SCMech 156
          IF (TliquidIn .LE. SSTmin)  THEN                                      SCMech 157
c              entering liquid is colder than suction - no load                 SCMech 158
            <ro.Mreqd> = 0.                                                     SCMech 159
            Call MechNoLoad                                                     SCMech 160
          ELSE                                                                  SCMech 161
c              subcooler load and subcooled liquid T                            SCMech 162
            SST = SSTmin                                                        SCMech 163
            Call MechLoad                                                       SCMech 164
c              required suction flow and pressure                               SCMech 165
            <ro.Mreqd> = Msuction                                               SCMech 166
            dT         = TliquidOut - SST                                       SCMech 167
            <ro.Preqd> = RefgP_fT(Jre, <sc:DES-SUBCOOL-T>-dT)                   SCMech 168
          ENDIF  ! TliquidIn                                                    SCMech 169
c                                                                               SCMech 170
        CASE (4:5)  ! Local EPR                                                 SCMech 171
c              get desired liquid setpoint                                      SCMech 172
          SELECT CASE (<sc:TEMP-CTRL>)                                          SCMech 173
            CASE (4)  ! Local EPR                                               SCMech 174
              <sc;Tsetpt> = <sc:TEMP-SETPT>                                     SCMech 175
            CASE (5)  ! Local EPR w/ schedule                                   SCMech 176
              <sc;Tsetpt> = SchVal(<sc:TEMP-SETPT-SC>)                          SCMech 177
          END SELECT                                                            SCMech 178
c              Suction setpoint is liquid setpoint minus the design             SCMech 179
c              EPR differential                                                 SCMech 180
          SSTset = <sc;Tsetpt> - <sc;EPRoffset>                                 SCMech 181
          SSPset = RefgP_fT(Jre, SSTset)                                        SCMech 182
c              Given the setpoint, see if subcooling necessary                  SCMech 183
          IF (TliquidIn .LE. SSTset)  THEN                                      SCMech 184
c              entering liquid is colder than suction setpoint - no load        SCMech 185
            <ro.Mreqd> = 0.                                                     SCMech 186
            Call MechNoLoad                                                     SCMech 187
          ELSE                                                                  SCMech 188
c                 required suction conditions                                   SCMech 189
            Call MechReqdLoad                                                   SCMech 190
            <ro.Preqd> = MAX(<ro.Preqd>, SSPset-dPctrl)                         SCMech 191
            IF (SSTmin .GE. TliquidIn)  THEN                                    SCMech 192
c                 suction is warmer than entering liquid - no load              SCMech 193
              Call MechNoLoad                                                   SCMech 194
            ELSE                                                                SCMech 195
c                 subcooler load and subcooled liquid T                         SCMech 196
              SST = MAX(SSTmin, SSTset)                                         SCMech 197
              Call MechLoad                                                     SCMech 198
            ENDIF  ! SSTmin                                                     SCMech 199
          ENDIF  ! TliquidIn                                                    SCMech 200
c                                                                               SCMech 201
        CASE DEFAULT  ! Thermostatic control schemes                            SCMech 202
          SELECT CASE (<sc:TEMP-CTRL>)                                          SCMech 203
            CASE (2)  ! Thermostat                                              SCMech 204
              <sc;Tsetpt> = <sc:TEMP-SETPT>                                     SCMech 205
            CASE (3)  ! Thermostat schedule                                     SCMech 206
              <sc;Tsetpt> = SchVal(<sc:TEMP-SETPT-SC>)                          SCMech 207
            CASE (6)  ! Saturation differential                                 SCMech 208
              <sc;Tsetpt> = RefgT_fP(Jre,PliquidOut)-<sc:SATURATION-DT>         SCMech 209
            CASE (7)  ! Load reset                                              SCMech 210
              <sc;Tsetpt> = <ro.Treqd> - <sc:SATURATION-DT>                     SCMech 211
          END SELECT                                                            SCMech 212
c              Given the setpoint, see if subcooling necessary                  SCMech 213
          IF (TliquidIn .LE. <sc;Tsetpt>)  THEN                                 SCMech 214
c              entering liquid is colder than liquid setpoint - no load         SCMech 215
            <ro.Mreqd> = 0.                                                     SCMech 216
            Call MechNoLoad                                                     SCMech 217
          ELSE                                                                  SCMech 218
c              required suction conditions                                      SCMech 219
            Call MechReqdLoad                                                   SCMech 220
            IF (SSTmin .GE. TliquidIn)  THEN                                    SCMech 221
c                 suction is warmer than entering liquid - no load              SCMech 222
              Call MechNoLoad                                                   SCMech 223
            ELSE                                                                SCMech 224
              SST = MAX(SSTmin, SSTreqd)                                        SCMech 225
              Call MechLoad                                                     SCMech 226
            ENDIF  ! SSTmin                                                     SCMech 227
          ENDIF  ! TliquidIn                                                    SCMech 228
      END SELECT  ! sc:TEMP-CTRL                                                SCMech 229
c                                                                               SCMech 230
c              Check if converged                                               SCMech 231
      Error = <ro.Moutlet> - Msuction                                           SCMech 232
      IF (Error*ErrorLast .lt. 0.) THEN  ! oscillating                          SCMech 233
        IF (Error/ErrorLast .lt. -0.5) THEN  ! slow convergence                 SCMech 234
          Damp = Damp * 0.7                                                     SCMech 235
        ENDIF                                                                   SCMech 236
      ENDIF                                                                     SCMech 237
      Error        = Error * Damp                                               SCMech 238
      <ro.Moutlet> = <ro.Moutlet> - Error                                       SCMech 239
      ErrorLast    = Error                                                      SCMech 240
      IF (Msuction .GT. 0.000001)  THEN                                         SCMech 241
        IF (ABS(Error/Msuction) .GT. <sp:ERROR-FLOW>)  GOTO 3210                SCMech 242
      ENDIF                                                                     SCMech 243
c              Pressure as regulated by temperature control valve               SCMech 244
      Pctrl = RefgP_fT(Jre, MAX(SST, SSTmin))                                   SCMech 245
c                                                                               SCMech 246
c              Check load-based flow against pressure-based flow                SCMech 247
      IF (Msuction .GT. 0.)  THEN                                               SCMech 248
c              Maximum suction flow across subcooler                            SCMech 249
        dP    = MAX(0., <Xri.Pinlet> - <Xro.Poutlet>)                           SCMech 250
        Mmax1 = <sc;Msuction> * (dP*<sc;1/dPsupply>)**(1./1.87)                 SCMech 251
c              Maximum suction flow, inlet to control valve                     SCMech 252
        dP    = MAX(0., <Xri.Pinlet> - Pctrl)                                   SCMech 253
        Mmax2 = <sc;Msuction> * (dP/<sc;1/dPsupplyIn>)**(1./1.87)               SCMech 254
        MsuctionMax = MIN(Mmax1, Mmax2)                                         SCMech 255
c ??           Superheat TXV                                                    SCMech 256
c ??           makes code unstable                                              SCMech 257
c ??    dTsuperMax = TliquidIn - 1. - SST                                       SCMech 258
c ??    IF (<sc:SUPERHEAT-DT> .GT. dTsuperMax)  THEN                            SCMech 259
c              Not enough superheat; modulate flow over a 2F band               SCMech 260
c ??      Mmax1       = Msuction * dTsuperMax/<sc:SUPERHEAT-DT>                 SCMech 261
c ??      MsuctionMax = MIN(MsuctionMax, Mmax1)                                 SCMech 262
c ??    ENDIF                                                                   SCMech 263
c              Check if the load-based suction flow is greater than             SCMech 264
c              what the liquid/suction pressure differential permits            SCMech 265
        IF (Msuction .GT. MsuctionMax)  THEN                                    SCMech 266
          IF (MsuctionMax .EQ. 0.)  THEN                                        SCMech 267
            Call MechNoLoad                                                     SCMech 268
          ELSE                                                                  SCMech 269
            Msuction = MsuctionMax                                              SCMech 270
c              Suction pressure, adjusted for control valve                     SCMech 271
            dP       = (Msuction * <sc;1/Msuction>)**1.87                       SCMech 272
     &               * ( Voutlet * <sc;DesignOutletD>)**1.6                     SCMech 273
            dP       = dP * <sc;CtrlValveDP>                                    SCMech 274
            Psuction = <Xro.Poutlet> + dP                                       SCMech 275
            SSTmin   = RefgT_fP(Jre, Psuction)                                  SCMech 276
            SELECT CASE (<sc:TEMP-CTRL>)                                        SCMech 277
              CASE (4:5)  ! Local EPR                                           SCMech 278
                SST = MAX(SSTmin, SSTset)                                       SCMech 279
              CASE DEFAULT                                                      SCMech 280
                SST = SSTmin                                                    SCMech 281
            END SELECT                                                          SCMech 282
c              Maximum possible heat transfer, assuming the refg                SCMech 283
c              temperature approaches the liquid inlet temperature              SCMech 284
            dTsuper      = (TliquidIn-SST) * 0.9                                SCMech 285
            <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SST, dTsuper)                   SCMech 286
            QhxMax       = Msuction * (<ro.Houtlet>-<Xri.Hinlet>)               SCMech 287
c              skip if the extra superheat can handle load                      SCMech 288
            IF (QhxMax .GE. <sc;Qsubcool>)  THEN                                SCMech 289
              <ro.Houtlet> = <Xri.Hinlet> + <sc;Qsubcool>/Msuction              SCMech 290
            ELSE                                                                SCMech 291
              <sc;Qsubcool> = QhxMax                                            SCMech 292
              TliquidOut    = TliquidIn - <sc;Qsubcool>/Cmin                    SCMech 293
            ENDIF                                                               SCMech 294
          ENDIF                                                                 SCMech 295
        ENDIF  ! ro,Moutlet .gt. MsuctionMax                                    SCMech 296
      ENDIF  ! ro,Moutlet .gt. 0.                                               SCMech 297
c                                                                               SCMech 298
c              Liquid inlet requirements                                        SCMech 299
 3290 <sc;Qsubcool> = <sc;Qsubcool> * RunFrac                                   SCMech 300
      <ro.Moutlet>  = Msuction      * RunFrac                                   SCMech 301
      <ri.Minlet>   = <ro.Moutlet>                                              SCMech 302
      dP         = <sc:SUCTION-DP> * (<ro.Mreqd>*<sc;1/Msuction>)**1.87         SCMech 303
      <ri.Preqd> = MIN(<re;Pmax>, Pctrl + dP)                                   SCMech 304
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCMech 305
      <ro.Mreqd> = <ro.Mreqd> * RunFrac                                         SCMech 306
      <ri.Mreqd> = <ro.Mreqd>                                                   SCMech 307
c                                                                               SCMech 308
      CALL CnvgCheck(1, <sc;SuctionHsty>)                                       SCMech 309
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<sc;SuRefgHrefPtr>))        SCMech 310
      <ro.Qoutlet> = <ri.Qinlet> + <sc;Qsubcool>                                SCMech 311
c                                                                               SCMech 312
c              Subcooled liquid                                                 SCMech 313
      Kri = <sc;SubInNode>                                                      SCMech 314
      Xri = <ri;Xnode>                                                          SCMech 315
      Kro = <sc;SubOutNode>                                                     SCMech 316
      IF (<ro.Moutlet> .GT. 0.)  THEN                                           SCMech 317
        <ro.Toutlet> = TliquidOut                                               SCMech 318
        <ro.Houtlet> = <Xri.Hinlet> - <sc;Qsubcool>/<ro.Moutlet>                SCMech 319
      ENDIF                                                                     SCMech 320
      CALL CnvgCheck(1, <sc;SubcoolHsty>)                                       SCMech 321
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<sc;RefgHrefPtr>))          SCMech 322
      <ro.Qoutlet> = <ri.Qinlet> - <sc;Qsubcool>                                SCMech 323
c                                                                               SCMech 324
c                                                                               SCMech 325
c ============ REPORT CREATION ================================================ SCMech 326
      CASE (50)                                                                 SCMech 327
c                                                                               SCMech 328
c              statistics blocks                                                SCMech 329
      Ks2Load     = NewStat2(Jsc, <+sc;Qsubcool>, 0, 1.)                        SCMech 330
      Ks5LoadBin  = NewStat5(Jsc, <+sc;Qsubcool>, 0, 1.)                        SCMech 331
      Ks2Msubc    = NewStat2(<sc;SubInNode>, <+ri.Minlet>, 0, 1.)               SCMech 332
      Ks5MsubcBin = NewStat5(<sc;SubInNode>, <+ri.Minlet>, 0, 1.)               SCMech 333
      Ks2Msuct    = NewStat2(<sc;SucInNode>, <+ri.Minlet>, 0, 1.)               SCMech 334
      Ks5MsuctBin = NewStat5(<sc;SucInNode>, <+ri.Minlet>, 0, 1.)               SCMech 335
c                                                                               SCMech 336
c              Create the type "H" report                                       SCMech 337
      IF (<sc:REPORTS> .GT. 0  .AND.  IREPRT(3,23) .GT. 0)                      SCMech 338
     &  <sc;PS-H> = NewReport_H(Jsc, 137,                                       SCMech 339
     &                          4, 5, 6,                                        SCMech 340
     &                          Ks2Load, Ks2Msubc, Ks2Msuct, 0,                 SCMech 341
     &                          Ks5LoadBin, Ks5MsubcBin, Ks5MsuctBin,           SCMech 342
     &                          0, 0, 0)                                        SCMech 343
c                                                                               SCMech 344
c                                                                               SCMech 345
c ============ REPORT ORDER =================================================== SCMech 346
      CASE (52)                                                                 SCMech 347
c                                                                               SCMech 348
      Call Report_H(Mode, <sc;PS-H>)                                            SCMech 349
c                                                                               SCMech 350
c                                                                               SCMech 351
c ============ REPORTS - VERIFICATION DATA ==================================== SCMech 352
      CASE (54)                                                                 SCMech 353
c                                                                               SCMech 354
c              Output design information                                        SCMech 355
      IF (<sc;PS-H> .ne. 0)  THEN                                               SCMech 356
        rH = <sc;PS-H>                                                          SCMech 357
        WRITE (IREPFL) 4,<rH;Iuniq>,1,1,0                                       SCMech 358
        CALL GetAttachments(Jsc, 2)                                             SCMech 359
        WRITE (IREPFL)  25,<rH;Iuniq>,1,2,21,                                   SCMech 360
     &    (NameAttachments(II,1,1),II=1,8),                                     SCMech 361
     &    (NameAttachments(II,1,2),II=1,8),                                     SCMech 362
     &    <sc;Capacity>,<sc;Mliquid>,<sc;Msuction>,<sc:DES-SUBCOOL-T>,          SCMech 363
     &    <sc;DesignUA>                                                         SCMech 364
        DO  Irow=2,NumRowsOfAttachments                                         SCMech 365
          WRITE (IREPFL)  20,<rH;Iuniq>,1,3,16,                                 SCMech 366
     &      (NameAttachments(II,Irow,1),II=1,8),                                SCMech 367
     &      (NameAttachments(II,Irow,2),II=1,8)                                 SCMech 368
        ENDDO                                                                   SCMech 369
      ENDIF                                                                     SCMech 370
c                                                                               SCMech 371
c                                                                               SCMech 372
c ============ HOURLY REPORTS - HOURLY DATA =================================== SCMech 373
      CASE (62)                                                                 SCMech 374
c                                                                               SCMech 375
c              Hourly-report variables                                          SCMech 376
      IF (<sc;HourRepBuf> .EQ. 0)  RETURN                                       SCMech 377
c                                                                               SCMech 378
      IAptr        = <sc;HourRepBuf> - 1                                        SCMech 379
      AA(IAptr+1)  = <sc;Qsubcool>                                              SCMech 380
      AA(IAptr+2)  = <sc;Tsetpt>                                                SCMech 381
      AA(IAptr+3)  = <sc;UA>                                                    SCMech 382
c              subcooled inlet                                                  SCMech 383
      Kri          = <sc;SubInNode>                                             SCMech 384
      Xri          = <ri;Xnode>                                                 SCMech 385
      AA(IAptr+4)  = <ri.Qinlet>                                                SCMech 386
      AA(IAptr+5)  = <ri.Minlet>                                                SCMech 387
      AA(IAptr+6)  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCMech 388
      AA(IAptr+7)  = <Xri.Pinlet>                                               SCMech 389
      AA(IAptr+8)  = <ri.Preqd>                                                 SCMech 390
      AA(IAptr+9)  = <Xri.Hinlet>                                               SCMech 391
c              subcooled outlet                                                 SCMech 392
      Kro          = <sc;SubOutNode>                                            SCMech 393
      AA(IAptr+10) = <ro.Qoutlet>                                               SCMech 394
      AA(IAptr+11) = <ro.Moutlet>                                               SCMech 395
c     AA(IAptr+12) = unused                                                     SCMech 396
      AA(IAptr+13) = <ro.Toutlet>                                               SCMech 397
      AA(IAptr+14) = <ro.Treqd>                                                 SCMech 398
      AA(IAptr+15) = <ro.Poutlet>                                               SCMech 399
      AA(IAptr+16) = <ro.Preqd>                                                 SCMech 400
      AA(IAptr+17) = <ro.Houtlet>                                               SCMech 401
c              suction inlet                                                    SCMech 402
      Kri          = <sc;SucInNode>                                             SCMech 403
      Xri          = <ri;Xnode>                                                 SCMech 404
      AA(IAptr+18) = <ri.Qinlet>                                                SCMech 405
      AA(IAptr+19) = <ri.Minlet>                                                SCMech 406
      AA(IAptr+20) = <Xri.Pinlet>                                               SCMech 407
      AA(IAptr+21) = <ri.Preqd>                                                 SCMech 408
      AA(IAptr+22) = <Xri.Hinlet>                                               SCMech 409
c              suction outlet                                                   SCMech 410
      Kro          = <sc;SucOutNode>                                            SCMech 411
      Xro          = <ro;Xnode>                                                 SCMech 412
      AA(IAptr+23) = <ro.Qoutlet>                                               SCMech 413
      AA(IAptr+24) = <ro.Moutlet>                                               SCMech 414
      AA(IAptr+25) = <Xro.Poutlet>                                              SCMech 415
      AA(IAptr+26) = <ro.Preqd>                                                 SCMech 416
      AA(IAptr+27) = <ro.Houtlet>                                               SCMech 417
c                                                                               SCMech 418
c                                                                               SCMech 419
c ============ DESIGN CALCULATIONS - LOADS TO PLANT =========================== SCMech 420
      CASE (111)                                                                SCMech 421
c                                                                               SCMech 422
c              Subcooled liquid side of HX                                      SCMech 423
      Kri = <sc;SubInNode>                                                      SCMech 424
      Xri = <ri;Xnode>                                                          SCMech 425
      Kro = <sc;SubOutNode>                                                     SCMech 426
      Jre = <sc;Refrigerant>                                                    SCMech 427
c                                                                               SCMech 428
c              Set iteration flag on inlet                                      SCMech 429
      <Xri.IterFlag> = Jsc                                                      SCMech 430
c                                                                               SCMech 431
c              Design mass flow of demanders                                    SCMech 432
      CALL RefgNode(Kro, <ro.Moutlet>,xMreqd,xH, <ro.Treqd>,                    SCMech 433
     &                   xPmin,xPmax, xPminReqd,<ro.Preqd>)                     SCMech 434
c                                                                               SCMech 435
c              Flow                                                             SCMech 436
      <ri.Minlet> = <ro.Moutlet>                                                SCMech 437
      <ri.Mreqd>  = <ro.Moutlet>                                                SCMech 438
c                                                                               SCMech 439
c              Capacity                                                         SCMech 440
      dHliquid = MAX(2., <Xri.Hinlet>-<ro.Houtlet>)                             SCMech 441
      Qsubcool = <ri.Minlet> * dHliquid                                         SCMech 442
      IF (<sc:CAPACITY> .NE. 0.)  THEN                                          SCMech 443
        <sc;Capacity> = <sc:CAPACITY>                                           SCMech 444
      ELSE                                                                      SCMech 445
        <sc;Capacity> = Qsubcool                                                SCMech 446
      ENDIF                                                                     SCMech 447
c                                                                               SCMech 448
c              Required inlet pressure, adjusted for HX friction                SCMech 449
      dP = <sc:SUBCOOL-DP>                                                      SCMech 450
      IF (<sc:FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)                        SCMech 451
     &  dP = dP * (<ri.Minlet>/<sc:FLOW>)**1.87                                 SCMech 452
      <ri.Preqd> = <ro.Preqd> + dP                                              SCMech 453
c              required inlet temperature                                       SCMech 454
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCMech 455
c                                                                               SCMech 456
c                                                                               SCMech 457
c              Suction side of HX                                               SCMech 458
      Kri = <sc;SucInNode>                                                      SCMech 459
      Xri = <ri;Xnode>                                                          SCMech 460
      Kro = <sc;SucOutNode>                                                     SCMech 461
      Xro = <ro;Xnode>                                                          SCMech 462
      Jre = <sc;SucRefg>                                                        SCMech 463
c                                                                               SCMech 464
c              Refrigerant conditions at outlet to suction                      SCMech 465
      SSTreqd      = <sc:DES-SUBCOOL-T> - <sc:SST-SUBCOOL-T>                    SCMech 466
      SSTreqd      = MIN(SSTreqd, <Xri.Tinlet>-(<sc:SUPERHEAT-DT>+1.))          SCMech 467
      <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SSTreqd, <sc:SUPERHEAT-DT>)           SCMech 468
      dHsuction    = MAX(20., <ro.Houtlet> - <Xri.Hinlet>)                      SCMech 469
      <ro.Moutlet> = Qsubcool / dHsuction                                       SCMech 470
      <ri.Minlet>  = <ro.Moutlet>                                               SCMech 471
      <ri.Mreqd>   = <ro.Moutlet>                                               SCMech 472
      <ro.Mreqd>   = <ro.Moutlet>                                               SCMech 473
      <ro.Preqd>   = RefgP_fT(Jre, SSTreqd)                                     SCMech 474
c              effect of control valve                                          SCMech 475
      IF (<sc:CTRL-VALVE-DT> .EQ. 0.)  THEN                                     SCMech 476
        dPctrl = 0.                                                             SCMech 477
      ELSE                                                                      SCMech 478
        dPctrl = <ro.Preqd> - RefgP_fT(Jre, SSTreqd-<sc:CTRL-VALVE-DT>)         SCMech 479
        IF (<sc:SUCTION-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)             SCMech 480
     &    dPctrl   = dPctrl * (<ro.Moutlet>/<sc:SUCTION-FLOW>)**1.87            SCMech 481
        <ro.Preqd> = <ro.Preqd> - dPctrl                                        SCMech 482
        <sc;CtrlValveDP> = dPctrl                                               SCMech 483
      ENDIF                                                                     SCMech 484
c                                                                               SCMech 485
c              Check for convergence on outlet conditions                       SCMech 486
      CALL CnvgCheck(1, <sc;SuctionHsty>)                                       SCMech 487
c                                                                               SCMech 488
c              Refrigerant conditions at liquid inlet                           SCMech 489
      dP          = <sc:SUCTION-DP>                                             SCMech 490
      IF (<sc:SUCTION-FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)                SCMech 491
     &  dP = dP * (<ri.Minlet>/<sc:SUCTION-FLOW>)**1.87                         SCMech 492
      <ri.Preqd> = <ro.Preqd> + dP + dPctrl                                     SCMech 493
c              Liquid should be delivered no warmer than saturation             SCMech 494
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  SCMech 495
c                                                                               SCMech 496
      IF (<sc:SUCTION-FLOW> .GT. 0.)  THEN                                      SCMech 497
        <sc;Msuction> = <sc:SUCTION-FLOW>                                       SCMech 498
      ELSE                                                                      SCMech 499
        <sc;Msuction> = <ro.Moutlet>                                            SCMech 500
      ENDIF                                                                     SCMech 501
c                                                                               SCMech 502
c                                                                               SCMech 503
c ============ DESIGN CALCULATIONS - PLANT TO LOADS =========================== SCMech 504
      CASE (112)                                                                SCMech 505
c                                                                               SCMech 506
c              Subcooled liquid side of HX                                      SCMech 507
      Kri = <sc;SubInNode>                                                      SCMech 508
      Xri = <ri;Xnode>                                                          SCMech 509
      Kro = <sc;SubOutNode>                                                     SCMech 510
      Jre = <sc;Refrigerant>                                                    SCMech 511
c                                                                               SCMech 512
c              Adjust for pressure loss                                         SCMech 513
      <ri.Pinlet> = <Xri.Pinlet>                                                SCMech 514
      IF (<sc:FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)  THEN                  SCMech 515
        dP = <sc:SUBCOOL-DP> * (<ri.Minlet>/<sc:FLOW>)**1.87                    SCMech 516
      ELSE                                                                      SCMech 517
        dP = <sc:SUBCOOL-DP>                                                    SCMech 518
      ENDIF                                                                     SCMech 519
      <ro.Poutlet> = <ri.Pinlet> - dP                                           SCMech 520
c                                                                               SCMech 521
c              Adjust outlet conditions for subcooling effect                   SCMech 522
      <ri.Tinlet>  = RefgT_fPH(Jre, <Xri.Pinlet>,<Xri.Hinlet>)                  SCMech 523
      <ro.Toutlet> = MIN(<sc:DES-SUBCOOL-T>, <ri.Tinlet>)                       SCMech 524
      <ro.Houtlet> = RefgH_Liquid_fTP(Jre, <ro.Toutlet>, <ro.Poutlet>)          SCMech 525
c                                                                               SCMech 526
c              Liquid flow                                                      SCMech 527
      IF (<sc:FLOW> .GT. 0.)  THEN                                              SCMech 528
        <sc;Mliquid> = <sc:FLOW>                                                SCMech 529
      ELSE                                                                      SCMech 530
        dHliquid      = MAX(1., <Xri.Hinlet>-<ro.Houtlet>)                      SCMech 531
        <sc;Mliquid> = <sc;Capacity> / dHliquid                                 SCMech 532
      ENDIF                                                                     SCMech 533
c                                                                               SCMech 534
c                                                                               SCMech 535
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== SCMech 536
      CASE (119)                                                                SCMech 537
c                                                                               SCMech 538
      IF (<sc;Mliquid>  .GT. 0.)  <sc;1/Mliquid>  = 1.0 / <sc;Mliquid>          SCMech 539
      IF (<sc;Msuction> .GT. 0.)  <sc;1/Msuction> = 1.0 / <sc;Msuction>         SCMech 540
c                                                                               SCMech 541
c              Subcooled liquid side of HX                                      SCMech 542
      Kri = <sc;SubInNode>                                                      SCMech 543
      Xri = <ri;Xnode>                                                          SCMech 544
      Kro = <sc;SubOutNode>                                                     SCMech 545
      Jre = <sc;Refrigerant>                                                    SCMech 546
c              warn if insufficient mass flow capacity                          SCMech 547
      IF (<ri.Minlet> .GT. <sc;Mliquid>*1.01)  THEN                             SCMech 548
        CALL MSGSIM(-2,II,II,II,II)                                             SCMech 549
        WRITE (IOUTPT, 9001)  (<sc:NAME>,II=1,8),                               SCMech 550
     &                         <ri.Minlet>, <sc;Mliquid>                        SCMech 551
      ENDIF                                                                     SCMech 552
c              warn if insufficient thermal capacity                            SCMech 553
      Qsubcool = <ri.Minlet> * (<Xri.Hinlet>-<ro.Houtlet>)                      SCMech 554
      IF (Qsubcool .GT. <sc;Capacity>*1.01)  THEN                               SCMech 555
        CALL MSGSIM(-2,II,II,II,II)                                             SCMech 556
        WRITE (IOUTPT, 9002)  (<sc:NAME>,II=1,8),                               SCMech 557
     &                         Qsubcool, <sc;Capacity>                          SCMech 558
      ENDIF                                                                     SCMech 559
      <sc;Qsubcool> = <sc;Capacity>                                             SCMech 560
c              error if no load                                                 SCMech 561
      IF (<sc;Mliquid>*<sc;Capacity> .eq. 0.)  THEN                             SCMech 562
        CALL MSGSIM(-1,II,II,II,II)                                             SCMech 563
        WRITE (IOUTPT,9007) (<sc:NAME>,II=1,8)                                  SCMech 564
        CALL MessageBox( NULL,                                                  SCMech 565
     &    'Subcooler has no design load'//char(0),                              SCMech 566
     &    'SUBCOOLER Errors'//char(0),                                          SCMech 567
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  SCMech 568
        IwinReturn = 1                                                          SCMech 569
        RETURN                                                                  SCMech 570
      ENDIF                                                                     SCMech 571
c                                                                               SCMech 572
c              Liquid temperature drop and inlets TD                            SCMech 573
      dTliquid = <Xri.Tinlet> - <ro.Toutlet>                                    SCMech 574
c              error if no liquid temperature drop                              SCMech 575
      IF (dTliquid .le. 0.)  THEN                                               SCMech 576
        CALL MSGSIM(-1,II,II,II,II)                                             SCMech 577
        WRITE (IOUTPT,9008) (<sc:NAME>,II=1,8), dTliquid                        SCMech 578
        CALL MessageBox( NULL,                                                  SCMech 579
     &    'Subcooler has no design liquid temperature drop'//char(0),           SCMech 580
     &    'SUBCOOLER Errors'//char(0),                                          SCMech 581
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  SCMech 582
        IwinReturn = 1                                                          SCMech 583
        RETURN                                                                  SCMech 584
      ENDIF                                                                     SCMech 585
c              Liquid inlets TD                                                 SCMech 586
      dTinlets = MAX(10., <sc:SST-SUBCOOL-T> + dTliquid)                        SCMech 587
c              base specific heat on average conditions                         SCMech 588
      CpLiquid = <sc;Capacity> / (<sc;Mliquid> * dTliquid)                      SCMech 589
c                                                                               SCMech 590
c                                                                               SCMech 591
c              Suction side of HX                                               SCMech 592
      Kri = <sc;SucInNode>                                                      SCMech 593
      Xri = <ri;Xnode>                                                          SCMech 594
      Kro = <sc;SucOutNode>                                                     SCMech 595
      Xro = <ro;Xnode>                                                          SCMech 596
      Jre = <sc;SucRefg>                                                        SCMech 597
c              Design volume and density at outlet                              SCMech 598
      <sc;DesignOutletV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)          SCMech 599
      <sc;DesignOutletD> = 1.0 / <sc;DesignOutletV>                             SCMech 600
c              Pressure drops thru suction side                                 SCMech 601
      <sc;1/dPsupplyIn> = 1. / <sc:SUCTION-DP>                                  SCMech 602
      <sc;1/dPsupply>   = 1. / (<sc:SUCTION-DP>+<sc;CtrlValveDP>)               SCMech 603
c                                                                               SCMech 604
c                                                                               SCMech 605
c              Design the heat exchanger                                        SCMech 606
      IF (<sc:HX-UA>  .NE. 0.)  THEN                                            SCMech 607
        <sc;DesignUA> = <sc:HX-UA>                                              SCMech 608
      ELSE                                                                      SCMech 609
c              initialize the UA to the ideal                                   SCMech 610
        <sc;DesignUA> = <sc;Capacity> / dTinlets                                SCMech 611
c              minimum capacity rate                                            SCMech 612
        Cmin = <sc;Mliquid> * CpLiquid                                          SCMech 613
c              iterate to solve for UA                                          SCMech 614
        DO  Iter=1,100                                                          SCMech 615
c              transfer units, effectiveness (phase change one side), and       SCMech 616
c              heat transfer for this size hx                                   SCMech 617
          NTU      = <sc;DesignUA> / Cmin                                       SCMech 618
          eff      = 1.0 - EXP(-NTU)                                            SCMech 619
          Qsubcool = eff * Cmin * dTinlets                                      SCMech 620
c              see if converged on UA                                           SCMech 621
          Error = (Qsubcool-<sc;Capacity>) / <sc;Capacity>                      SCMech 622
          IF (ABS(Error) .LT. 0.001)  EXIT                                      SCMech 623
c              solution not converged yet - make new estimate                   SCMech 624
          <sc;DesignUA> = <sc;DesignUA> * <sc;Capacity>/Qsubcool                SCMech 625
          IF (Iter .EQ. 100)  THEN                                              SCMech 626
c              convergence has failed after 100 iterations                      SCMech 627
            CALL MSGSIM(-1,II,II,II,II)                                         SCMech 628
            WRITE (IOUTPT, 9004)  (<sc:NAME>,II=1,8)                            SCMech 629
            CALL MessageBox( NULL,                                              SCMech 630
     &        'Convergence failure in UA calculation'//char(0),                 SCMech 631
     &        'SUBCOOLER Errors'//char(0),                                      SCMech 632
     &        MB_OK + MB_ICONSTOP + MB_TASKMODAL )                              SCMech 633
            IwinReturn = 1                                                      SCMech 634
            RETURN                                                              SCMech 635
          ENDIF                                                                 SCMech 636
        ENDDO                                                                   SCMech 637
      ENDIF                                                                     SCMech 638
c                                                                               SCMech 639
c              Break down UA into its components                                SCMech 640
      Resistance        = 1. / <sc;DesignUA>                                    SCMech 641
      <sc;SubcoolFilmR> = Resistance * <sc:SUBCOOL-FILM>                        SCMech 642
      <sc;SucFilmR>     = Resistance * <sc:SUCTION-FILM>                        SCMech 643
      <sc;HtExchR>      = Resistance                                            SCMech 644
     &                           - (<sc;SubcoolFilmR>+<sc;SucFilmR>)            SCMech 645
c              and check resistances for consistency                            SCMech 646
      IF (<sc;HtExchR> .LT. 0.)  THEN                                           SCMech 647
        CALL MSGSIM(-1,II,II,II,II)                                             SCMech 648
        WRITE (IOUTPT, 9005)  (<sc:NAME>,II=1,8)                                SCMech 649
        CALL MessageBox( NULL,                                                  SCMech 650
     &    'Inconsistent internal/external resistances'//char(0),                SCMech 651
     &    'SUBCOOLER Errors'//char(0),                                          SCMech 652
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  SCMech 653
        IwinReturn = 1                                                          SCMech 654
        RETURN                                                                  SCMech 655
      ENDIF                                                                     SCMech 656
c              make film resistance coefs negative for faster                   SCMech 657
c              hourly computation (can multiply instead of divide)              SCMech 658
      <sc;SubcoolFilmE> = -<sc:SUBCOOL-EXP>                                     SCMech 659
c                                                                               SCMech 660
c              For EPR, offset between liquid setpoint and SST                  SCMech 661
      SELECT CASE (<sc:TEMP-CTRL>)                                              SCMech 662
        CASE (4:5)  ! Local EPR                                                 SCMech 663
          Kri = <sc;SubInNode>           ! Liquid inlet                         SCMech 664
c              effectiveness at rated flow                                      SCMech 665
          Cmin     = <sc;Mliquid> * CpLiquid                                    SCMech 666
          NTU      = <sc;DesignUA> / Cmin                                       SCMech 667
          effRated = 1.0 - EXP(-NTU)                                            SCMech 668
c              effectiveness at design flow with modified liquid film           SCMech 669
          Rliquid  = <sc;SubcoolFilmR>                                          SCMech 670
     &                 * (<ri.Minlet>/<sc;Mliquid>)**<sc;SubcoolFilmE>          SCMech 671
          <sc;UA>  = 1. / (Rliquid + <sc;HtExchR> + <sc;SucFilmR>)              SCMech 672
          Cmin     = <ri.Minlet> * CpLiquid                                     SCMech 673
          NTU      = <sc;UA> / Cmin                                             SCMech 674
          eff      = 1.0 - EXP(-NTU)                                            SCMech 675
          <sc;EPRoffset> = <sc:SST-SUBCOOL-T> * effRated/eff                    SCMech 676
      END SELECT  ! sc:TEMP-CTRL                                                SCMech 677
c                                                                               SCMech 678
c                                                                               SCMech 679
c ============ ATTACHMENTS ==================================================== SCMech 680
c                                                                               SCMech 681
c              Initial attachments                                              SCMech 682
      CASE (201)                                                                SCMech 683
c              Component pointers, schedules, and curves                        SCMech 684
        <sc:COST-DATA>     = Jcomponent(18, <sc:COST-DATA>)                     SCMech 685
        <sc:TEMP-SETPT-SC> = Jsched(<sc:TEMP-SETPT-SC>)                         SCMech 686
        <sc:REFG-SYSTEM>   = Jcomponent(29, <sc:REFG-SYSTEM>)                   SCMech 687
        <sc:/RefgSystem/>  = Jcomponent(29, <sc:/RefgSystem/>)                  SCMech 688
        <sc:SUCTION-CKT>   = Jcomponent(22, <sc:SUCTION-CKT>)                   SCMech 689
c              subcooled attachment                                             SCMech 690
        SELECT CASE (<sc:ATTACH-TO>)                                            SCMech 691
          CASE (1)  ! Refg-system                                               SCMech 692
            <sc:SUBCOOL-CKT> = <sc:REFG-SYSTEM>                                 SCMech 693
          CASE (6)  ! Refg-circuit                                              SCMech 694
            <sc:SUBCOOL-CKT> = Jcomponent(22, <sc:SUBCOOL-CKT>)                 SCMech 695
        END SELECT                                                              SCMech 696
c              liquid to provide subcooling                                     SCMech 697
        IF (<sc:LIQUID-CKT> .GT. 0)  THEN                                       SCMech 698
          <sc:LIQUID-CKT> = Jcomponent(22, <sc:LIQUID-CKT>)                     SCMech 699
        ELSE                                                                    SCMech 700
c              Default liquid feed to same circuit as subcooled                 SCMech 701
          <sc:LIQUID-CKT> = <sc:SUBCOOL-CKT>                                    SCMech 702
        ENDIF                                                                   SCMech 703
c                                                                               SCMech 704
c              Second level of attachments                                      SCMech 705
      CASE (202)                                                                SCMech 706
c              Refrigerants                                                     SCMech 707
c              subcooled liquid                                                 SCMech 708
        Jrs = <sc:/RefgSystem/>                                                 SCMech 709
        <sc;Refrigerant> = <rs:REFRIGERANT>                                     SCMech 710
c              suction side                                                     SCMech 711
        Jrc          = <sc:SUCTION-CKT>                                         SCMech 712
        Jrs          = <rc:/RefgSystem/>                                        SCMech 713
        <sc;SucRefg> = <rs:REFRIGERANT>                                         SCMech 714
c                                                                               SCMech 715
c              Create nodes                                                     SCMech 716
      CASE (203)                                                                SCMech 717
c              Check for cross-connected systems                                SCMech 718
        CALL RefgX(Jsc, <sc:LIQUID-CKT>,<sc:SUCTION-CKT>,0)                     SCMech 719
c                                                                               SCMech 720
c              Attachments on both sides of HX                                  SCMech 721
        Jrs = <sc:/RefgSystem/>                                                 SCMech 722
        Keu = NewEndUse(Jsc)                                                    SCMech 723
        <sc;SubInNode>  =NewNode(1, Jrs,0,Jsc,<sc:SUBCOOL-CKT>,                 SCMech 724
     &                                                     61,1,Keu, 1.)        SCMech 725
        <sc;SubOutNode> =NewNode(1, Jrs,0,Jsc,0,           61,2,Keu, 1.)        SCMech 726
        <sc;SucInNode>  =NewNode(1, Jrs,0,Jsc, <sc:LIQUID-CKT>,                 SCMech 727
     &                                                     61,1,Keu, 1.)        SCMech 728
        <sc;SucOutNode> =NewNode(1, Jrs,0,Jsc,<sc:SUCTION-CKT>,                 SCMech 729
     &                                                     62,2,Keu,1.)         SCMech 730
c                                                                               SCMech 731
c              Links, lists                                                     SCMech 732
      CASE (205)                                                                SCMech 733
c              Check if no attachments                                          SCMech 734
        Kro = <sc;SubOutNode>                                                   SCMech 735
        IF (<ro;Xnode> .EQ. 0)  THEN                                            SCMech 736
          CALL MSGSIM(-1,II,II,II,II)                                           SCMech 737
          WRITE (IOUTPT,9006) (<sc:NAME>,II=1,8)                                SCMech 738
          CALL MessageBox( NULL,                                                SCMech 739
     &      'Subcooler must feed at least one liquid circuit'//char(0),         SCMech 740
     &      'SUBCOOLER Errors'//char(0),                                        SCMech 741
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                SCMech 742
          IwinReturn = 1                                                        SCMech 743
          RETURN                                                                SCMech 744
        ENDIF                                                                   SCMech 745
c              Get pointer to reference enthalpy                                SCMech 746
        <sc;RefgHrefPtr> = IA_RefgHRef(<sc:/RefgSystem/>)                       SCMech 747
c                                                                               SCMech 748
c              List of nodes                                                    SCMech 749
        CALL ListNodes(<sc;Nodes>, 0,0,Jsc,0, 0,0)                              SCMech 750
c                                                                               SCMech 751
c              Histories                                                        SCMech 752
      CASE (208)                                                                SCMech 753
        Jrs = <sc:/RefgSystem/>                                                 SCMech 754
c              Set up history on outlet conditions - set flags in outlet        SCMech 755
c              Xnodes when not converged                                        SCMech 756
        Kro = <sc;SubOutNode>                                                   SCMech 757
        <sc;SubcoolHsty> = NewHistory(Jrs,0,Jsc, <ro;Xnode>, Kro,               SCMech 758
     &                       5, 12, 1.25,                                       SCMech 759
     &                       <#ro.Houtlet>, <sp:ERROR-H>, 1,                    SCMech 760
     &                       <#ro.Poutlet>, <sp:ERROR-P>, 1,                    SCMech 761
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)                    SCMech 762
c              Inlet history                                                    SCMech 763
        Kri = <sc;SubInNode>                                                    SCMech 764
        <sc;PlantHsty> = NewHistory(Jrs,0,Jsc, <ri;Xnode>, Kri,                 SCMech 765
     &                     0, 0, 1.,                                            SCMech 766
     &                     <#ri.Minlet>, <sp:ERROR-FLOW>, 2,                    SCMech 767
     &                     <#ri.Mreqd> , <sp:ERROR-FLOW>, 2,                    SCMech 768
     &                     <#ri.Preqd> , <sp:ERROR-P>   , 1,                    SCMech 769
     &                     <#ri.Treqd> , <sp:ERROR-T>   , 1,                    SCMech 770
     &                     0,0.,0, 0,0.,0)                                      SCMech 771
c              Suction                                                          SCMech 772
        Kri = <sc;SucInNode>                                                    SCMech 773
        Kro = <sc;SucOutNode>                                                   SCMech 774
        Kli = 0                                                                 SCMech 775
        CALL ListAdd(Kli, Kri)                                                  SCMech 776
        CALL ListAdd(Kli, Kro)                                                  SCMech 777
        Kli2 = 0                                                                SCMech 778
        CALL ListAdd(Kli2, <ri;Xnode>)                                          SCMech 779
        CALL ListAdd(Kli2, <ro;Xnode>)                                          SCMech 780
        <sc;SuctionHsty> = NewHistory(Jrs,0,Jsc, Kli2, Kli,                     SCMech 781
     &                       5, 3, 1.5,                                         SCMech 782
     &                       <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,                 SCMech 783
     &                       <#ro.Houtlet>, <sp:ERROR-H>   , 1,                 SCMech 784
     &                       <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,                 SCMech 785
     &                       <#ro.Preqd>  , <sp:ERROR-P>   , 1,                 SCMech 786
     &                       0,0.,0, 0,0.,0)                                    SCMech 787
c                                                                               SCMech 788
c              History lists                                                    SCMech 789
      CASE (209)                                                                SCMech 790
c              All histories associated with this component                     SCMech 791
        CALL ListHstys(<sc;Hstys>, 0, 0, Jsc)                                   SCMech 792
c                                                                               SCMech 793
c              Dump pointers                                                    SCMech 794
      CASE (210)                                                                SCMech 795
        IF (<sc;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         SCMech 796
        WRITE (IOUTPT, 9202)  (<sc:NAME>,II=1,8),                               SCMech 797
     &    Jsc, <sc:SUBCOOL-CKT>, <sc;SubInNode>, <sc;SubOutNode>,               SCMech 798
     &    <sc;SucInNode>, <sc;SucOutNode>                                       SCMech 799
c                                                                               SCMech 800
c                                                                               SCMech 801
      END SELECT  ! Mode                                                        SCMech 802
c                                                                               SCMech 803
c                                                                               SCMech 804
      RETURN                                                                    SCMech 805
c                                                                               SCMech 806
c              Message formats                                                  SCMech 807
 9001 FORMAT(14x,'Subcooler: ',8A4,' has a mass capacity'              /        SCMech 808
     &       14x,'smaller than the design flow.'                       /        SCMech 809
     &       14x,'Flow: ',F10.1,'  Capacity: ',F10.1                   )        SCMech 810
 9002 FORMAT(14x,'Subcooler: ',8A4,' has a thermal'                    /        SCMech 811
     &       14x,'capacity smaller than required.'                     /        SCMech 812
     &       14x,'Capacity: ',F10.0,'  Design Capacity: ',F10.0        )        SCMech 813
 9003 FORMAT(14x,'Subcooler: ',8A4,' has a design '                    /        SCMech 814
     &       14x,'temperature differential between the entering liquid'/        SCMech 815
     &       14x,'and suction gas of only',F4.1,'F.  Will use 10F in'  /        SCMech 816
     &       14x,'the heat-exchanger design calculations.'             )        SCMech 817
 9004 FORMAT(14x,'Subcooler: ',8A4,' heat exchanger design '           /        SCMech 818
     &       14x,'calculations failed to converge in 100 iterations.'  )        SCMech 819
 9005 FORMAT(14x,'Subcooler: ',8A4,' has subcool side'                 /        SCMech 820
     &       14x,'and suction side film resistances > 1.0'             )        SCMech 821
 9006 FORMAT(                                                                   SCMech 822
     &14x,'Subcooler: ',8A4,' has no attached liquid'                  /        SCMech 823
     &14x,'circuits. At least one circuit must be attached to the'     /        SCMech 824
     &14x,'subcooler discharge, or the subcooler must be removed.'     )        SCMech 825
 9007 FORMAT(                                                                   SCMech 826
     &14x,'Subcooler: ',8A4,' has no design load.'                     /        SCMech 827
     &14x,'Check the attachments, define the UA product, or remove'    /        SCMech 828
     &14x,'the subcooler.'                                             )        SCMech 829
 9008 FORMAT(                                                                   SCMech 830
     &14x,'Subcooler: ',8A4,' has a subcooled liquid'                  /        SCMech 831
     &14x,'temperature drop of',F6.1,'F. The DESIGN-SUBCOOL-T must be' /        SCMech 832
     &14x,'colder than the subcooler inlet temperature.'               )        SCMech 833
 9201 FORMAT(/' SUBCOOLERs                             Jsc       Jrc',          SCMech 834
     &'       Kri       Kro    Suc In   Suc Out'                       /        SCMech 835
     &1x,32('-'),6('  --------'))                                               SCMech 836
 9202 FORMAT(1x,8A4,6I10)                                                       SCMech 837
c                                                                               SCMech 838
c                                                                               SCMech 839
      CONTAINS                                                                  SCMech 840
c ============== MechLoad ===================================================== SCMech 841
      Subroutine MechLoad                                                       SCMech 842
c                                                                               SCMech 843
c              Active subcooling                                                SCMech 844
c                                                                               SCMech 845
c              Subcooler load and subcooled temperature                         SCMech 846
      <sc;Qsubcool> = eff * Cmin * (TliquidIn-SST)                              SCMech 847
      TliquidOut    = TliquidIn - <sc;Qsubcool>/Cmin                            SCMech 848
c                                                                               SCMech 849
c              Suction superheat, enthalpy, and mass flow                       SCMech 850
      dTsuper    = TliquidIn - SST                                              SCMech 851
      dTsuper    = MIN(<sc:SUPERHEAT-DT>, dTsuper)                              SCMech 852
      <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SST, dTsuper)                         SCMech 853
      dHsuction    = <ro.Houtlet> - <Xri.Hinlet>                                SCMech 854
      Msuction     = <sc;Qsubcool> / dHsuction                                  SCMech 855
c                                                                               SCMech 856
      End Subroutine MechLoad                                                   SCMech 857
c                                                                               SCMech 858
c                                                                               SCMech 859
c ============== MechNoLoad =================================================== SCMech 860
      Subroutine MechNoLoad                                                     SCMech 861
c                                                                               SCMech 862
c              No subcooler load                                                SCMech 863
c                                                                               SCMech 864
      <sc;Qsubcool> = 0.               ! subcooler load                         SCMech 865
      TliquidOut    = TliquidIn        ! leaving liquid T                       SCMech 866
      Msuction      = 0.               ! suction mass flow                      SCMech 867
c                                                                               SCMech 868
      End Subroutine MechNoLoad                                                 SCMech 869
c                                                                               SCMech 870
c                                                                               SCMech 871
c ============== MechReqdLoad ================================================= SCMech 872
      Subroutine MechReqdLoad                                                   SCMech 873
c                                                                               SCMech 874
c              Required subcooler load                                          SCMech 875
c                                                                               SCMech 876
c              Required load and suction temperature                            SCMech 877
      Qreqd    = Cmin * (TliquidIn - <sc;Tsetpt>)                               SCMech 878
      SSTreqd  = TliquidIn - Qreqd/(eff * Cmin)                                 SCMech 879
c              adjust required SST for superheat                                SCMech 880
      SSTreqd  = MIN(SSTreqd, TliquidIn-(<sc:SUPERHEAT-DT>+1.))                 SCMech 881
c                                                                               SCMech 882
c              Required suction pressure, enthalpy, and flow                    SCMech 883
      <ro.Preqd> = MAX(<re;Pmin>, RefgP_fT(Jre, SSTreqd) - dPctrl)              SCMech 884
      Hreqd      = RefgH_Vapor_fTS(Jre, SSTreqd, <sc:SUPERHEAT-DT>)             SCMech 885
      dHsuction  = Hreqd - <Xri.Hinlet>                                         SCMech 886
      <ro.Mreqd> = Qreqd / dHsuction                                            SCMech 887
c                                                                               SCMech 888
      End Subroutine MechReqdLoad                                               SCMech 889
                                                                                SCMech 890
      END                                                                       SCMech 891
C ##############################################################################Coils    2
C ##############################################################################Coils    3
C ##############################################################################Coils    4
C ##############################################################################Coils    5
C ##########                                                          ##########Coils    6
C ##########                      COIL ROUTINES                       ##########Coils    7
C ##########                                                          ##########Coils    8
C ##############################################################################Coils    9
C ##############################################################################Coils   10
C ##############################################################################Coils   11
C ##############################################################################Coils   12
c                                                                               Coils   13
c                                                                               Coils   14
c              Routines that simulate devices that heat/cool air                Coils   15
c                                                                               Coils   16
c              Coil_Wet           Fully wet coil                                Coils   17
c              Evap_Wet           Fully wet air coil                            Coils   18
c                                                                               Coils   19
c                                                                               Coils   20
      SUBROUTINE AirCoil_DX(Mode, Kac)                                          AXDX     2
c                                                                               AXDX     3
c              Simulates a direct-expansion evaporator                          AXDX     4
c                                                                               AXDX     5
c              Mode = 0-9  Attachment calculations                              AXDX     6
c                      10  Design, airside                                      AXDX     7
c                      11  Design, refrigerant side                             AXDX     8
c                      19  Design, reconciliation                               AXDX     9
c                      21  Hourly capacity                                      AXDX    10
c                      32  Hourly simulation, airside                           AXDX    11
c                      33  Hourly simulation, refrigerant side                  AXDX    12
c                                                                               AXDX    13
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /Attach/ NameAttachments(8,100,3), NumRowsOfAttachments           /Attach/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
      COMMON /WCTRL/   IwinReturn, Imsgflg                                      /WCTRL/  2
c              For DLLs, delete Win_MB and enable msgbox.fi                     /WCTRL/  3
#ifndef _DLL                                                                 /* /WCTRL/  4 */ 
      COMMON /WIN_MB/ MB_OK,MB_ICONSTOP,MB_ICONEXCLAMATION,MB_TASKMODAL,        /WCTRL/  5
     &                MB_ICONINFORMATION                                        /WCTRL/  6
#else                                                                        /* /WCTRL/  7 */ 
      include 'msgbox.fi'                                                       /WCTRL/  8
#endif                                                                       /* /WCTRL/  9 */ 
C ??                                                                            AXDX    22
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
c                                                                               AXDX    24
      INTEGER  Xai, Xao, Xri, Xro                                               AXDX    25
      REAL     MairCp, Mmelt, Mlatent, Mfrost, NTU, Mmax                        AXDX    26
      LOGICAL  IterReqdHsty                                                     AXDX    27
      SAVE     Hsurf32                                                          AXDX    28
      INTEGER  Routine(4)                                                       AXDX    29
      DATA     Routine       /4HAirC,4Hoil_,4HDX  ,4H    /                      AXDX    30
                                                                                AXDX    31
c              Data shared by internal procedures                               AXDX    32
      Real     eff                                                              AXDX    33
                                                                                AXDX    34
      CpAir(W)   = 0.24 + 0.444*W                                               CpAir    2
      DBair(H,W) = (H - 1061.*W) / (0.24 + 0.444*W)                             DBair    2
      HAir(DB,W) = 0.24*DB + (1061.0 + 0.444*DB)*W                              HAir     2
      Hice(T)    = (T-32.)*.487 - 143.35                                        Hice     2
      Hliq(T)    = (T-32.)                                                      Hliq     2
c                                                                               AXDX    40
      Jre = <ac;Refrigerant>             ! Refrigerant                          AXDX    41
      Kai = <ac;AirInletNode>            ! Inlet from fixture                   AXDX    42
      Xai = <ai;Xnode>                   ! Xfaced inlet                         AXDX    43
      Kao = <ac;AirOutletNode>           ! Outlet to fixture                    AXDX    44
      Xao = <ao;Xnode>                   ! Xfaced outlet                        AXDX    45
      Kri = <ac;LiquidNode>              ! Refrigerant liquid                   AXDX    46
      Xri = <ri;Xnode>                   ! Xfaced liquid                        AXDX    47
      Kro = <ac;SuctionNode>             ! Refrigerant suction                  AXDX    48
      Xro = <ro;Xnode>                   ! Xfaced suction                       AXDX    49
c                                                                               AXDX    50
      SELECT CASE (Mode)                                                        AXDX    51
c                                                                               AXDX    52
c                                                                               AXDX    53
c ============ HOURLY INITIALIZATION ========================================== AXDX    54
      CASE (10)                                                                 AXDX    55
c                                                                               AXDX    56
c              Update past hour's variables                                     AXDX    57
      <ac;Qfrost>  = <ac;Qfrost''>                                              AXDX    58
      <ac;Qfrost'> = <ac;Qfrost''>                                              AXDX    59
      <ac;Mfrost>  = <ac;Mfrost''>                                              AXDX    60
      <ac;Mfrost'> = <ac;Mfrost''>                                              AXDX    61
c                                                                               AXDX    62
      CALL ZeroAA(<#ac.HrZeroStart..>, <#ac.HrZeroEnd....>)                     AXDX    63
c                                                                               AXDX    64
c              Check if defrost required                                        AXDX    65
      IF (<ac:DEF-TYPE> .GT. 0)  THEN                                           AXDX    66
        SELECT CASE (<ac:DEF-INITIATE>)                                         AXDX    67
          CASE (1)   ! Time                                                     AXDX    68
            IF (SchVal(<ac:DEF-SCH>) .GT. 0.)  THEN                             AXDX    69
              IF (<ac:DEF-TERMINATE> .EQ. 1  .OR.                               AXDX    70
     &           (<ac:DEF-TERMINATE> .EQ. 2 .AND. <ac;Mfrost> .GT. 0.))         AXDX    71
     &          <ac;DefrostReqd> = 1                                            AXDX    72
            ENDIF                                                               AXDX    73
          CASE (2)   ! Demand                                                   AXDX    74
            IF (<ac;Mfrost> .GT. <ac;MaxFrost>)                                 AXDX    75
     &        <ac;DefrostReqd> = 1                                              AXDX    76
        END SELECT                                                              AXDX    77
c                                                                               AXDX    78
c              If frost buildup excessive, initiate defrost                     AXDX    79
        IF (<ac;DefrostReqd> .EQ. 0  .AND.                                      AXDX    80
     &    <ac;Mfrost> .GT. <ac;MaxFrost>*2.0)  THEN                             AXDX    81
          <ac;DefrostReqd> = 1                                                  AXDX    82
          IF (<ac;FlagForceDef> .EQ. 0)  THEN                                   AXDX    83
            Jna = Jparent(<ac;Parent>)                                          AXDX    84
            CALL MSGSIM(-2,II,II,II,II)                                         AXDX    85
            WRITE (IOUTPT,9103)  (<na:NAME>,II=1,8), <ac;Mfrost>,               AXDX    86
     &                           IMO, IDAY, IHR                                 AXDX    87
c           CALL MessageBox( NULL,                                              AXDX    88
c    &        'Frost has built up to more than '//char(10)//char(13)//          AXDX    89
c    &        '2X the design value; defrost cycle initiated.'//char(0),         AXDX    90
c    &        'Evaporator Errors'//char(0),                                     AXDX    91
c    &        MB_OK + MB_ICONEXCLAMATION + MB_TASKMODAL )                       AXDX    92
          ENDIF                                                                 AXDX    93
          <ac;FlagForceDef> = <ac;FlagForceDef> + 1                             AXDX    94
        ENDIF                                                                   AXDX    95
c                                                                               AXDX    96
        IF (<ac;DefrostReqd> .EQ. 0)  THEN                                      AXDX    97
c              no defrost required                                              AXDX    98
          <ac;HoursLastDef> = <ac;HoursLastDef> + 1                             AXDX    99
          <ac;QdefLoss>     = 0.                                                AXDX   100
          SELECT CASE (<ac:DEF-TYPE>)                                           AXDX   101
            CASE (1)  ! Electric                                                AXDX   102
              Kmd       = <ac:ELEC-METER>                                       AXDX   103
              <md.Elec> = 0.                                                    AXDX   104
            CASE (2)  ! Hot gas                                                 AXDX   105
              Kri          = <ac;HotGasNode>                                    AXDX   106
              <ri.Minlet>  = 0.                                                 AXDX   107
              Kro          = <ac;HotGasRetNode>                                 AXDX   108
              <ro.Moutlet> = 0.                                                 AXDX   109
          END SELECT                                                            AXDX   110
        ELSE                                                                    AXDX   111
          <ac;HoursLastDef> = 0                                                 AXDX   112
        ENDIF                                                                   AXDX   113
      ENDIF    ! ev:DEF-TYPE                                                    AXDX   114
c                                                                               AXDX   115
c                                                                               AXDX   116
c ============ HOURLY SIMULATION - DEFROST ==================================== AXDX   117
      CASE (31)                                                                 AXDX   118
c                                                                               AXDX   119
c              Determine the length of time in the defrost mode and             AXDX   120
c              power consumed                                                   AXDX   121
c                                                                               AXDX   122
      IF (<ac;DefrostReqd> .EQ. 0)  RETURN                                      AXDX   123
c                                                                               AXDX   124
c              Transfer air flows                                               AXDX   125
      <ao.Moutlet> = <Xai.Minlet>                                               AXDX   126
      <ai.Minlet>  = <Xai.Minlet>                                               AXDX   127
c                                                                               AXDX   128
      IF (<ac;DefrostCall> .EQ. 0)  THEN                                        AXDX   129
c              First call - initialize parameters to last defrost               AXDX   130
c              cycle's values                                                   AXDX   131
        <ac;DefrostCall> = 1                                                    AXDX   132
        <ac;QdefLoss>    = <ac;QdefLoss'>                                       AXDX   133
        <ao.Toutlet>     = <ac;AirToDef'>                                       AXDX   134
        <ao.Woutlet>     = <ac;AirWoDef'>                                       AXDX   135
        <ac;TcoilNoQ>    = <ac;TcoilNoQDef'>                                    AXDX   136
        <ac;TcoilUA>     = <ac;TcoilUADef'>                                     AXDX   137
        <ac;SurfWo>      = Wfunc(<ac;TcoilNoQ>, 100., Patm)                     AXDX   138
        <ac;SurfWoUA>    = <ac;SurfWoUADef'>                                    AXDX   139
        <ac;DefrostFrac> = MAX(0.017, <ac;DefrostFrac'>)                        AXDX   140
        W32              = Wfunc(32., 100., Patm)                               AXDX   141
        Hsurf32          = HAir(32., W32)                                       AXDX   142
        RETURN                                                                  AXDX   143
      ENDIF                                                                     AXDX   144
c                                                                               AXDX   145
c              Second or following calls - Note that the bypass-factor          AXDX   146
c              calcs assume that the frost is at 32F, and neglect the           AXDX   147
c              initial transient required to warm the frost to 32F.             AXDX   148
c              This causes the defrost time to be overestimated                 AXDX   149
c              somewhat.                                                        AXDX   150
      SELECT CASE (<ac:DEF-TYPE>)                                               AXDX   151
        CASE (1)  ! Electric                                                    AXDX   152
          DefCap = <ac;DefCapacity> * <ac:DEF-EFF>                              AXDX   153
          IF (<ac:FAN-W/DEFROST> .NE. 0)  THEN                                  AXDX   154
c              fan is off during defrost                                        AXDX   155
            QdefNet = DefCap                                                    AXDX   156
          ELSE                                                                  AXDX   157
c              Fan is running during defrost                                    AXDX   158
            MairCp = <ao.Moutlet> * CpAir(<Xai.Winlet>)                         AXDX   159
            Tinlet = <Xai.Tinlet> + DefCap/MairCp                               AXDX   160
            Hinlet = HAir(Tinlet, <Xai.Winlet>)                                 AXDX   161
            IF (Hinlet .GT. Hsurf32)  THEN                                      AXDX   162
c                 air is warm enough to melt frost                              AXDX   163
              <ac;TcoilNoQ> = 32.                                               AXDX   164
              <ac;SurfWo>   = Wfunc(32., 100., Patm)                            AXDX   165
            ELSE                                                                AXDX   166
c                 air is not warm enough to melt frost, but frost can           AXDX   167
c                 sublimate (a W.A.G. by SDG!)                                  AXDX   168
              HsurfIce      = Hinlet                                            AXDX   169
              <ac;TcoilNoQ> = Aircoil_Tsurf(HsurfIce)                           AXDX   170
              <ac;SurfWo>   = Wfunc(<ac;TcoilNoQ>, 100., Patm)                  AXDX   171
            ENDIF                                                               AXDX   172
c                 Outlet conditions assume uniform frost layer                  AXDX   173
            <ao.Toutlet> = <ac;TcoilNoQ>                                        AXDX   174
     &                   + (Tinlet-<ac;TcoilNoQ>)*<ac;CoilBF>                   AXDX   175
            dWmax = <ac;SurfWo> - <Xai.Winlet>                                  AXDX   176
            IF (dWmax .LT. 0.)  THEN                                            AXDX   177
c                 coil is dehumidifying air                                     AXDX   178
              <ao.Woutlet> = <ac;SurfWo>                                        AXDX   179
     &                     + (<Xai.Winlet>-<ac;SurfWo>)*<ac;CoilBF>             AXDX   180
              Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                   AXDX   181
              QdefNet      = <ao.Moutlet> * (Hinlet-Houtlet)                    AXDX   182
            ELSEIF (<ac;Mfrost> .GT. 0.)  THEN                                  AXDX   183
c                 coil is humidifying air                                       AXDX   184
              QdefNet = MairCp * (Tinlet-<ao.Toutlet>)                          AXDX   185
              dQdMelt = <ac;Hmelt> - <ac;Qfrost>/<ac;Mfrost>                    AXDX   186
     &                             + 1061. + .444*<ao.Toutlet>                  AXDX   187
              Mmelt        = QdefNet / dQdMelt                                  AXDX   188
              dWmelt       = Mmelt / <ao.Moutlet>                               AXDX   189
              dWair        = dWmax * (1.-<ac;CoilBF>)  ! ?? necessary ??        AXDX   190
              dW           = MIN(dWmelt, dWair)                                 AXDX   191
              <ao.Woutlet> = <Xai.Winlet> + dW                                  AXDX   192
              Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                   AXDX   193
            ELSE                                                                AXDX   194
c                coil inactive                                                  AXDX   195
              <ao.Woutlet> = <Xai.Winlet>                                       AXDX   196
              Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                   AXDX   197
              QdefNet      = <ao.Moutlet> * (Hinlet-Houtlet)                    AXDX   198
            ENDIF  ! dWmax                                                      AXDX   199
          ENDIF                                                                 AXDX   200
        CASE (2)  ! Hot-gas                                                     AXDX   201
          DefCap = <ac;DefCapacity> * <ac:DEF-EFF>                              AXDX   202
          IF (<ac:FAN-W/DEFROST> .EQ. 0)  THEN                                  AXDX   203
c              Fan is running during defrost                                    AXDX   204
            Hinlet       = HAir(<Xai.Tinlet>, <Xai.Winlet>)                     AXDX   205
            <ao.Toutlet> = <ac;TcoilNoQ>                                        AXDX   206
     &                   + (<Xai.Tinlet>-<ac;TcoilNoQ>)*<ac;CoilBF>             AXDX   207
            <ao.Woutlet> = <ac;SurfWo>                                          AXDX   208
     &                   + (<Xai.Winlet>-<ac;SurfWo>)*<ac;CoilBF>               AXDX   209
            Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                     AXDX   210
            dQair        = <ao.Moutlet> * (Hinlet-Houtlet)                      AXDX   211
            IF (DefCap .GT. -dQair)  THEN                                       AXDX   212
              QdefNet = DefCap + dQair                                          AXDX   213
            ELSE                                                                AXDX   214
c                 Defroster does not have enough capacity to heat air           AXDX   215
c                 and melt frost                                                AXDX   216
              <ao.Toutlet> = <Xai.Tinlet>                                       AXDX   217
     &                     + DefCap / (<ao.Moutlet>*CpAir(<Xai.Winlet>))        AXDX   218
              <ao.Woutlet> = <Xai.Winlet>                                       AXDX   219
              QdefNet      = 0.                                                 AXDX   220
            ENDIF                                                               AXDX   221
          ELSE                                                                  AXDX   222
c              fan is off during defrost                                        AXDX   223
            QdefNet = DefCap                                                    AXDX   224
          ENDIF                                                                 AXDX   225
        CASE (3)  ! Ambient                                                     AXDX   226
          MairCp = <ao.Moutlet> * CpAir(<Xai.Winlet>)                           AXDX   227
          Tinlet = <Xai.Tinlet>                                                 AXDX   228
          Hinlet = HAir(Tinlet, <Xai.Winlet>)                                   AXDX   229
          IF (Hinlet .GT. Hsurf32)  THEN                                        AXDX   230
c                 air is warm enough to melt frost                              AXDX   231
            <ac;TcoilNoQ> = 32.                                                 AXDX   232
            <ac;SurfWo>   = Wfunc(32., 100., Patm)                              AXDX   233
          ELSE                                                                  AXDX   234
c                 air is not warm enough to melt frost, but frost can           AXDX   235
c                 sublimate                                                     AXDX   236
            HsurfIce      = Hinlet                                              AXDX   237
            <ac;TcoilNoQ> = Aircoil_Tsurf(HsurfIce)                             AXDX   238
            <ac;SurfWo>   = Wfunc(<ac;TcoilNoQ>, 100., Patm)                    AXDX   239
          ENDIF                                                                 AXDX   240
c                 Outlet conditions assume uniform frost layer                  AXDX   241
          <ao.Toutlet> = <ac;TcoilNoQ>                                          AXDX   242
     &                 + (Tinlet-<ac;TcoilNoQ>)*<ac;CoilBF>                     AXDX   243
          dWmax = <ac;SurfWo> - <Xai.Winlet>                                    AXDX   244
          IF (dWmax .LT. 0.)  THEN                                              AXDX   245
c                 coil is dehumidifying air                                     AXDX   246
            <ao.Woutlet> = <ac;SurfWo>                                          AXDX   247
     &                   + (<Xai.Winlet>-<ac;SurfWo>)*<ac;CoilBF>               AXDX   248
            Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                     AXDX   249
            QdefNet      = <ao.Moutlet> * (Hinlet-Houtlet)                      AXDX   250
          ELSEIF (<ac;Mfrost> .GT. 0.)  THEN                                    AXDX   251
c                 coil is humidifying air                                       AXDX   252
            QdefNet = MairCp * (Tinlet-<ao.Toutlet>)                            AXDX   253
            dQdMelt = <ac;Hmelt> - <ac;Qfrost>/<ac;Mfrost>                      AXDX   254
     &                           + 1061. + .444*<ao.Toutlet>                    AXDX   255
            Mmelt        = QdefNet / dQdMelt                                    AXDX   256
            dWmelt       = Mmelt / <ao.Moutlet>                                 AXDX   257
            dWair        = dWmax * (1.-<ac;CoilBF>)  ! ?? necessary ??          AXDX   258
            dW           = MIN(dWmelt, dWair)                                   AXDX   259
            <ao.Woutlet> = <Xai.Winlet> + dW                                    AXDX   260
            Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                     AXDX   261
          ELSE                                                                  AXDX   262
c                coil inactive                                                  AXDX   263
            <ao.Woutlet> = <Xai.Winlet>                                         AXDX   264
            Houtlet      = HAir(<ao.Toutlet>, <ao.Woutlet>)                     AXDX   265
            QdefNet      = <ao.Moutlet> * (Hinlet-Houtlet)                      AXDX   266
          ENDIF  ! dWmax                                                        AXDX   267
      END SELECT  ! ev:DEF-TYPE                                                 AXDX   268
c                                                                               AXDX   269
c              Energy in frost, and time required to melt                       AXDX   270
      IF (<ac;Mfrost> .GT. 0.)  THEN                                            AXDX   271
        Qfrost = <ac;Mfrost>*<ac;Hmelt> - <ac;Qfrost>                           AXDX   272
      ELSE                                                                      AXDX   273
        Qfrost = 0.                                                             AXDX   274
      ENDIF                                                                     AXDX   275
      IF (QdefNet .GT. 0.)  THEN                                                AXDX   276
        <ac;DefTimeReqd> = Qfrost / QdefNet                                     AXDX   277
      ELSE                                                                      AXDX   278
        <ac;DefTimeReqd> = 1.0                                                  AXDX   279
      ENDIF                                                                     AXDX   280
c              fraction of the hour in defrost mode                             AXDX   281
      SELECT CASE (<ac:DEF-TERMINATE>)                                          AXDX   282
        CASE (1)   ! Time                                                       AXDX   283
          <ac;DefrostFrac> = <ac;DefDuration>                                   AXDX   284
        CASE (2)   ! Demand - cannot be whole hour, nor less than 1 minute      AXDX   285
          <ac;DefrostFrac> = MIN(0.983, <ac;DefTimeReqd>)                       AXDX   286
          IF (<ac;DefrostFrac> .GT. 0.)                                         AXDX   287
     &        <ac;DefrostFrac> = MAX(0.017, <ac;DefrostFrac>)                   AXDX   288
      END SELECT                                                                AXDX   289
c              fraction of DefrostFrac that is useful and surplus               AXDX   290
      IF (<ac;DefrostFrac> .GT. 0.)  THEN                                       AXDX   291
        FracUseful = MIN(1., <ac;DefTimeReqd>/<ac;DefrostFrac>)                 AXDX   292
      ELSE                                                                      AXDX   293
        FracUseful = 0.                                                         AXDX   294
      ENDIF                                                                     AXDX   295
      FracSurplus = 1.0 - FracUseful                                            AXDX   296
c                                                                               AXDX   297
c             Frost melted                                                      AXDX   298
      IF (Qfrost .GT. 0.)  THEN                                                 AXDX   299
        <ac;Qmelt>    = MAX(0.,MIN(Qfrost, QdefNet*<ac;DefrostFrac>))           AXDX   300
        <ac;Mdefrost> = <ac;Mfrost> * <ac;Qmelt>/Qfrost                         AXDX   301
        <ac;Mfrost'>  = <ac;Mfrost> - <ac;Mdefrost>                             AXDX   302
        <ac;Qfrost'>  = <ac;Qfrost> * <ac;Mfrost'>/<ac;Mfrost>                  AXDX   303
      ELSE                                                                      AXDX   304
        <ac;Qmelt>    = 0.                                                      AXDX   305
        <ac;Mdefrost> = 0.                                                      AXDX   306
        <ac;Mfrost'>  = <ac;Mfrost>                                             AXDX   307
        <ac;Qfrost'>  = <ac;Qfrost>                                             AXDX   308
      ENDIF  ! Qfrost                                                           AXDX   309
c                                                                               AXDX   310
c              Energy consumed by defroster                                     AXDX   311
      SELECT CASE (<ac:DEF-TYPE>)                                               AXDX   312
        CASE (1)  ! Electric                                                    AXDX   313
          <ac;Qdefroster> = <ac;DefCapacity> * <ac;DefrostFrac>                 AXDX   314
          <ac;QdefReqd>   = <ac;Qdefroster>  * FracUseful                       AXDX   315
          Kmd             = <ac:ELEC-METER>                                     AXDX   316
          <md.Elec>       = <ac;Qdefroster> * KWBTU                             AXDX   317
        CASE (2)  ! Hot gas                                                     AXDX   318
          <ac;Qdefroster> = <ac;DefCapacity> * <ac;DefrostFrac>                 AXDX   319
          <ac;QdefReqd>   = <ac;Qdefroster>  * FracUseful                       AXDX   320
c              Assume heat output rate of hot-gas defrost drops once all        AXDX   321
c              ice melted, and depends on whether airflow exists                AXDX   322
          IF (<ac:FAN-W/DEFROST> .EQ. 0)  THEN                                  AXDX   323
c              Fan is running during defrost                                    AXDX   324
            <ac;Qdefroster> = <ac;QdefReqd>                                     AXDX   325
     &                      + <ac;Qdefroster> * FracSurplus * 0.8               AXDX   326
          ELSE  ! fan off                                                       AXDX   327
            <ac;Qdefroster> = <ac;QdefReqd>                                     AXDX   328
     &                      + <ac;Qdefroster> * FracSurplus * 0.2               AXDX   329
          ENDIF                                                                 AXDX   330
c              hot-gas consumption                                              AXDX   331
          Kri = <ac;HotGasNode>                                                 AXDX   332
          Xri = <ri;Xnode>                                                      AXDX   333
          Kro = <ac;HotGasRetNode>                                              AXDX   334
          Xro = <ro;Xnode>                                                      AXDX   335
c              assume 10F subcooling on liquid                                  AXDX   336
          <ro.Houtlet> = RefgH_Liquid_fSP(Jre, 10., <Xro.Poutlet>)              AXDX   337
          <ri.Hinlet>  = <Xri.Hinlet>                                           AXDX   338
          <ro.Moutlet> = <ac;Qdefroster> / (<ri.Hinlet>-<ro.Houtlet>)           AXDX   339
          <ri.Minlet>  = -<ro.Moutlet>                                          AXDX   340
          <ri.Qinlet>  = <ri.Minlet>*(<ri.Hinlet>-AA(<rc;RefgHrefPtr>))         AXDX   341
          <ro.Qoutlet> = <ri.Qinlet> + <ac;Qdefroster>                          AXDX   342
        CASE (3)  ! Off-cycle defrost                                           AXDX   343
      END SELECT  ! ev:DEF-TYPE                                                 AXDX   344
c                                                                               AXDX   345
c              Sensible effect on environment                                   AXDX   346
      <ac;QdefLoss> = <ac;Qdefroster> - <ac;Qmelt>                              AXDX   347
      IF (<ac;TloadAA> .GT. 0)  <ac;TcoilUA> = 0.                               AXDX   348
      IF (<ac:FAN-W/DEFROST> .NE. 0)  THEN                                      AXDX   349
c              fan is off during defrost                                        AXDX   350
        IF (<ac;WloadAA> .GT. 0)  <ac;SurfWoUA> = 0.                            AXDX   351
      ELSE                                                                      AXDX   352
c              fan is running during defrost                                    AXDX   353
c              latent exchange may either humidify or dehumidify air            AXDX   354
        IF (<ac;Qmelt> .GT. 0.  .AND.  <ac;WloadAA> .GT. 0)  THEN               AXDX   355
          Mlatent = <ao.Moutlet> * FracUseful                                   AXDX   356
     &                           * (<Xai.Winlet>-<ao.Woutlet>)                  AXDX   357
          dW      = AA(<ac;WloadAA>) - <ac;SurfWo>                              AXDX   358
          IF (ABS(dW) .GT. 1.E-10)  <ac;SurfWoUA> = Mlatent / dW                AXDX   359
        ENDIF                                                                   AXDX   360
        CALL CnvgCheck(2, <ac;UAerHsty>)                                        AXDX   361
      ENDIF                                                                     AXDX   362
c                                                                               AXDX   363
c                                                                               AXDX   364
c ============ HOURLY SIMULATION - AIRSIDE ==================================== AXDX   365
      CASE (32)                                                                 AXDX   366
c                                                                               AXDX   367
c              Transfer air flows                                               AXDX   368
      <ao.Moutlet> = <Xai.Minlet>                                               AXDX   369
      <ai.Minlet>  = <Xai.Minlet>                                               AXDX   370
c                                                                               AXDX   371
c              If defrost cycle this hour and first normal call                 AXDX   372
      IF (<ac;DefrostCall> .EQ. 1)  THEN                                        AXDX   373
        <ac;DefrostCall> = 0                                                    AXDX   374
c              store defrost conditions for use next defrost                    AXDX   375
        <ac;QdefLoss'>    = <ac;QdefLoss>                                       AXDX   376
        <ac;AirToDef'>    = <ao.Toutlet>                                        AXDX   377
        <ac;AirWoDef'>    = <ao.Woutlet>                                        AXDX   378
        <ac;TcoilNoQDef'> = <ac;TcoilNoQ>                                       AXDX   379
        <ac;TcoilUADef'>  = <ac;TcoilUA>                                        AXDX   380
        <ac;SurfWoUADef'> = <ac;SurfWoUA>                                       AXDX   381
        <ac;DefrostFrac'> = <ac;DefrostFrac>                                    AXDX   382
c              initialize normal conditions                                     AXDX   383
        <ao.Toutlet>  = <ac;AirToDef''>                                         AXDX   384
        <ao.Woutlet>  = <ac;AirWoDef''>                                         AXDX   385
        <ac;CpDemand> = <ac;CpDemand''>                                         AXDX   386
        <ac;TcoilNoQ> = <ac;TcoilNoQDef''>                                      AXDX   387
        <ac;TcoilUA>  = <ac;TcoilUADef''>                                       AXDX   388
        <ac;SurfWo>   = <ac;SurfWoDef''>                                        AXDX   389
        <ac;SurfWoUA> = <ac;SurfWoUADef''>                                      AXDX   390
        CALL CnvgCheck(1, <ac;DefPwrHsty>)                                      AXDX   391
        RETURN                                                                  AXDX   392
      ENDIF                                                                     AXDX   393
c                                                                               AXDX   394
c              Air inlet conditions                                             AXDX   395
      AirHi   = HAir(<Xai.Tinlet>, <Xai.Winlet>)                                AXDX   396
      AirTdew = Dewpt(<Xai.Winlet>, Patm)                                       AXDX   397
c                                                                               AXDX   398
c              Skip if no airflow                                               AXDX   399
      IF (<ao.Moutlet> .EQ. 0.)  THEN                                           AXDX   400
        Call AirCoilNoLoad                                                      AXDX   401
        <ro.Mreqd> = 0.                                                         AXDX   402
        RETURN                                                                  AXDX   403
      ENDIF                                                                     AXDX   404
c                                                                               AXDX   405
c              Maximum possible refrigerant flow                                AXDX   406
      dP   = MAX(0., <Xri.Pinlet> - <Xro.Poutlet>)                              AXDX   407
      Mmax = (dP*<ac;1/dPsupply>)**(1./1.87)                                    AXDX   408
      Mmax = Mmax * <ac;DesMsup>                                                AXDX   409
      Mmax = MIN(Mmax, <ac;MaxMsup>)                                            AXDX   410
      <ac;MsupplyMax>   = Mmax                                                  AXDX   411
      <ac;1/MsupplyMax> = 1. / MAX(Mmax, 1.E-20)                                AXDX   412
c                                                                               AXDX   413
c              Adjust HX resistance for frost buildup                           AXDX   414
      IF (<ac;MaxFrost> .EQ. 0.)  THEN                                          AXDX   415
        <ac;Rmedia'> = <ac;Rmedia>                                              AXDX   416
      ELSE                                                                      AXDX   417
        <ac;Rmedia'> = <ac;Rmedia>                                              AXDX   418
     &               + <ac;Rfrost>*<ac;Mfrost'>*<ac;1/MaxFrost>                 AXDX   419
      ENDIF                                                                     AXDX   420
c                                                                               AXDX   421
c              Calculate the leaving air conditions, given                      AXDX   422
c              the minimum SST and entering air conditions                      AXDX   423
      SSTmin    = RefgT_fP(Jre, <Xro.Poutlet>)                                  AXDX   424
      SELECT CASE (<ac:TEMP-CTRL>)                                              AXDX   425
c                                                                               AXDX   426
        CASE (1)  ! Floating                                                    AXDX   427
          TsetMin = SSTmin                                                      AXDX   428
          IF (SSTmin .GE. <Xai.Tinlet>)  THEN                                   AXDX   429
c              suction is warmer than entering air - no load                    AXDX   430
            Call AirCoilNoLoad                                                  AXDX   431
            <ro.Mreqd> = 0.                                                     AXDX   432
          ELSE                                                                  AXDX   433
            ModeCoil = 1                                                        AXDX   434
            SST      = SSTmin                                                   AXDX   435
            Call AirCoilLoad                                                    AXDX   436
            <ro.Mreqd> = <ro.Moutlet>                                           AXDX   437
            dT         = <ao.Toutlet> - SST                                     AXDX   438
            <ro.Preqd> = RefgP_fT(Jre, <Xao.Treqd>-dT)                          AXDX   439
          ENDIF                                                                 AXDX   440
c                                                                               AXDX   441
        CASE (2,3)  ! Thermostat                                                AXDX   442
c              Air outlet temperature at bottom of control band                 AXDX   443
          TsetMin = <Xao.Treqd> - <ac;Throttle/2>                               AXDX   444
          IF (TsetMin .GE. <Xai.Tinlet>)  THEN                                  AXDX   445
c              setpoint is warmer than entering air - no load                   AXDX   446
            Call AirCoilNoLoad                                                  AXDX   447
            <ro.Mreqd> = 0.                                                     AXDX   448
          ELSEIF (SSTmin .GE. <Xai.Tinlet>)  THEN                               AXDX   449
c              suction is warmer than entering air                              AXDX   450
            Call AirCoilNoLoad                                                  AXDX   451
c              set required suction to tentative value                          AXDX   452
            Call AirCoilReqdSuction_NoLoad                                      AXDX   453
          ELSE                                                                  AXDX   454
c              Coil is active - air outlet temperature at top of band           AXDX   455
            TsetMax = TsetMin + <ac:TEMP-THROTTLE>                              AXDX   456
            TsetMax = MIN(TsetMax, <Xai.Tinlet>-0.01)                           AXDX   457
            TsetMin = MIN(TsetMin, TsetMax-0.01)                                AXDX   458
            dTband  = TsetMax - TsetMin                                         AXDX   459
c              get the required suction conditions                              AXDX   460
            Call AirCoilReqdSuction                                             AXDX   461
            IF (SSPreqd .LT. <Xro.Poutlet>)  THEN                               AXDX   462
c                 temperature setpoint can't be met; take what we can           AXDX   463
              ModeCoil = 2                                                      AXDX   464
              Call AirCoilLoad                                                  AXDX   465
            ENDIF                                                               AXDX   466
          ENDIF  ! TsetMin                                                      AXDX   467
c                                                                               AXDX   468
c              Check for humidity requirement         ! ?? not debugged         AXDX   469
          IF ( <Xao.Wreqd> .NE. -88888.        .AND.  ! humidity setpt          AXDX   470
     &        <ao.Woutlet> .GT. <Xao.Wreqd>    .AND.  ! must run colder         AXDX   471
     &              SSTmin .LT. <Xai.Tinlet>   .AND.  ! can run                 AXDX   472
     &          <ro.Preqd> .GT. <Xro.Poutlet>)  THEN  ! can run colder          AXDX   473
c              required suction conditions                                      AXDX   474
            Call AirCoilReqdSuction_fW                ! ?? not debugged         AXDX   475
            TsetMin = MIN(TsetMin, <ao.Toutlet>)                                AXDX   476
            IF (<ro.Preqd> .LT. <Xro.Poutlet>)  THEN                            AXDX   477
c                 humidity setpoint can't be met; take what we can              AXDX   478
              ModeCoil = 2                                                      AXDX   479
              Call AirCoilLoad                                                  AXDX   480
            ENDIF                                                               AXDX   481
          ENDIF                                                                 AXDX   482
c                                                                               AXDX   483
        CASE (4,5)  ! local EPR                                                 AXDX   484
c              Suction setpoint is air setpoint minus the design EPR            AXDX   485
c              differential                                                     AXDX   486
          SSTset  = <Xao.Treqd> - <ac:SST-SUPPLY-TD>                            AXDX   487
          SSPset  = RefgP_fT(Jre, SSTset)                                       AXDX   488
c              suction temperature at bottom of control band                    AXDX   489
          TsetMin = SSTset-<ac;Throttle/2>                                      AXDX   490
          IF (TsetMin .GE. <Xai.Tinlet>)  THEN                                  AXDX   491
c              setpoint is warmer than entering air - no load                   AXDX   492
            Call AirCoilNoLoad                                                  AXDX   493
            <ro.Mreqd> = 0.                                                     AXDX   494
          ELSEIF (SSTmin .GE. <Xai.Tinlet>)  THEN                               AXDX   495
c              suction is warmer than entering air                              AXDX   496
            Call AirCoilNoLoad                                                  AXDX   497
c              set required suction to tentative value                          AXDX   498
            Call AirCoilReqdSuction_NoLoad                                      AXDX   499
          ELSE                                                                  AXDX   500
c              Coil is active - suction temperature at top of band              AXDX   501
            TsetMax = TsetMin + <ac:TEMP-THROTTLE>                              AXDX   502
            TsetMax = MIN(TsetMax, <Xai.Tinlet>-0.01)                           AXDX   503
            TsetMin = MIN(TsetMin, TsetMax-0.01)                                AXDX   504
            dTband  = TsetMax - TsetMin                                         AXDX   505
c              calc SST and refg mass                                           AXDX   506
            ModeCoil = 3                                                        AXDX   507
            Call AirCoilLoad                                                    AXDX   508
c              required suction flow and required coil temperature              AXDX   509
            <ro.Mreqd>   = <ro.Moutlet>                                         AXDX   510
            <ac;SSTreqd> = Tsetpt                                               AXDX   511
c              If running below setpoint, reset reqd to setpoint                AXDX   512
            IF (<ao.Toutlet> .LT. <Xao.Treqd>)                                  AXDX   513
     &        <ac;SSTreqd> = <ac;SSTreqd> + <Xao.Treqd>-<ao.Toutlet>            AXDX   514
c              required suction pressure; limit if defrosted recently           AXDX   515
            IF (<ac;HoursLastDef> .EQ. 0  .OR.                                  AXDX   516
     &         (<ac;HoursLastDef> .EQ. 1  .AND.                                 AXDX   517
     &                                     <ac;DefrostFrac'> .GT. 0.5))         AXDX   518
     &        dPctrl = MIN(dPctrl, <ac;CtrlValveDP>)                            AXDX   519
            <ro.Preqd> = MAX(<re;Pmin>,                                         AXDX   520
     &                       RefgP_fT(Jre, <ac;SSTreqd>)-dPctrl)                AXDX   521
          ENDIF                                                                 AXDX   522
      END SELECT  ! ac:TEMP-CTRL                                                AXDX   523
c                                                                               AXDX   524
c              Pressure as regulated by temperature control valve               AXDX   525
      Pctrl = RefgP_fT(Jre, SST)                                                AXDX   526
c                                                                               AXDX   527
c              Check load-based flow against pressure-based flow                AXDX   528
      IF (<ro.Moutlet> .GT. 0.)  THEN                                           AXDX   529
c              Maximum suction flow, inlet to control valve                     AXDX   530
        dP            = MAX(0., <Xri.Pinlet> - Pctrl)                           AXDX   531
        Mmax          = (dP*<ac;1/dPsupplyIn>)**(1./1.87)                       AXDX   532
        Mmax          = Mmax * <ac;DesMsup>                                     AXDX   533
        <ac;MsupplyMax> = MIN(<ac;MsupplyMax>, Mmax)                            AXDX   534
c ??           Superheat TXV                                                    AXDX   535
c ??           makes code unstable                                              AXDX   536
c ??    dTsuperMax = MAX(0., <Xai.Tinlet> - SST)                                AXDX   537
c ??    IF (<ac:SUPERHEAT-DT> .GT. dTsuperMax)  THEN                            AXDX   538
c              Not enough superheat; modulate flow                              AXDX   539
c ??      Mmax            = <ro.Moutlet> * dTsuperMax/<ac:SUPERHEAT-DT>         AXDX   540
c ??      <ac;MsupplyMax> = MIN(<ac;MsupplyMax>, Mmax)                          AXDX   541
c ??    ENDIF                                                                   AXDX   542
c                                                                               AXDX   543
        IF (<ro.Moutlet> .GT. <ac;MsupplyMax>)  THEN                            AXDX   544
c              insufficient refrigerant capacity                                AXDX   545
          IF (<ac;MsupplyMax> .EQ. 0.)  THEN                                    AXDX   546
            Call AirCoilNoLoad                                                  AXDX   547
          ELSE                                                                  AXDX   548
c              Maximum possible heat transfer, assuming the refg                AXDX   549
c              temperature approaches the air inlet temperature                 AXDX   550
            TrefgOut     = <Xai.Tinlet> - 1.0                                   AXDX   551
            dTsuper      = MAX(0., TrefgOut - SST)                              AXDX   552
            <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SST, dTsuper)                   AXDX   553
            QhxMax       = <ac;MsupplyMax> * (<ro.Houtlet>-<Xri.Hinlet>)        AXDX   554
c              skip if the extra superheat can handle load                      AXDX   555
            IF (QhxMax .GE. <ac;Qsupply>)  THEN                                 AXDX   556
              <ro.Houtlet> = <Xri.Hinlet> + <ac;Qsupply>/<ro.Moutlet>           AXDX   557
            ELSE                                                                AXDX   558
c                 Determine coil leaving air conditions at maximum              AXDX   559
c                 possible heat transfer                                        AXDX   560
               Call AirCoilChoked                                               AXDX   561
            ENDIF  ! QhxMax                                                     AXDX   562
          ENDIF    ! ac;MsupplyMax                                              AXDX   563
        ENDIF      ! ro,Moutlet .gt. acMrefgMax                                 AXDX   564
      ENDIF        ! ro,Moutlet .gt. 0.                                         AXDX   565
c                                                                               AXDX   566
c              Air-side load                                                    AXDX   567
      <ai.Qinlet> = <ac;Qair>                                                   AXDX   568
      <ac;SST>    = SST                                                         AXDX   569
c                                                                               AXDX   570
c              Condensate/frost conditions                                      AXDX   571
      <ac;Mlatent> = MAX(0., <ao.Moutlet> * (<Xai.Winlet>-<ao.Woutlet>))        AXDX   572
      IF (<ac;Mlatent> .GT. 0.  .AND.  <ac;FracFrosted> .GT. 0.)  THEN          AXDX   573
c              Frost is building up on coil                                     AXDX   574
        Mfrost       = <ac;Mlatent> * <Xao.RunFrac> * <ac;FracFrosted>          AXDX   575
        <ac;Mfrost''> = <ac;Mfrost'> + Mfrost                                   AXDX   576
        <ac;Qfrost''> = <ac;Qfrost'> + Mfrost*Hfrost                            AXDX   577
      ELSEIF (<ac;Mfrost'> .GT. 0.  .AND.  <ac;SurfTo> .GT. 32.)  THEN          AXDX   578
c              Frost may be melting and dropping outlet temperature.            AXDX   579
c              Get outlet conditions for surface at 32F.                        AXDX   580
c              ?? modify for actual airfilm coef ??                             AXDX   581
        Toutlet  = <Xai.Tinlet> + (32.-<Xai.Tinlet>)*<ac;SurfEff>               AXDX   582
        WsurfIce = Wfunc(32., 100., Patm)                                       AXDX   583
        Woutlet  = <Xai.Winlet> + (WsurfIce-<Xai.Winlet>)*<ac;SurfEff>          AXDX   584
        Houtlet  = HAir(Toutlet, Woutlet)                                       AXDX   585
        IF (Houtlet .LT. <ac;AirHo>)  THEN                                      AXDX   586
c              Frost is melting - do not let frost handle entire load           AXDX   587
c              unless surface is above 35F                                      AXDX   588
          dQmax         = MIN(1., (<ac;SurfTo> - 32.)/3.)                       AXDX   589
          dH            = AirHi - Houtlet                                       AXDX   590
          Qair          = <ao.Moutlet> * dH * <Xao.RunFrac>                     AXDX   591
          Qfrost        = -<ac;Qfrost'>                                         AXDX   592
          Qmelt         = MIN(Qair*dQmax, Qfrost)                               AXDX   593
          Mmelt         = <ac;Mfrost'> * Qmelt/Qfrost                           AXDX   594
          <ac;Mfrost''> = <ac;Mfrost'> - Mmelt                                  AXDX   595
          <ac;Qfrost''> = <ac;Qfrost'> * <ac;Mfrost''>/<ac;Mfrost'>             AXDX   596
          Ratio         = Qmelt / Qair                                          AXDX   597
          <ao.Toutlet>  = Ratio*Toutlet  + (1.-Ratio)*<ao.Toutlet>              AXDX   598
          <ao.Woutlet>  = Ratio*Woutlet  + (1.-Ratio)*<ao.Woutlet>              AXDX   599
          <ac;SurfWo>   = Ratio*WsurfIce + (1.-Ratio)*<ac;SurfWo>               AXDX   600
          IF (SSTmin .GT. 32.)                                                  AXDX   601
     &        SSTmin    = Ratio*32.      + (1.-Ratio)*SSTmin                    AXDX   602
          <ac;AirHo>    = HAir(<ao.Toutlet>, <ao.Woutlet>)                      AXDX   603
          <ac;Qair>     = <ao.Moutlet> * (AirHi-<ac;AirHo>)                     AXDX   604
          <ai.Qinlet>   = <ac;Qair>                                             AXDX   605
          dW            = <Xai.Winlet> - <ao.Woutlet>                           AXDX   606
          <ac;Mlatent>  = <ao.Moutlet> * dW                                     AXDX   607
          IF (<ro.Moutlet> .GT. 0.)  THEN                                       AXDX   608
            dMrefg       = Qmelt / (dHrefg * <Xao.RunFrac>)                     AXDX   609
            dMrefg       = MIN(<ro.Moutlet>, dMrefg)                            AXDX   610
            <ac;Qsupply> = <ac;Qsupply> * (1. - dMrefg/<ro.Moutlet>)            AXDX   611
            <ro.Moutlet> = <ro.Moutlet> - dMrefg                                AXDX   612
            IF (<ro.Mreqd> .LE. <ro.Moutlet>)                                   AXDX   613
     &        <ro.Mreqd> = MAX(0., <ro.Mreqd> - dMrefg)                         AXDX   614
          ENDIF                                                                 AXDX   615
        ELSE                                                                    AXDX   616
c              no change in frost                                               AXDX   617
          <ac;Mfrost''> = <ac;Mfrost'>                                          AXDX   618
          <ac;Qfrost''> = <ac;Qfrost'>                                          AXDX   619
        ENDIF                                                                   AXDX   620
      ELSE                                                                      AXDX   621
c              no change in frost                                               AXDX   622
        <ac;Mfrost''> = <ac;Mfrost'>                                            AXDX   623
        <ac;Qfrost''> = <ac;Qfrost'>                                            AXDX   624
      ENDIF  ! Qlatent .lt. 0                                                   AXDX   625
c                                                                               AXDX   626
c              Coil conditions for extraction rate calcs                        AXDX   627
c              First, sensible extraction terms                                 AXDX   628
      IF (<ac;TloadAA> .GT. 0)  THEN                                            AXDX   629
c              sensible load                                                    AXDX   630
        dTair = <Xai.Tinlet> - <ao.Toutlet>                                     AXDX   631
        IF (dTair .LE. 0.)  THEN                                                AXDX   632
          <ac;TcoilUA> = 0.                                                     AXDX   633
        ELSE                                                                    AXDX   634
c              sensible load                                                    AXDX   635
          <ac;CpDemand> = CpAir((<Xai.Winlet>+<ao.Woutlet>)*0.5)                AXDX   636
          UAair         = <ao.Moutlet> * <ac;CpDemand>                          AXDX   637
          Qsens         = UAair * dTair                                         AXDX   638
c              surface temperature at zero load                                 AXDX   639
          <ac;TcoilNoQ> = MAX(SSTmin, TsetMin)                                  AXDX   640
c              effective extraction "conductivity"                              AXDX   641
          dTload = AA(<ac;TloadAA>) - <ac;TcoilNoQ>                             AXDX   642
          IF (dTload .GT. 1.E-10)  THEN                                         AXDX   643
            <ac;TcoilUA>  = Max(0., Min(UAair, Qsens / dTload))                 AXDX   644
          ELSEIF (dTload .LE. 0.)  THEN                                         AXDX   645
            <ac;TcoilUA>  = 0.                                                  AXDX   646
          ENDIF                                                                 AXDX   647
        ENDIF  ! dTair                                                          AXDX   648
c              Next, latent extraction terms - latent exchange may              AXDX   649
c              either humidify or dehumidify air                                AXDX   650
        IF (<ac;WloadAA> .GT. 0)  THEN                                          AXDX   651
          dWair = <Xai.Winlet> - <ao.Woutlet>                                   AXDX   652
          IF (dWair .EQ. 0.)  THEN                                              AXDX   653
            <ac;SurfWoUA> = 0.                                                  AXDX   654
          ELSE                                                                  AXDX   655
            dW = AA(<ac;WloadAA>) - <ac;SurfWo>                                 AXDX   656
            IF (ABS(dW) .GT. 1.E-10)  <ac;SurfWoUA> = <ac;Mlatent>/dW           AXDX   657
          ENDIF                                                                 AXDX   658
        ENDIF  ! ac;WloadAA                                                     AXDX   659
        CALL CnvgCheck(2, <ac;UAerHsty>)                                        AXDX   660
      ENDIF  ! ac;TloadAA                                                       AXDX   661
c                                                                               AXDX   662
c                                                                               AXDX   663
c ============ HOURLY SIMULATION - REFRIGERANT-SIDE =========================== AXDX   664
      CASE (33)                                                                 AXDX   665
c                                                                               AXDX   666
c              If defrost cycle this hour                                       AXDX   667
      IF (<ac;DefrostReqd> .EQ. 1)  THEN                                        AXDX   668
c              Store end of hour conditions for use next defrost                AXDX   669
        <ac;AirToDef''>    = <ao.Toutlet>                                       AXDX   670
        <ac;AirWoDef''>    = <ao.Woutlet>                                       AXDX   671
        <ac;CpDemand''>    = <ac;CpDemand>                                      AXDX   672
        <ac;TcoilNoQDef''> = <ac;TcoilNoQ>                                      AXDX   673
        <ac;SurfWoDef''>   = <ac;SurfWo>                                        AXDX   674
        <ac;TcoilUADef''>  = <ac;TcoilUA>                                       AXDX   675
        <ac;SurfWoUADef''> = <ac;SurfWoUA>                                      AXDX   676
        CALL CnvgCheck(1, <ac;DefPwrHsty>)                                      AXDX   677
      ELSE                                                                      AXDX   678
        CALL HstyClearFlag(<ac;DefPwrHsty>)                                     AXDX   679
      ENDIF                                                                     AXDX   680
c                                                                               AXDX   681
c              Adjust loads for run fraction                                    AXDX   682
      <ro.Moutlet> = <ro.Moutlet> * <Xao.RunFrac>                               AXDX   683
      <ro.Mreqd>   = <ro.Mreqd>   * <Xao.RunFrac>                               AXDX   684
      <ac;Qsupply> = <ac;Qsupply> * <Xao.RunFrac>                               AXDX   685
      <ac;Qair>    = <ac;Qair>    * <Xao.RunFrac>                               AXDX   686
      <ai.Qinlet>  = <ai.Qinlet>  * <Xao.RunFrac>                               AXDX   687
c                                                                               AXDX   688
c              Refrigerant conditions at inlet                                  AXDX   689
      <ri.Minlet>  = <ro.Moutlet>                                               AXDX   690
      <ri.Qinlet>  = <ri.Minlet> * (<Xri.Hinlet>-AA(<ac;RefgHrefPtr>))          AXDX   691
      <ro.Qoutlet> = <ri.Qinlet> + <ac;Qsupply>                                 AXDX   692
c              required pressure at inlet                                       AXDX   693
      <ri.Mreqd> = <ro.Mreqd>                                                   AXDX   694
      IF (<ri.Mreqd> .GT. 0.)  THEN                                             AXDX   695
        dP         = (<ri.Mreqd>*<ac;1/DesMsup>)**1.87                          AXDX   696
        dP         = dP * <ac:SUPPLY-DP>                                        AXDX   697
        Pctrl      = RefgP_fT(Jre, <ac;SST>)                                    AXDX   698
        <ri.Preqd> = MIN(<re;Pmax>, Pctrl+dP)                                   AXDX   699
c              liquid should be no warmer than saturation                       AXDX   700
        <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                AXDX   701
      ENDIF                                                                     AXDX   702
c                                                                               AXDX   703
c              Check for convergence on outlet conditions                       AXDX   704
      CALL CnvgCheck(1, <ac;SupplyHsty>)                                        AXDX   705
c                                                                               AXDX   706
c                                                                               AXDX   707
c ============ STATISTICS - HOURLY DATA ======================================= AXDX   708
      CASE (42)                                                                 AXDX   709
c                                                                               AXDX   710
c              Check if sufficient refrigerant available                        AXDX   711
      IF (<ro.Moutlet> .EQ. <ac;MsupplyMax>)  THEN                              AXDX   712
        IF (<ac;MsupplyMax> .LT. <ac;DesMsup>)  THEN                            AXDX   713
          IF (<ac;ChokeHours> .EQ. 0)  THEN                                     AXDX   714
            SST = RefgT_fP(Jre, <Xro.Poutlet>)                                  AXDX   715
            SCT = RefgT_fP(Jre, <Xri.Pinlet>)                                   AXDX   716
            Jna = Jparent(<ac;Parent>)                                          AXDX   717
            CALL MSGSIM(-3,II,II,II,II)                                         AXDX   718
            WRITE (IOUTPT,9102)  (<na:NAME>,II=1,8),                            AXDX   719
     &                           SST, SCT, IMO, IDAY, IHR                       AXDX   720
          ENDIF                                                                 AXDX   721
          <ac;ChokeHours> = <ac;ChokeHours> + 1                                 AXDX   722
        ENDIF                                                                   AXDX   723
      ENDIF                                                                     AXDX   724
                                                                                AXDX   725
c              If defrost cycle this hour                                       AXDX   726
      IF (<ac;DefrostReqd> .EQ. 1)  THEN                                        AXDX   727
c              Check if defrost cycle complete                                  AXDX   728
        IF (<ac;Mfrost'> .GT. <ac;Mfrost>*0.25)  THEN                           AXDX   729
          IF (<ac;FlagDefCap> .EQ. 0)  THEN                                     AXDX   730
            Jna = Jparent(<ac;Parent>)                                          AXDX   731
            CALL MSGSIM(-3,II,II,II,II)                                         AXDX   732
            WRITE (IOUTPT,9104)  (<na:NAME>,II=1,8),                            AXDX   733
     &                           <ac;Mfrost'>, <ac;Mfrost>,                     AXDX   734
     &                           IMO,IDAY,IHR                                   AXDX   735
          ENDIF                                                                 AXDX   736
          <ac;FlagDefCap> = <ac;FlagDefCap> + 1                                 AXDX   737
        ENDIF                                                                   AXDX   738
c              convert defrost times to minutes                                 AXDX   739
        <ac;DefTime>     = <ac;DefrostFrac> * 60.                               AXDX   740
        <ac;DefTimeReqd> = <ac;DefTimeReqd> * 60.                               AXDX   741
      ENDIF                                                                     AXDX   742
c              If frost build-up with no defroster                              AXDX   743
      IF (<ac:DEF-TYPE> .EQ. 0  .AND.  <ac;Mfrost''> .GT. 0.                    AXDX   744
     &                            .AND.  <ac;NoDefrostMsg> .EQ. 0)  THEN        AXDX   745
        Jna = Jparent(<ac;Parent>)                                              AXDX   746
        CALL MSGSIM(-2,II,II,II,II)                                             AXDX   747
        WRITE (IOUTPT,9106)  (<na:NAME>,II=1,8), IMO, IDAY, IHR                 AXDX   748
        <ac;NoDefrostMsg> = 1                                                   AXDX   749
      ENDIF                                                                     AXDX   750
c                                                                               AXDX   751
c                                                                               AXDX   752
c ============ STATISTICS - YEARLY DATA ======================================= AXDX   753
      CASE (47)                                                                 AXDX   754
c                                                                               AXDX   755
c              Number of hours refrigerant flow choked                          AXDX   756
      IF (<ac;ChokeHours> .GT. 0)  THEN                                         AXDX   757
        CALL MSGSIM(-3,II,II,II,II)                                             AXDX   758
        WRITE (IOUTPT,9108)  (<na:NAME>,II=1,8), <ac;ChokeHours>                AXDX   759
      ENDIF                                                                     AXDX   760
c                                                                               AXDX   761
c                                                                               AXDX   762
c ============ DESIGN CALCULATIONS - RATED UA ================================= AXDX   763
      CASE (110)                                                                AXDX   764
c                                                                               AXDX   765
c              Check heat-exchanger resistances for consistency                 AXDX   766
      IF (<ac:SUP-RES>+<ac:AIR-RES> .gt. 0.9)  THEN                             AXDX   767
        Jna = Jparent(Kac)                                                      AXDX   768
        CALL MSGSIM(-1,II,II,II,II)                                             AXDX   769
        WRITE (IOUTPT, 9000)  (<na:NAME>,II=1,8)                                AXDX   770
        CALL MessageBox( NULL,                                                  AXDX   771
     &    'Invalid internal/external resistances'//char(0),                     AXDX   772
     &    'Heat-Exchanger Errors'//char(0),                                     AXDX   773
     &    MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                  AXDX   774
        IwinReturn = 1                                                          AXDX   775
        RETURN                                                                  AXDX   776
      ENDIF                                                                     AXDX   777
c              enthalpy of melted frost                                         AXDX   778
      <ac;Hmelt> = Hliq(<ac:MELT-T>)                                            AXDX   779
c                                                                               AXDX   780
c              Specific heat for refrigerant                                    AXDX   781
      <ac;CpSupply> = 1.E20                                                     AXDX   782
      ErrorMax      = <sp:ERROR-LOAD> / 10.                                     AXDX   783
c                                                                               AXDX   784
c              dT between refrigerant and leaving air                           AXDX   785
c              Required suction pressure and design refrigerant flow            AXDX   786
      SST          = <Xao.Treqd> - <ac:SST-SUPPLY-TD>                           AXDX   787
      SST          = MIN(SST, <Xai.Tinlet>-<ac:SUPERHEAT-DT>)                   AXDX   788
      <ac;SST>     = SST                                                        AXDX   789
      <ro.Moutlet> = MAX(1., <ro.Moutlet>)                                      AXDX   790
      <ao.Moutlet> = <Xai.Minlet>                                               AXDX   791
c              entering enthalpy and dewpoint                                   AXDX   792
      AirHi    = HAir(<Xai.Tinlet>, <Xai.Winlet>)                               AXDX   793
      AirTdew  = Dewpt(<Xai.Winlet>, BLDGP)                                     AXDX   794
c                                                                               AXDX   795
c              Iterate to solve for resistances                                 AXDX   796
      ModeCoil = 1                                                              AXDX   797
      dTreqd = <Xai.Tinlet> - <Xao.Treqd>   ! required temperature drop         AXDX   798
      Rcoil  = dTreqd / <Xai.Qinlet>        ! initial guess                     AXDX   799
      DO iRcoil=1,100                                                           AXDX   800
        Rair = Rcoil * <ac:AIR-RES>         ! airside resistance                AXDX   801
        Rhx  = Rcoil - Rair                 ! hx&refg resistance                AXDX   802
        Call AirCoilLoad                                                        AXDX   803
c              correct internal resistance                                      AXDX   804
        Error = (<Xai.Tinlet>-<ao.Toutlet>) / dTreqd                            AXDX   805
        Rcoil = Rcoil * Error                                                   AXDX   806
        IF (ABS(1.-Error) .LT. 0.005)  Exit                                     AXDX   807
        IF (iRcoil .EQ. 100)                                                    AXDX   808
     &    CALL CnvgMsg2(1, Routine, Jparent(<ac;Parent>))                       AXDX   809
      ENDDO                                                                     AXDX   810
c                                                                               AXDX   811
c              Rated UA                                                         AXDX   812
      <ac;RatedUA> = 1. / Rcoil                                                 AXDX   813
      IF (<ac:COIL-UA> .NE. 0.)  THEN                                           AXDX   814
        IF (<ac:COIL-UA> .lt. <ac;RatedUA>)  THEN                               AXDX   815
          CALL MSGSIM(-2,II,II,II,II)                                           AXDX   816
          Jna = Jparent(<ac;Parent>)                                            AXDX   817
          WRITE (IOUTPT, 9005) (<na:NAME>,II=1,8),                              AXDX   818
     &                         <ac:COIL-UA>, <ac;RatedUA>                       AXDX   819
          CALL MessageBox( NULL,                                                AXDX   820
     &     'Fixture has undersized coil'//char(10)//char(13)//                  AXDX   821
     &     ' - Will override size'//char(0),                                    AXDX   822
     &     'REFG-FIXTURE Errors'//char(0),                                      AXDX   823
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                AXDX   824
        ELSE                                                                    AXDX   825
          <ac;RatedUA> = <ac:COIL-UA>                                           AXDX   826
          Rcoil        = 1. / <ac:COIL-UA>                                      AXDX   827
          Rair         = Rcoil * <ac:AIR-RES>                                   AXDX   828
          Rhx          = Rcoil - Rair                                           AXDX   829
          Call AirCoilLoad                                                      AXDX   830
        ENDIF                                                                   AXDX   831
      ENDIF                                                                     AXDX   832
      <ac;Rdemand>  = Rcoil * <ac:AIR-RES>                                      AXDX   833
      <ac;Rsupply>  = Rcoil * <ac:SUP-RES>                                      AXDX   834
      <ac;Rmedia>   = Rcoil - (<ac;Rdemand>+<ac;Rsupply>)                       AXDX   835
      <ac;Capacity> = <ac;Qair>                                                 AXDX   836
c                                                                               AXDX   837
c              set up the airside fluid properties                              AXDX   838
      CALL FluidFilm_Design(1, <ac;FluidPropDem>, <ac;Rdemand>, xx,             AXDX   839
     &                         <ao.Moutlet>, <Xai.Tinlet>, -<ac;Qair>)          AXDX   840
c                                                                               AXDX   841
c              Rated refrigerant flow; assume liquid @ 95F rating               AXDX   842
      dHrefg       = <ro.Houtlet> - RefgH_Liquid_fT(Jre, 95.)                   AXDX   843
      <ac;DesMsup> = <ac;Qsupply>/dHrefg                                        AXDX   844
      IF (<ac:SUPPLY-FLOW> .GT. 0.)  THEN                                       AXDX   845
        IF (<ac:SUPPLY-FLOW> .lt. <ac;DesMsup>)  THEN                           AXDX   846
          CALL MSGSIM(-2,II,II,II,II)                                           AXDX   847
          Jna = Jparent(<ac;Parent>)                                            AXDX   848
          WRITE (IOUTPT, 9006) (<na:NAME>,II=1,8),                              AXDX   849
     &                         <ac:SUPPLY-FLOW>, <ac;DesMsup>                   AXDX   850
          CALL MessageBox( NULL,                                                AXDX   851
     &     'Fixture has undersized coil'//char(10)//char(13)//                  AXDX   852
     &     ' - Will override size'//char(0),                                    AXDX   853
     &     'REFG-FIXTURE Errors'//char(0),                                      AXDX   854
     &      MB_OK + MB_ICONSTOP + MB_TASKMODAL )                                AXDX   855
        ELSE                                                                    AXDX   856
          <ac;DesMsup> = <ac:SUPPLY-FLOW>                                       AXDX   857
        ENDIF                                                                   AXDX   858
      ENDIF                                                                     AXDX   859
      CALL FluidFilm_Design(1, <ac;FluidPropSup>, <ac;Rsupply>, xx,             AXDX   860
     &                         <ac;DesMsup>, SST, <ac;Qsupply>)                 AXDX   861
c                                                                               AXDX   862
c              CoilBF for defrost calculations                                  AXDX   863
      <ac;CoilBF> = Exp(1./ (-<ao.Moutlet>*<ac;CpDemand>*<ac;Rdemand>))         AXDX   864
c              mass and energy in defrost                                       AXDX   865
      <ac;Mlatent>   = MAX(0., <ao.Moutlet>*(<Xai.Winlet>-<ao.Woutlet>))        AXDX   866
      <ac;DesMfrost> = <ac;Mlatent> * <ac;FracFrosted>                          AXDX   867
      <ac;DesQfrost> = <ac;DesMfrost> * Hfrost                                  AXDX   868
c                                                                               AXDX   869
c                                                                               AXDX   870
c ============ DESIGN CALCULATIONS - AIRSIDE ================================== AXDX   871
      CASE (111)                                                                AXDX   872
c                                                                               AXDX   873
c              Air inlet conditions                                             AXDX   874
      <ao.Moutlet> = <Xai.Minlet>                                               AXDX   875
      <ai.Minlet>  = <Xai.Minlet>                                               AXDX   876
      AirHi        = HAir(<Xai.Tinlet>, <Xai.Winlet>)                           AXDX   877
      AirTdew      = Dewpt(<Xai.Winlet>, Patm)                                  AXDX   878
c              HX resistance assuming no frost buildup                          AXDX   879
      <ac;Rmedia'> = <ac;Rmedia>                                                AXDX   880
c                                                                               AXDX   881
c              Air outlet temperature at bottom and top of control band         AXDX   882
      TsetMin = <Xao.Treqd> - 0.01                                              AXDX   883
      TsetMax = <Xao.Treqd> + 0.01                                              AXDX   884
      dTband  = 0.02                                                            AXDX   885
c              get the required suction conditions                              AXDX   886
      Call AirCoilReqdSuction                                                   AXDX   887
      <ao.Qoutlet> = <ac;Qair>                                                  AXDX   888
c                                                                               AXDX   889
c                                                                               AXDX   890
c ============ DESIGN CALCULATIONS - REFRIGERANT SIDE ========================= AXDX   891
      CASE (112)                                                                AXDX   892
c                                                                               AXDX   893
c              required suction pressure                                        AXDX   894
      Psuction = RefgP_fT(Jre, <ac;SSTreqd>-<ac:MAX-FROST-DT>)                  AXDX   895
c                                                                               AXDX   896
c              Refrigerant conditions at outlet to suction                      AXDX   897
      <ro.Houtlet> = RefgH_Vapor_fSP(Jre, <ac:SUPERHEAT-DT>, Psuction)          AXDX   898
      <ro.Moutlet> = <ac;Qsupply> / (<ro.Houtlet>-<Xri.Hinlet>)                 AXDX   899
      <ro.Mreqd>   = <ro.Moutlet>                                               AXDX   900
c              effect of control valve                                          AXDX   901
      IF (<ac:CTRL-VALVE-DT> .EQ. 0.)  THEN                                     AXDX   902
        dPctrl = 0.                                                             AXDX   903
      ELSE                                                                      AXDX   904
        dPctrl = Psuction-RefgP_fT(Jre, <ac;SSTreqd>-<ac:CTRL-VALVE-DT>)        AXDX   905
        <ac;CtrlValveDP> = dPctrl                                               AXDX   906
        IF (<ac:SUPPLY-FLOW> .GT. 0.  .AND.  <ro.Moutlet> .GT. 0.)              AXDX   907
     &    dPctrl = dPctrl * (<ro.Moutlet>/<ac:SUPPLY-FLOW>)**1.87               AXDX   908
        dPctrl   = MAX(dPctrl, <ac:MIN-CTRL-DP>)                                AXDX   909
      ENDIF                                                                     AXDX   910
      <ro.Preqd>   = Psuction - dPctrl                                          AXDX   911
      <ri.Qinlet>  = <ro.Moutlet> * (<Xri.Hinlet>-AA(<ac;RefgHrefPtr>))         AXDX   912
      <ro.Qoutlet> = <ri.Qinlet> + <ac;Qsupply>                                 AXDX   913
c              Refrigerant conditions at inlet from liquid                      AXDX   914
      <ri.Minlet> = <ro.Moutlet>                                                AXDX   915
      <ri.Mreqd>  = <ro.Moutlet>                                                AXDX   916
      dPhx        = <ac:SUPPLY-DP>                                              AXDX   917
      IF (<ac:SUPPLY-FLOW> .GT. 0.  .AND.  <ri.Minlet> .GT. 0.)                 AXDX   918
     &  dPhx = dPhx * (<ri.Minlet>/<ac:SUPPLY-FLOW>)**1.87                      AXDX   919
      <ri.Preqd> = Psuction + dPhx                                              AXDX   920
c              Liquid should be delivered no warmer than saturation             AXDX   921
      <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                                  AXDX   922
c                                                                               AXDX   923
c              Check for convergence on outlet conditions                       AXDX   924
      CALL CnvgCheck(1, <ac;SupplyHsty>)                                        AXDX   925
c                                                                               AXDX   926
c                                                                               AXDX   927
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== AXDX   928
      CASE (119)                                                                AXDX   929
c                                                                               AXDX   930
      <ac;Capacity> = <ac;Qsupply>                                              AXDX   931
c                                                                               AXDX   932
      <ac;1/dPsupplyIn> = 1. / <ac:SUPPLY-DP>                                   AXDX   933
      <ac;1/dPsupply>   = 1. / (<ac:SUPPLY-DP>+<ac;CtrlValveDP>)                AXDX   934
      <ac;MaxMsup> = <ac;DesMsup> * 2.0     ! maximum allowed refrigerant flow  AXDX   935
      <ac;MaxMdem> = <ao.Moutlet> * 2.0     ! maximum airflow                   AXDX   936
      IF (<ac;DesMsup> .GT. 0.)                                                 AXDX   937
     &  <ac;1/DesMsup> = 1.0/<ac;DesMsup>                                       AXDX   938
c                                                                               AXDX   939
c              Design refrigerant volume and density at outlet                  AXDX   940
      <ac;DesignOutletV> = RefgV_fPH(Jre, <Xro.Poutlet>, <ro.Houtlet>)          AXDX   941
      <ac;DesignOutletD> = 1.0 / <ac;DesignOutletV>                             AXDX   942
c              Cut throttling range in half for easier hourly use               AXDX   943
      <ac;Throttle/2> = <ac:TEMP-THROTTLE> / 2.                                 AXDX   944
c              Initialize hourly media resistance - may be adjusted             AXDX   945
c              hourly for frost                                                 AXDX   946
      <ac;Rmedia'> = <ac;Rmedia>                                                AXDX   947
c                                                                               AXDX   948
c              Frost conditions                                                 AXDX   949
      IF (<ac:DEF-TYPE> .NE. 0)  THEN                                           AXDX   950
c              Maximum allowable frost buildup                                  AXDX   951
        IF (<ac:MAX-FROST> .GT. 0.)  THEN                                       AXDX   952
          <ac;MaxFrost> = <ac:MAX-FROST>                                        AXDX   953
        ELSE                                                                    AXDX   954
          <ac;MaxFrost> = <ac;DesMfrost> * 24. / <ac:NUM-DEF/DAY>               AXDX   955
c              adjust for amount that may redeposit on product                  AXDX   956
          IF (<ac:FAN-W/DEFROST> .EQ. 0)                                        AXDX   957
     &      <ac;MaxFrost> = <ac;MaxFrost> * 2.0                                 AXDX   958
        ENDIF                                                                   AXDX   959
        IF (<ac;MaxFrost> .LT. 0.00001)  <ac;MaxFrost> = 1.E10                  AXDX   960
c              invert for usage hourly                                          AXDX   961
        <ac;1/MaxFrost> = 1.0 / <ac;MaxFrost>                                   AXDX   962
c              resistance due to frost buildup                                  AXDX   963
        <ac;Rfrost> = <ac:MAX-FROST-DT> / <ac;Qsupply>                          AXDX   964
c              convert defrost duration from minutes to hours, cannot           AXDX   965
c              be whole hour                                                    AXDX   966
        <ac;DefDuration> = <ac:DEF-DURATION> / 60.                              AXDX   967
        <ac;DefDuration> = MIN(<ac;DefDuration>, 0.99)                          AXDX   968
c              defrost load                                                     AXDX   969
        Qdefrost = <ac;DesMfrost>*<ac;Hmelt> - <ac;DesQfrost>                   AXDX   970
        Qdefrost = Qdefrost * 24. / <ac:NUM-DEF/DAY>                            AXDX   971
c              defroster capacity                                               AXDX   972
        IF (<ac:DEF-CAP> .NE. 0.)  THEN                                         AXDX   973
          <ac;DefCapacity> = <ac:DEF-CAP>                                       AXDX   974
        ELSE                                                                    AXDX   975
          Cap      = Qdefrost / <ac;DefDuration>                                AXDX   976
          Tdef     = <Xai.Tinlet> + <ac:DEF-DT>                                 AXDX   977
          IF (<ac:FAN-W/DEFROST> .EQ. 1)  THEN                                  AXDX   978
c              Fan stays off during defrost                                     AXDX   979
            <ac;DefCapacity> = Cap * <ac:DEFROST-RATIO> / <ac:DEF-EFF>          AXDX   980
          ELSE                                                                  AXDX   981
c              Fan stays on during defrost                                      AXDX   982
            Qdef  = Cap                                                         AXDX   983
            Wcoil = Wfunc(32., 100., BLDGP)                                     AXDX   984
            Hcoil = HAir(32., Wcoil)                                            AXDX   985
            SELECT CASE (<ac:DEF-TYPE>)                                         AXDX   986
              CASE (1)  ! Electric                                              AXDX   987
                dH     = Qdef / <ao.Moutlet>                                    AXDX   988
                Hinlet = (Hcoil*(1.-<ac;CoilBF>) + dH)                          AXDX   989
     &                                          / (1.-<ac;CoilBF>)              AXDX   990
                Tinlet = DBair(Hinlet,<Xai.Winlet>)                             AXDX   991
                Cap    = MAX(0., <ao.Moutlet> * CpAir(<Xai.Winlet>)             AXDX   992
     &                                        * (Tdef-Tinlet))                  AXDX   993
                <ac;DefCapacity> = Cap*<ac:DEFROST-RATIO> / <ac:DEF-EFF>        AXDX   994
              CASE (2)  ! Hot-gas                                               AXDX   995
                Hinlet  = HAir(Tdef,<Xai.Winlet>)                               AXDX   996
                Houtlet = Hcoil + (Hinlet-Hcoil)*<ac;CoilBF>                    AXDX   997
                Cap     = MAX(0., Qdef  + <ao.Moutlet>*(Houtlet-Hinlet))        AXDX   998
                <ac;DefCapacity> = Cap*<ac:DEFROST-RATIO> / <ac:DEF-EFF>        AXDX   999
              CASE (3)  ! Off-cycle                                             AXDX  1000
                <ac;DefCapacity> = Qdef                                         AXDX  1001
            END SELECT                                                          AXDX  1002
          ENDIF                                                                 AXDX  1003
        ENDIF  ! ev:DEF-CAP                                                     AXDX  1004
        <ac;Qdefroster> = <ac;DefCapacity> * <ac;DefDuration>                   AXDX  1005
        <ac;QdefLoss>   = <ac;Qdefroster> - Qdefrost                            AXDX  1006
c              initialize leaving conditions during defrost - these do          AXDX  1007
c              not have to be particularly accurate                             AXDX  1008
        <ac;DefrostFrac'> = <ac;DefDuration>                                    AXDX  1009
        <ac;CpDemand''>   = 0.244                                               AXDX  1010
c                                                                               AXDX  1011
      ENDIF  ! ev:DEF-TYPE                                                      AXDX  1012
c                                                                               AXDX  1013
c                                                                               AXDX  1014
c ============ ATTACHMENTS ==================================================== AXDX  1015
c                                                                               AXDX  1016
c              Initial attachments                                              AXDX  1017
      CASE (201)                                                                AXDX  1018
c              Component pointers, schedules and curves                         AXDX  1019
        <ac:LIQUID-CKT>    = Jcomponent(22, <ac:LIQUID-CKT>)                    AXDX  1020
        <ac:SUCTION-CKT>   = Jcomponent(22, <ac:SUCTION-CKT>)                   AXDX  1021
        <ac:HOT-GAS-CKT>   = Jcomponent(22, <ac:HOT-GAS-CKT>)                   AXDX  1022
        <ac:ELEC-METER>    = Jcomponent(13, <ac:ELEC-METER>)                    AXDX  1023
        <ac:COST-DATA>     = Jcomponent(18, <ac:COST-DATA>)                     AXDX  1024
        <ac:DEF-SCH>       = Jsched(<ac:DEF-SCH>)                               AXDX  1025
c                                                                               AXDX  1026
c              Create fluid properties subcomponents                            AXDX  1027
        Jrc = <ac:LIQUID-CKT>                                                   AXDX  1028
        Jrs = <rc:/RefgSystem/>                                                 AXDX  1029
        <ac;FluidPropSup> = NewFluidProperties(Kac, Jrs,32,                     AXDX  1030
     &                                   0., 0., 0., 0.,                        AXDX  1031
     &                                   0., 0., 0., 0.,                        AXDX  1032
     &                                   0., 0., 0., 0., 0.)                    AXDX  1033
        <ac;FluidPropDem> = NewFluidProperties(Kac, 0, 21,                      AXDX  1034
     &                                   0., 0., 0., 0.,                        AXDX  1035
     &                                   0., 0., 0., 0.,                        AXDX  1036
     &                                   0., 0., 0., 0., 0.)                    AXDX  1037
c                                                                               AXDX  1038
c              Second level of attachments                                      AXDX  1039
      CASE (202)                                                                AXDX  1040
c              Check if cross-connected between two different systems           AXDX  1041
        CALL RefgX(Jparent(Kac), <ac:LIQUID-CKT>,<ac:SUCTION-CKT>,              AXDX  1042
     &                                           <ac:HOT-GAS-CKT>)              AXDX  1043
c              Get refrigerant pointer from refg plant                          AXDX  1044
        Jrc = <ac:LIQUID-CKT>                                                   AXDX  1045
        Jrs = <rc:/RefgSystem/>                                                 AXDX  1046
        <ac;Refrigerant> = <rs:REFRIGERANT>                                     AXDX  1047
c                                                                               AXDX  1048
c              Create nodes                                                     AXDX  1049
      CASE (203)                                                                AXDX  1050
c              Airside and supply attachments                                   AXDX  1051
        Keu   = <ac;Parent>                                                     AXDX  1052
        Jsys  = <ac;Parent>                                                     AXDX  1053
        xMult = <ac;Multiplier>                                                 AXDX  1054
        <ac;AirInletNode>  = NewNode(1, 0,Jsys,Kac,Jsys, 42,1,Keu, 1.)          AXDX  1055
        <ac;AirOutletNode> = NewNode(1, 0,Jsys,Kac,Jsys, 41,2,Keu, 1.)          AXDX  1056
        <ac;LiquidNode>    = NewNode(1, Jsys,0,Kac,<ac:LIQUID-CKT>,             AXDX  1057
     &                                                  61,1,Keu, xMult)        AXDX  1058
        <ac;SuctionNode>   = NewNode(1, Jsys,0,Kac,<ac:SUCTION-CKT>,            AXDX  1059
     &                                                  62,2,Keu, xMult)        AXDX  1060
c              attachments for hot-gas defrost                                  AXDX  1061
        IF (<ac:DEF-TYPE> .EQ. 2)  THEN                                         AXDX  1062
          <ac;HotGasNode>    = NewNode(1, Jsys,0,Kac,<ac:HOT-GAS-CKT>,          AXDX  1063
     &                                                  63,2,Keu, xMult)        AXDX  1064
          Jrc = <ac:HOT-GAS-CKT>                                                AXDX  1065
          <ac;HotGasRetNode> = NewNode(1, Jsys,0,Kac,<rc:/RefgSystem/>,         AXDX  1066
     &                                                  64,2,Keu, xMult)        AXDX  1067
        ENDIF                                                                   AXDX  1068
c              attach to electric meter (electric defrost)                      AXDX  1069
        IF (<ac:ELEC-METER> .GT. 0)  THEN                                       AXDX  1070
          Jme = <ac:ELEC-METER>                                                 AXDX  1071
          <ac:ELEC-METER> = NewNode(1, Jsys,0,Kac,Jme, 11,2,Keu, xMult)         AXDX  1072
        ENDIF                                                                   AXDX  1073
c                                                                               AXDX  1074
c              Links, lists                                                     AXDX  1075
      CASE (205)                                                                AXDX  1076
c              Get pointer to reference enthalpy from liquid trunk              AXDX  1077
        Jrc              = <ac:LIQUID-CKT>                                      AXDX  1078
        <ac;RefgHrefPtr> = IA_RefgHRef(<rc:/RefgSystem/>)                       AXDX  1079
c                                                                               AXDX  1080
c              Histories                                                        AXDX  1081
      CASE (208)                                                                AXDX  1082
        Jsys = <ac;Parent>                                                      AXDX  1083
c              defrost histories                                                AXDX  1084
c              defroster power                                                  AXDX  1085
        KliIter = 0                                                             AXDX  1086
        SELECT CASE (<ac:DEF-TYPE>)                                             AXDX  1087
          CASE (1)  ! electric                                                  AXDX  1088
            CALL ListAdd(KliIter, <ac:ELEC-METER>, 0)                           AXDX  1089
          CASE (2)  ! hot gas                                                   AXDX  1090
            CALL ListAdd(KliIter, <ac;HotGasNode>, 0)                           AXDX  1091
            CALL ListAdd(KliIter, <ac;HotGasRetNode>, 0)                        AXDX  1092
          CASE (3)  ! off-cycle                                                 AXDX  1093
        END SELECT                                                              AXDX  1094
        KliX = KliIter                                                          AXDX  1095
        CALL ListXNodes(KliIter, KliX)                                          AXDX  1096
        <ac;DefPwrHsty> = NewHistory(Jsys,0,Kac, KliX, 0,                       AXDX  1097
     &                        5, 3, 1.5,                                        AXDX  1098
     &                        <#ac;Qdefroster>, <sp:ERROR-LOAD>, 2,             AXDX  1099
     &                        0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)           AXDX  1100
c              Refrigerant outlet history                                       AXDX  1101
        Kli = 0                                                                 AXDX  1102
        CALL ListAdd(Kli, <ac;LiquidNode>)                                      AXDX  1103
        CALL ListAdd(Kli, <ac;SuctionNode>)                                     AXDX  1104
        KliX = Kli                                                              AXDX  1105
        CALL ListXNodes(Kli, KliX)                                              AXDX  1106
        <ac;SupplyHsty> = NewHistory(Jsys,0,Kac, KliX, Kro,                     AXDX  1107
     &                       5, 3, 1.0,                                         AXDX  1108
     &                       <#ro.Qoutlet>, <sp:ERROR-LOAD>, 3,                 AXDX  1109
     &                       <#ro.Moutlet>, <sp:ERROR-FLOW>, 3,                 AXDX  1110
     &                       <#ro.Mreqd>  , <sp:ERROR-FLOW>, 3,                 AXDX  1111
     &                       0,0.,0, 0,0.,0, 0,0.,0)                            AXDX  1112
c              Coil history                                                     AXDX  1113
        ListDamp = 0                                                            AXDX  1114
        CALL ListAddVars(ListDamp, <#ac;Qsupply>, <#ac;FracWet>)                AXDX  1115
        CALL ListAddVars(ListDamp, <#ao.Toutlet>, 0)                            AXDX  1116
        CALL ListAddVars(ListDamp, <#ao.Woutlet>, 0)                            AXDX  1117
        CALL ListAddVars(ListDamp, <#ro.Moutlet>, 0)                            AXDX  1118
        <ac;CoilHsty> = NewHistory(0,0,Kac, 0, ListDamp,                        AXDX  1119
     &                    0, 3, 1.5,                                            AXDX  1120
     &                    <#ac;Qsupply>, <sp:ERROR-LOAD>/2., 2,                 AXDX  1121
c ??     &                    <#ac;FracWet>,            0.05, 2,                AXDX  1122
     &                    0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)               AXDX  1123
c              Extraction terms history                                         AXDX  1124
        <ac;UAerHsty> = NewHistory(0,0,Kac, 0, 0,                               AXDX  1125
     &                    0, 6, 1.2,                                            AXDX  1126
     &                    <#ac;TcoilUA> , <sp:ERROR-LOAD>, 2,                   AXDX  1127
     &                    <#ac;SurfWoUA>, <sp:ERROR-LOAD>, 2,                   AXDX  1128
     &                    <#ac;TcoilNoQ>,    <sp:ERROR-T>, 1,                   AXDX  1129
     &                    <#ac;SurfWo>  ,    <sp:ERROR-W>, 1,                   AXDX  1130
     &                    0,0.,0, 0,0.,0)                                       AXDX  1131
c              SSTreqd history                                                  AXDX  1132
        ListDamp = 0                                                            AXDX  1133
        CALL ListAddVars(ListDamp, <#ac;SSTreqd>, 0)                            AXDX  1134
        CALL ListAddVars(ListDamp, <#ao.Toutlet>, 0)                            AXDX  1135
        CALL ListAddVars(ListDamp, <#ao.Woutlet>, 0)                            AXDX  1136
        CALL ListAddVars(ListDamp, <#ro.Moutlet>, 0)                            AXDX  1137
        <ac;TreqdHsty> = NewHistory(0,0,Kac, 0, ListDamp,                       AXDX  1138
     &                       0, 3, 1.5,                                         AXDX  1139
     &                       <#ac;SSTreqd>, <sp:ERROR-T>, 1,                    AXDX  1140
     &                       0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0, 0,0.,0)            AXDX  1141
c                                                                               AXDX  1142
c              History lists                                                    AXDX  1143
      CASE (209)                                                                AXDX  1144
        Jsys = <ac;Parent>                                                      AXDX  1145
c              External loads                                                   AXDX  1146
        CALL ListHstys(<ac;Hstys>, Jsys, 0, 0)                                  AXDX  1147
c                                                                               AXDX  1148
c              Dump pointers                                                    AXDX  1149
      CASE (210)                                                                AXDX  1150
        IF (<ac;Previous> .EQ. 0)  WRITE (IOUTPT, 9201)                         AXDX  1151
        Jna = <ac;Parent>                                                       AXDX  1152
        WRITE (IOUTPT, 9202)  (<na:NAME>,II=1,8),                               AXDX  1153
     &    Kac, Jna, Kai, Kao, Kri, Kro,                                         AXDX  1154
     &    <ac;HotGasNode>, <ac;HotGasRetNode>,                                  AXDX  1155
     & <ac;FluidPropSup>, <ac;FluidPropDem>                                     AXDX  1156
c                                                                               AXDX  1157
c                                                                               AXDX  1158
      END SELECT  ! Mode                                                        AXDX  1159
c                                                                               AXDX  1160
      RETURN                                                                    AXDX  1161
c                                                                               AXDX  1162
c              Message formats                                                  AXDX  1163
 9000 FORMAT(14x,'Cooling coil: ',8A4,' has supply'                    /        AXDX  1164
     &14x,'side and demand side film resistances > 1.0'                )        AXDX  1165
 9001 FORMAT(14x,'Cooling coil: ',8A4,' has a capacity'                /        AXDX  1166
     &14x,'smaller than the design load.'                              /        AXDX  1167
     &14x,'Load: ',F10.0,' Capacity: ',F10.0                           )        AXDX  1168
 9003 FORMAT(14x,'Cooling coil: ',8A4,' design'                        /        AXDX  1169
     &14x,'calculations have failed to converge.'                      )        AXDX  1170
 9004 FORMAT(14x,'Cooling coil: ',8A4,' has unrealistic'               /        AXDX  1171
     &14x,'design air conditions that force the apparatus dewpoint and'/        AXDX  1172
     &14x,'coil bypass factor to be:',2F7.2                            )        AXDX  1173
 9005 FORMAT(14x,'Cooling Coil: ',8A4,' has a specified'               /        AXDX  1174
     &14x,'coil UA of',f9.1,' Btu/F, which is smaller than the'        /        AXDX  1175
     &14x,'required UA of',f9.1,' The UA will be increased to the'     /        AXDX  1176
     &14x,'required UA.'                                               )        AXDX  1177
 9006 FORMAT(14x,'Cooling Coil: ',8A4,' has a specified'               /        AXDX  1178
     &14x,'refrigerant flow of',f9.1,' Lbs/hr, which is smaller than'  /        AXDX  1179
     &14x,'the required flow of',f9.1,' The flow will be increased to' /        AXDX  1180
     &14x,'the required flow.'                                         )        AXDX  1181
 9101 FORMAT(14x,'Cooling coil: ',8A4,' cannot meet the'               /        AXDX  1182
     &14x,'required temperature setpoint. First occurrence: ',                  AXDX  1183
     &I2,2('/',I2)                                                     )        AXDX  1184
 9102 FORMAT(14x,'Cooling coil: ',8A4,' has a choked'                  /        AXDX  1185
     &14x,'refrigerant flow due to insufficient pressure differential' /        AXDX  1186
     &14x,'between the liquid and suction. SST/SCT at fixture:',2F4.0  /        AXDX  1187
     &14x,'First occurrence: '3(I2,'/')                                )        AXDX  1188
 9103 FORMAT(14x,'Cooling coil: ',8A4,' has a frost'                   /        AXDX  1189
     &14x,'buildup of',F6.1,' lbs, which is more than twice the design'/        AXDX  1190
     &14x,'quantity.  Non-scheduled defrost cycle will be initiated.'  /        AXDX  1191
     &14x,'First occurrance: ',I2,2('/',I2)                            )        AXDX  1192
 9104 FORMAT(14x,'Cooling coil: ',8A4,' defrost cycle'                 /        AXDX  1193
     &14x,'has',F6.1,' lbs frost remaining out of',F6.1,' total'       /        AXDX  1194
     &14x,'First occurrance: ',I2,2('/',I2)                            )        AXDX  1195
 9106 FORMAT(14x,'Cooling coil: ',8A4,' is experiencing'               /        AXDX  1196
     &14x,'a frost condition, but does not have a defroster. Frost'    /        AXDX  1197
     &14x,'buildup will be ignored.  First occurrence: ',I2,2('/',I2)  )        AXDX  1198
 9107 FORMAT(14x,'Cooling coil: ',8A4,' has failed to'                 /        AXDX  1199
     &14x,'converge in AirCoilLoad'                                    )        AXDX  1200
 9108 FORMAT(14x,'Cooling coil: ',8A4,' had a choked'                  /        AXDX  1201
     &14x,'refrigerant flow',I5,' hours.'                              )        AXDX  1202
 9201 FORMAT(/' DX Coils                               Kac    Parent',          AXDX  1203
     &'       Kai       Kao       Kri       Kro   HGD Kri   HGD Kro',           AXDX  1204
     &'  Prop Sup  Prop Dem'                                           /        AXDX  1205
     &1x,32('-'),10('  --------'))                                              AXDX  1206
 9202 FORMAT(1x,8A4,10I10)                                                      AXDX  1207
c                                                                               AXDX  1208
c                                                                               AXDX  1209
      CONTAINS                                                                  AXDX  1210
c ============== AirCoilLoad ================================================== AXDX  1211
      Subroutine AirCoilLoad                                                    AXDX  1212
c                                                                               AXDX  1213
c              Calculates the heat transferred and air outlet conditions        AXDX  1214
c              given the inlet conditions                                       AXDX  1215
c                                                                               AXDX  1216
c              ModeCoil  1  SST set externally, calculate refg mass             AXDX  1217
c                        2  Thermostat out of control, calc SST and refg        AXDX  1218
c                        3  EPR valve, calc SST and refg mass                   AXDX  1219
c                        4  Choked flow due to insufficient dP,                 AXDX  1220
c                             SST and refg mass set externally                  AXDX  1221
c                                                                               AXDX  1222
      Logical IterReqdHsty                                                      AXDX  1223
                                                                                AXDX  1224
      CALL HistoryInit(<ac;CoilHsty>)                                           AXDX  1225
c                                                                               AXDX  1226
c              Start of iterative loop                                          AXDX  1227
      nCoilQ = 0                                                                AXDX  1228
10010 nCoilQ = nCoilQ + 1                                                       AXDX  1229
      IF (nCoilQ .GT. 50)  THEN                                                 AXDX  1230
        CALL CnvgMsg2(4, Routine, Jparent(<ac;Parent>))                         AXDX  1231
        GOTO 10099                                                              AXDX  1232
      ENDIF                                                                     AXDX  1233
c                                                                               AXDX  1234
      SELECT CASE (ModeCoil)                                                    AXDX  1235
        CASE (2)  ! Out of control thermostat                                   AXDX  1236
c              control valve pressure drop                                      AXDX  1237
          dPctrl = (<ro.Moutlet>*<ac;1/DesMsup>)**1.87                          AXDX  1238
          dPctrl = MAX(dPctrl*<ac;CtrlValveDP>, <ac:MIN-CTRL-DP>)               AXDX  1239
          SST    = RefgT_fP(Jre, <Xro.Poutlet>+dPctrl)                          AXDX  1240
        CASE (3)  ! EPR valve                                                   AXDX  1241
c              Control valve pressure drop and throttling range                 AXDX  1242
          dPctrl = (<ro.Moutlet>*<ac;1/DesMsup>)**1.87                          AXDX  1243
          dPctrl = MAX(dPctrl*<ac;CtrlValveDP>, <ac:MIN-CTRL-DP>)               AXDX  1244
          Tsetpt = TsetMin                                                      AXDX  1245
     &                + dTband * MIN(1., <ro.Moutlet>*<ac;1/MsupplyMax>)        AXDX  1246
          SST    = MAX(RefgT_fP(Jre, <Xro.Poutlet>+dPctrl), Tsetpt)             AXDX  1247
      END SELECT  ! ModeCoil                                                    AXDX  1248
c                                                                               AXDX  1249
c              coolant inlet enthalpy at equivalent air                         AXDX  1250
      SupWiSat = Wfunc(SST, 100., Patm)                                         AXDX  1251
      SupWi    = SupWiSat*<ac;FracWet> + <ao.Woutlet>*(1.-<ac;FracWet>)         AXDX  1252
      SupHi    = HAir(SST, SupWi)                                               AXDX  1253
      dWair    = MIN(0., <ao.Woutlet> - <Xai.Winlet>)                           AXDX  1254
c              Make sure supply equivalent air is not greater than              AXDX  1255
c              entering air - this can happen if the previous FracWet           AXDX  1256
c              condition is much wetter than now                                AXDX  1257
      SupHi = MIN(SupHi, AirHi*0.999999)                                        AXDX  1258
c              Air side - average Cp                                            AXDX  1259
      <ac;CpDemand> = CpAir((<Xai.Winlet>+<ao.Woutlet>)*0.5)                    AXDX  1260
c              Coolant side - Calculate the effective specific heat             AXDX  1261
c              corresponding to air at the coil surface condition.  This        AXDX  1262
c              may represent a fully saturated condition, may be                AXDX  1263
c              saturated only at the air outlet (partially wet coil), or        AXDX  1264
c              be at the air humidity (dry coil)                                AXDX  1265
      dT = <ac;SurfTi> - <ac;SurfTo>                                            AXDX  1266
      IF (dT .GT. 0.000001)  THEN                                               AXDX  1267
        <ac;SurfCp> = (<ac;SurfHi> - <ac;SurfHo>) / dT                          AXDX  1268
      ELSE                                                                      AXDX  1269
        <ac;SurfCp> = <ac;CpDemand>                                             AXDX  1270
      ENDIF                                                                     AXDX  1271
c              Create a heat capacity adjustment factor to take into            AXDX  1272
c              account the effect of the enthalpy in condensate/frost           AXDX  1273
c              Frost that deposits on the coil has a negative enthaply          AXDX  1274
c              which will act to increase the heat transport capacity           AXDX  1275
c              of the air.  Condensate is slightly positive.                    AXDX  1276
      IF (dWair .LT. 0.)  THEN                                                  AXDX  1277
        IF (<ac;SurfTo> .LT. 32.)  THEN                                         AXDX  1278
          IF (<ac;Tdry/wet> .LT. 32.)  THEN                                     AXDX  1279
c              wet section of coil is fully frozen                              AXDX  1280
            <ac;FracFrosted> = 1.0                                              AXDX  1281
            TsurfAvg         = (<ac;Tdry/wet>+<ac;SurfTo>) * 0.5                AXDX  1282
            Hfrost           = Hice(TsurfAvg)                                   AXDX  1283
            <ac;Hlatent>     = Hfrost                                           AXDX  1284
          ELSE                                                                  AXDX  1285
c              wet section of coil is partially frozen                          AXDX  1286
            <ac;FracFrosted> = (32.-<ac;SurfTo>)                                AXDX  1287
     &                                     / (<ac;Tdry/wet>-<ac;SurfTo>)        AXDX  1288
            TsurfAvg         = (<ac;Tdry/wet>+32.) * 0.5                        AXDX  1289
            <ac;Hlatent>     = Hliq(TsurfAvg) * (1.-<ac;FracFrosted>)           AXDX  1290
            TsurfAvg         = (32.+<ac;SurfTo>) * 0.5                          AXDX  1291
            Hfrost           = Hice(TsurfAvg)                                   AXDX  1292
            <ac;Hlatent>     = <ac;Hlatent> + Hfrost*<ac;FracFrosted>           AXDX  1293
          ENDIF                                                                 AXDX  1294
        ELSE                                                                    AXDX  1295
c              coil is wet                                                      AXDX  1296
          <ac;FracFrosted> = 0.0                                                AXDX  1297
          TsurfAvg         = (<ac;Tdry/wet>+<ac;SurfTo>) * 0.5                  AXDX  1298
          <ac;Hlatent>     = Hliq(TsurfAvg)                                     AXDX  1299
        ENDIF                                                                   AXDX  1300
        dHlatent = <ac;Hlatent> * dWair                                         AXDX  1301
c              ratio of dQ to dHair taking into account condensate              AXDX  1302
        <ac;dQ/dHair> = 1.0 + dHlatent/(AirHi-<ac;AirHo>)                       AXDX  1303
      ELSE                                                                      AXDX  1304
        <ac;dQ/dHair> = 1.0                                                     AXDX  1305
      ENDIF                                                                     AXDX  1306
c                                                                               AXDX  1307
c              Modify the film resistances for flow and get UA.                 AXDX  1308
c              supply side                                                      AXDX  1309
      IF (Mode .eq. 110)  THEN  ! coil design call                              AXDX  1310
        Rint = <ac;SurfCp> * Rhx                                                AXDX  1311
      ELSE                                                                      AXDX  1312
c              refrigerant and internal resistance; in terms of enthalpy        AXDX  1313
        Rsup = FluidFilm(<ac;FluidPropSup>, <ro.Moutlet>)                       AXDX  1314
        Rint = <ac;SurfCp> * (Rsup+<ac;Rmedia'>)                                AXDX  1315
c              airside                                                          AXDX  1316
        Rair = FluidFilm(<ac;FluidPropDem>, <ao.Moutlet>)                       AXDX  1317
      ENDIF                                                                     AXDX  1318
c              modify airside for a partially wet surface                       AXDX  1319
      Radj    = <ac:DRY/WET-RES>*(1.-<ac;FracWet>) + <ac;FracWet>               AXDX  1320
      Rext    = <ac;CpDemand> * Rair * Radj                                     AXDX  1321
      <ac;UA> = 1. / (Rint + Rext)                                              AXDX  1322
c              Reduce UA for choked refrigerant flow                            AXDX  1323
      IF (ModeCoil .EQ. 4)  <ac;UA> = <ac;UA> * <ac;UAchoke>                    AXDX  1324
c                                                                               AXDX  1325
c              Fluid capacity rates                                             AXDX  1326
      Csup = MAX(0.00001, <ro.Moutlet> * <ac;CpSupply>/<ac;SurfCp>)             AXDX  1327
      Cdem = MAX(0.00001, <ao.Moutlet> * <ac;dQ/dHair>)                         AXDX  1328
      Cmin = MIN(Csup, Cdem)                                                    AXDX  1329
      NTU  = <ac;UA> / Cmin                                                     AXDX  1330
c              Phase-change HX effectiveness                                    AXDX  1331
      eff  = 1.0 - EXP(-NTU)                                                    AXDX  1332
c              Heat transfer - negative Q means heating load                    AXDX  1333
      <ac;Qsupply> = eff * Cmin * (AirHi-SupHi)                                 AXDX  1334
c                                                                               AXDX  1335
c              Leaving conditions                                               AXDX  1336
      <ac;AirHo> = AirHi - <ac;Qsupply>/Cdem                                    AXDX  1337
      SupHo      = SupHi - <ac;Qsupply>/Csup                                    AXDX  1338
c                                                                               AXDX  1339
c              Surface conditions - surface outlet is air outlet end            AXDX  1340
      FracAir     = Rext / (Rint + Rext)                                        AXDX  1341
      <ac;SurfHi> = AirHi + (SupHo-AirHi)*FracAir                               AXDX  1342
      <ac;SurfTi> = AirCoil_Tsurf(<ac;SurfHi>)                                  AXDX  1343
      IF (<ac;SurfTi> .GT. AirTdew)                                             AXDX  1344
     &    <ac;SurfTi> = DBair(<ac;SurfHi>,<Xai.Winlet>)                         AXDX  1345
c                                                                               AXDX  1346
      <ac;SurfHo> = <ac;AirHo> + (SupHi-<ac;AirHo>)*FracAir                     AXDX  1347
      <ac;SurfTo> = AirCoil_Tsurf(<ac;SurfHo>)                                  AXDX  1348
      <ac;SurfWo> = Wfunc(<ac;SurfTo>, 100., Patm)                              AXDX  1349
      IF (<ac;SurfWo> .GE. <Xai.Winlet>)  THEN                                  AXDX  1350
c              Dry coil                                                         AXDX  1351
        <ac;SurfTo>   = DBair(<ac;SurfHo>,<Xai.Winlet>)                         AXDX  1352
        <ac;SurfWo>   = <Xai.Winlet>                                            AXDX  1353
        <ac;FracWet>  = 0.                                                      AXDX  1354
        <ao.Toutlet>  = DBair(<ac;AirHo>, <Xai.Winlet>)                         AXDX  1355
        <ao.Woutlet>  = <Xai.Winlet>                                            AXDX  1356
        <ac;Tdry/wet> = 88888.                                                  AXDX  1357
      ELSE                                                                      AXDX  1358
c              Wet coil - estimate the fraction of the coil surface that        AXDX  1359
c              is wet assuming surface enthalpy change is linear                AXDX  1360
        <ac;Hdry/wet> = HAir(AirTdew, <Xai.Winlet>)                             AXDX  1361
        <ac;Hdry/wet> = MIN(<ac;SurfHi>, MAX(<ac;SurfHo>,<ac;Hdry/wet>))        AXDX  1362
        <ac;Tdry/wet> = AirCoil_Tsurf(<ac;Hdry/wet>)                            AXDX  1363
        dHsurf        = <ac;SurfHi> - <ac;SurfHo>                               AXDX  1364
        IF (ABS(dHsurf) .GT. 0.00001)  THEN                                     AXDX  1365
          <ac;FracWet> = (<ac;Hdry/wet>-<ac;SurfHo>) / dHsurf                   AXDX  1366
        ELSE                                                                    AXDX  1367
          <ac;FracWet> = 1.                                                     AXDX  1368
        ENDIF                                                                   AXDX  1369
c              effectiveness of heat transfer relative to the leaving           AXDX  1370
c              surface enthalpy, and leaving conditions                         AXDX  1371
        <ac;SurfEff> = (AirHi-<ac;AirHo>) / (AirHi-<ac;SurfHo>)                 AXDX  1372
c                                                                               AXDX  1373
c ??           Tout and Wout just for comparison to ao.Toutlet,Woutlet          AXDX  1374
        Tout = <Xai.Tinlet> + (<ac;SurfTo>-<Xai.Tinlet>)*<ac;SurfEff>           AXDX  1375
        Wout = <Xai.Winlet> + (<ac;SurfWo>-<Xai.Winlet>)*<ac;SurfEff>           AXDX  1376
c ??                                                                            AXDX  1377
c              Effectiveness of WET heat transfer relative to the               AXDX  1378
c              leaving surface enthalpy,                                        AXDX  1379
        AirHwet      = <ac;AirHo> + (AirHi-<ac;AirHo>)*<ac;FracWet>             AXDX  1380
        WetEff       = (AirHwet-<ac;AirHo>) / (AirHwet-<ac;SurfHo>)             AXDX  1381
        AirTwet      = DBair(AirHwet, <Xai.Winlet>)                             AXDX  1382
        <ao.Toutlet> = AirTwet                                                  AXDX  1383
     &               + (<ac;SurfTo>-AirTwet)*WetEff                             AXDX  1384
        <ao.Woutlet> = <Xai.Winlet>                                             AXDX  1385
     &               + (<ac;SurfWo>-<Xai.Winlet>)*WetEff                        AXDX  1386
      ENDIF  ! dry vs. wet coil                                                 AXDX  1387
c                                                                               AXDX  1388
c              Leaving refrigerant enthalpy and flow                            AXDX  1389
      dTsuper      = <Xai.Tinlet> - SST                                         AXDX  1390
      dTsuper      = MIN(<ac:SUPERHEAT-DT>, dTsuper)                            AXDX  1391
      <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SST, dTsuper)                         AXDX  1392
      dHrefg       = <ro.Houtlet> - <Xri.Hinlet>                                AXDX  1393
      <ro.Moutlet> = MAX(0.01, <ac;Qsupply>/dHrefg)                             AXDX  1394
c                                                                               AXDX  1395
      CALL CnvgCheck(2, <ac;CoilHsty>)                                          AXDX  1396
      IF (IterReqdHsty(<ac;CoilHsty>)  .OR.  nCoilQ .EQ. 1)  GOTO 10010         AXDX  1397
c              Skip to here if convergence failure                              AXDX  1398
10099 CONTINUE                                                                  AXDX  1399
c              airside heat transferred                                         AXDX  1400
      <ac;Qair> = <ao.Moutlet> * (AirHi - <ac;AirHo>)                           AXDX  1401
c                                                                               AXDX  1402
      End Subroutine AirCoilLoad                                                AXDX  1403
c                                                                               AXDX  1404
c                                                                               AXDX  1405
c ============== AirCoilChoked ================================================ AXDX  1406
      Subroutine AirCoilChoked                                                  AXDX  1407
c                                                                               AXDX  1408
c              Calculates the heat transferred and air outlet conditions        AXDX  1409
c              given the inlet conditions and a choked refrigerant flow         AXDX  1410
c                                                                               AXDX  1411
c              In this mode, the refrigerant does not evaporate over            AXDX  1412
c              the entire HX; instead evaporation occurs over a smaller         AXDX  1413
c              area, thereby reducing the effective UA of the HX.  The          AXDX  1414
c              leaving air temperature and humidity are affected                AXDX  1415
c              accordingly.                                                     AXDX  1416
c                                                                               AXDX  1417
c              In block 'AirCoilLoad', ModeCoil = 4 allows this block to        AXDX  1418
c              set the SST, and enables the ac;UAchoke adjustment term          AXDX  1419
      ModeCoil     = 4                                                          AXDX  1420
      <ac;UAchoke> = 1.                                                         AXDX  1421
c                                                                               AXDX  1422
c              Control valve pressure drop and SST at maximum flow              AXDX  1423
      dPctrl = (<ac;MsupplyMax>*<ac;1/DesMsup>)**1.87                           AXDX  1424
      dPctrl = MAX(dPctrl*<ac;CtrlValveDP>, <ac:MIN-CTRL-DP>)                   AXDX  1425
      SELECT CASE (<ac:TEMP-CTRL>)                                              AXDX  1426
        CASE (2,3)  ! thermostat                                                AXDX  1427
          SST     = RefgT_fP(Jre, <Xro.Poutlet> + dPctrl)                       AXDX  1428
          TsetMin = SSTmin                                                      AXDX  1429
          Call AirCoilLoad                                                      AXDX  1430
        CASE (4,5)  ! local EPR                                                 AXDX  1431
          Tsetpt = TsetMin                                                      AXDX  1432
     &                + dTband * MIN(1., <ro.Moutlet>*<ac;1/MsupplyMax>)        AXDX  1433
          SST    = MAX(RefgT_fP(Jre, <Xro.Poutlet>+dPctrl), Tsetpt)             AXDX  1434
          Call AirCoilLoad                                                      AXDX  1435
      END SELECT                                                                AXDX  1436
c                                                                               AXDX  1437
c              Solve for the coil choke factor and air outlet conditions        AXDX  1438
c              using an interpolating bi-sectional search                       AXDX  1439
      RfgMax = <ro.Moutlet>                                                     AXDX  1440
      RfgMin = 0.                                                               AXDX  1441
      UAmax  = 1.                                                               AXDX  1442
      UAmin  = 0.                                                               AXDX  1443
      RfgSet = <ac;MsupplyMax>                                                  AXDX  1444
      Denom  = 1./RfgSet                                                        AXDX  1445
      DO  nChoke=1,100                                                          AXDX  1446
        Flow1        = <ro.Moutlet>                                             AXDX  1447
c              Interpolate for Choke between solution boundaries                AXDX  1448
        Ratio        = (RfgSet-RfgMin) / (RfgMax-RfgMin)                        AXDX  1449
        Ratio        = MIN(0.85, MAX(0.15, Ratio))                              AXDX  1450
        <ac;UAchoke> = UAmin + (UAmax-UAmin)*Ratio                              AXDX  1451
c              coil performance with this UA                                    AXDX  1452
        Call AirCoilLoad                                                        AXDX  1453
c              compare flow to required flow                                    AXDX  1454
        Error = 1.- <ro.Moutlet>*Denom                                          AXDX  1455
        IF (ABS(Error) .LT. <sp:ERROR-FLOW>)  EXIT                              AXDX  1456
        Error = 1. - <ro.Moutlet>/Flow1                                         AXDX  1457
        IF (ABS(Error) .LT. <sp:ERROR-FLOW>)  EXIT                              AXDX  1458
c              tighten the solution boundaries                                  AXDX  1459
        IF (<ro.Moutlet> .GT. RfgSet)  THEN                                     AXDX  1460
          RfgMax = <ro.Moutlet>                                                 AXDX  1461
          UAmax  = <ac;UAchoke>                                                 AXDX  1462
        ELSE                                                                    AXDX  1463
          RfgMin = <ro.Moutlet>                                                 AXDX  1464
          UAmin  = <ac;UAchoke>                                                 AXDX  1465
        ENDIF                                                                   AXDX  1466
c              If flows have inverted, convergence is within the                AXDX  1467
c              accuracy inherent in 'AirCoilLoad'                               AXDX  1468
        IF (ABS(1.-RfgMin/RfgMax) .LT. <sp:ERROR-LOAD>)  EXIT                   AXDX  1469
        IF (nChoke .EQ. 100)                                                    AXDX  1470
     &    CALL CnvgMsg2(5, Routine, Jparent(<ac;Parent>))                       AXDX  1471
      ENDDO                                                                     AXDX  1472
c                                                                               AXDX  1473
      End Subroutine AirCoilChoked                                              AXDX  1474
c                                                                               AXDX  1475
c                                                                               AXDX  1476
c ============== AirCoilNoLoad ================================================ AXDX  1477
      Subroutine AirCoilNoLoad                                                  AXDX  1478
c                                                                               AXDX  1479
c              No coil load condition                                           AXDX  1480
c                                                                               AXDX  1481
      SST           = <Xai.Tinlet>                                              AXDX  1482
      <ao.Toutlet>  = <Xai.Tinlet>                                              AXDX  1483
      <ac;SurfTo>   = <Xai.Tinlet>                                              AXDX  1484
      <ao.Woutlet>  = <Xai.Winlet>                                              AXDX  1485
      <ac;SurfWo>   = <Xai.Winlet>                                              AXDX  1486
      <ac;AirHo>    = AirHi                                                     AXDX  1487
      <ac;Qair>     = 0.                                                        AXDX  1488
      <ac;TcoilUA>  = 0.                                                        AXDX  1489
      <ac;SurfWoUA> = 0.                                                        AXDX  1490
      <ac;Mfrost''> = <ac;Mfrost'>                                              AXDX  1491
      <ac;Qfrost''> = <ac;Qfrost'>                                              AXDX  1492
      <ro.Moutlet>  = 0.                                                        AXDX  1493
c                                                                               AXDX  1494
      End Subroutine AirCoilNoLoad                                              AXDX  1495
c                                                                               AXDX  1496
c                                                                               AXDX  1497
c ============== AirCoilReqdSuction =========================================== AXDX  1498
      Subroutine AirCoilReqdSuction                                             AXDX  1499
c                                                                               AXDX  1500
c              Get required saturated suction pressure and flow given           AXDX  1501
c              the airside leaving temperature.                                 AXDX  1502
                                                                                AXDX  1503
      Logical IterReqdHsty                                                      AXDX  1504
c                                                                               AXDX  1505
c              In block 'AirCoilLoad', ModeCoil = 1 allows this block to        AXDX  1506
c              set the SST                                                      AXDX  1507
      ModeCoil = 1                                                              AXDX  1508
c                                                                               AXDX  1509
      CALL HistoryInit(<ac;TreqdHsty>)                                          AXDX  1510
c                                                                               AXDX  1511
      SSTmax = <Xai.Tinlet> - 0.01                                              AXDX  1512
      SST    = MIN(<ac;SSTreqd>, SSTmax)                                        AXDX  1513
      DO  nReqdSST=1,100                                                        AXDX  1514
        Call AirCoilLoad                                                        AXDX  1515
        Tsetpt = TsetMin + dTband*MIN(1.,<ro.Moutlet>*<ac;1/MsupplyMax>)        AXDX  1516
        Error  = Tsetpt - <ao.Toutlet>                                          AXDX  1517
        <ac;SSTreqd> = SST + Error/eff                                          AXDX  1518
        <ac;SSTreqd> = MIN(MAX(<re;Tmin>, <ac;SSTreqd>), SSTmax)                AXDX  1519
        CALL CnvgCheck(2, <ac;TreqdHsty>)                                       AXDX  1520
        IF (.NOT. IterReqdHsty(<ac;TreqdHsty>)  .OR.                            AXDX  1521
     &     (nReqdSST .GT. 10  .AND.  ABS(Error) .LE. <sp:ERROR-T>)) EXIT        AXDX  1522
        SST = <ac;SSTreqd>                                                      AXDX  1523
        IF (nReqdSST .EQ. 100)  THEN                                            AXDX  1524
          CALL CnvgMsg2(6, Routine, Jparent(<ac;Parent>))                       AXDX  1525
        ENDIF                                                                   AXDX  1526
      ENDDO                                                                     AXDX  1527
      IF (Mode .gt. 100)  Return                                                AXDX  1528
c                                                                               AXDX  1529
c              Required flow                                                    AXDX  1530
      <ro.Mreqd> = MIN(<ro.Moutlet>, <ac;DesMsup>*1.5)                          AXDX  1531
c              Control valve pressure drop and required SSP                     AXDX  1532
      dPctrl  = (<ro.Mreqd>*<ac;1/DesMsup>)**1.87                               AXDX  1533
      dPctrl  = MAX(dPctrl*<ac;CtrlValveDP>, <ac:MIN-CTRL-DP>)                  AXDX  1534
      Pctrl   = RefgP_fT(Jre, <ac;SSTreqd>)                                     AXDX  1535
      SSPreqd = MAX(<re;Pmin>,  Pctrl-dPctrl)                                   AXDX  1536
c                                                                               AXDX  1537
c              If running below setpoint, reset reqd suction to setpoint        AXDX  1538
      IF (<ao.Toutlet> .LT. <Xao.Treqd>)                                        AXDX  1539
     &  <ac;SSTreqd> = <ac;SSTreqd> + <Xao.Treqd>-<ao.Toutlet>                  AXDX  1540
c              Required SSP to suction group; if defrosted recently,            AXDX  1541
c              limit requested P                                                AXDX  1542
      IF (<ac;HoursLastDef> .EQ. 0  .OR.  (<ac;HoursLastDef> .EQ. 1             AXDX  1543
     &                         .AND.  <ac;DefrostFrac'> .GT. 0.5))  THEN        AXDX  1544
        SSTdef     = MAX(<ac;SSTreqd>, <Xao.Treqd>-<ac:SST-SUPPLY-TD>)          AXDX  1545
        Pctrl      = RefgP_fT(Jre, SSTdef)                                      AXDX  1546
        dPctrl     = MIN(dPctrl, <ac;CtrlValveDP>)                              AXDX  1547
        <ro.Preqd> = MAX(<re;Pmin>, Pctrl-dPctrl)                               AXDX  1548
      ELSE  ! no recent defrost                                                 AXDX  1549
        <ro.Preqd> = SSPreqd                                                    AXDX  1550
      ENDIF                                                                     AXDX  1551
c                                                                               AXDX  1552
      End Subroutine AirCoilReqdSuction                                         AXDX  1553
c                                                                               AXDX  1554
c                                                                               AXDX  1555
c ============== AirCoilReqdSuction_fW ======================================== AXDX  1556
      Subroutine AirCoilReqdSuction_fW                                          AXDX  1557
c                                                                               AXDX  1558
c              Get required saturated suction pressure given the                AXDX  1559
c              airside leaving humidity ratio.  Note that humidity              AXDX  1560
c              control does not use a setpoint throttling range.                AXDX  1561
c                                                                               AXDX  1562
c     ?? not debugged                                                           AXDX  1563
c                                                                               AXDX  1564
      Logical IterReqdHsty                                                      AXDX  1565
                                                                                AXDX  1566
c              In block 'AirCoilLoad', ModeCoil = 1 allows this block to        AXDX  1567
c              set the SST                                                      AXDX  1568
      ModeCoil = 1                                                              AXDX  1569
c                                                                               AXDX  1570
      CALL HistoryInit(<ac;TreqdHsty>)                                          AXDX  1571
c                                                                               AXDX  1572
      SSTmax = <Xai.Tinlet> - 0.01                                              AXDX  1573
      SST    = MIN(<ac;SSTreqd>, SSTmax)                                        AXDX  1574
      DO  nReqdSSTw=1,100                                                       AXDX  1575
        dW = <Xai.Winlet> - <ao.Woutlet>                                        AXDX  1576
        IF (dW .GT. 0.)  THEN                                                   AXDX  1577
          ErrorW       = <Xao.Wreqd> - <ao.Woutlet>                             AXDX  1578
          dTdW         = (<Xai.Tinlet> - <ao.Toutlet>) / dW                     AXDX  1579
          ErrorT       = ErrorW * dTdW                                          AXDX  1580
          <ac;SSTreqd> = <ac;SSTreqd> + ErrorT/eff                              AXDX  1581
        ELSE                                                                    AXDX  1582
          <ac;SSTreqd> = <ac;SSTreqd> - 10.                                     AXDX  1583
        ENDIF                                                                   AXDX  1584
        <ac;SSTreqd> = MIN(MAX(<re;Tmin>, <ac;SSTreqd>), SSTmax)                AXDX  1585
        CALL CnvgCheck(2, <ac;TreqdHsty>)                                       AXDX  1586
        IF (.NOT. IterReqdHsty(<ac;TreqdHsty>))  EXIT                           AXDX  1587
        SST = <ac;SSTreqd>                                                      AXDX  1588
        Call AirCoilLoad                                                        AXDX  1589
        IF (nReqdSSTw .EQ. 100)                                                 AXDX  1590
     &    CALL CnvgMsg2(7, Routine, Jparent(<ac;Parent>))                       AXDX  1591
      ENDDO                                                                     AXDX  1592
c                                                                               AXDX  1593
c              Required flow                                                    AXDX  1594
      <ro.Mreqd> = MIN(<ro.Moutlet>, <ac;DesMsup>*1.5)                          AXDX  1595
c              Control valve pressure drop and required SSP                     AXDX  1596
      dPctrl     = (<ro.Mreqd>*<ac;1/DesMsup>)**1.87                            AXDX  1597
      dPctrl     = MAX(dPctrl*<ac;CtrlValveDP>, <ac:MIN-CTRL-DP>)               AXDX  1598
      Pctrl      = RefgP_fT(Jre, <ac;SSTreqd>)                                  AXDX  1599
      <ro.Preqd> = MAX(<re;Pmin>,  Pctrl-dPctrl)                                AXDX  1600
c                                                                               AXDX  1601
      End Subroutine AirCoilReqdSuction_fW                                      AXDX  1602
c                                                                               AXDX  1603
c                                                                               AXDX  1604
c ============== AirCoilReqdSuction_NoLoad ==================================== AXDX  1605
      Subroutine AirCoilReqdSuction_NoLoad                                      AXDX  1606
c                                                                               AXDX  1607
c              When a no load condition exists because the suction              AXDX  1608
c              temperature is too warm, sets the required suction               AXDX  1609
c              pressure and flow to tentative values in hope that               AXDX  1610
c              the suction group responds                                       AXDX  1611
c                                                                               AXDX  1612
      AirHo      = HAir(<Xao.Treqd>, <Xai.Winlet>)                              AXDX  1613
      Qest       = <ao.Moutlet> * <ac;CpDemand> * (AirHi-AirHo)                 AXDX  1614
      <ro.Mreqd> = Qest / (<Xro.Houtlet>-<Xri.Hinlet>)                          AXDX  1615
      SST        = <Xao.Treqd> - 5.                                             AXDX  1616
      <ro.Preqd> = RefgP_fT(Jre, MAX(<re;Tmin>, SST))                           AXDX  1617
c                                                                               AXDX  1618
      End Subroutine AirCoilReqdSuction_NoLoad                                  AXDX  1619
                                                                                AXDX  1620
      END                                                                       AXDX  1621
      FUNCTION Aircoil_Tsurf(Hsat)                                              ACTsrf   2
c                                                                               ACTsrf   3
c              Calculates the surface temperature corresponding to              ACTsrf   4
c              a saturated enthaply                                             ACTsrf   5
c                                                                               ACTsrf   6
c              Hsat  Saturated enthaply on surface                              ACTsrf   7
c                                                                               ACTsrf   8
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /DatSrf/ Tsurface, Hsurface, dTdH                                 /DatSrf/ 2
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /WEATH / IWDID(5),LRECX,WLAT,WLONG,LTIMZ,IFX,IWSIZ,               /WEATH/  2
     1                 CLRNES,TGNDR,WBT,DBT,Patm,CLDAMT,ISNOW,IRAIN,            /WEATH/  3
     2                 IWNDDR,HUMRAT,DENSTY,ENTHAL,DIFSOL,DIRSOL,SOLRAD,        /WEATH/  4
     3                 ICLDTY,WNDSPD,IDUMMY,DPT,WNDDRR,CLDCOV,RDNCC,            /WEATH/  5
     4                 BSCC,SKYA,DBTR,GTEMP(12),CLR(12),ESKY,EGND,IWINTR        /WEATH/  6
                                                                                ACTsrf  14
      HAir(DB,W) = 0.24*DB + (1061.0 + 0.444*DB)*W                              HAir     2
c                                                                               ACTsrf  16
c              Find temperature corresponding to this saturated enthalpy        ACTsrf  17
      DO  Iter=1,100                                                            ACTsrf  18
        Herror   = Hsat - Hsurface                                              ACTsrf  19
        IF (ABS(Herror) .LT. 0.001)  GOTO 10                                    ACTsrf  20
        Terror   = Herror * dTdH                                                ACTsrf  21
        Tnew     = Tsurface + Terror                                            ACTsrf  22
        Wnew     = Wfunc(Tnew, 100., Patm)                                      ACTsrf  23
        Hnew     = HAir(Tnew, Wnew)                                             ACTsrf  24
        dH       = Hnew - Hsurface                                              ACTsrf  25
        IF (ABS(dH) .LT. 0.000001)  GOTO 10                                     ACTsrf  26
        dTdH     = (Tnew - Tsurface) / dH                                       ACTsrf  27
        Tsurface = Tnew                                                         ACTsrf  28
        Hsurface = Hnew                                                         ACTsrf  29
      ENDDO                                                                     ACTsrf  30
c                                                                               ACTsrf  31
      WRITE (IOUTPT,9101)                                                       ACTsrf  32
c                                                                               ACTsrf  33
   10 AirCoil_Tsurf = Tsurface                                                  ACTsrf  34
c                                                                               ACTsrf  35
      RETURN                                                                    ACTsrf  36
c                                                                               ACTsrf  37
 9101 FORMAT(14x,'Aircoil_Tsurf convergence failure')                           ACTsrf  38
      END                                                                       ACTsrf  39
      Subroutine RefgCoils_Old(Mode)                                            CoilsO   2
c                                                                               CoilsO   3
c              Simulates the refrigerant-side of the old-style coils found      CoilsO   4
c              in version DOE-2.2, and not upgraded to the new models           CoilsO   5
c                                                                               CoilsO   6
c                                                                               /JJHSDG/ 2
c              DEVELOPED BY                                                     /JJHSDG/ 3
c                            S. D. Gates                                        /JJHSDG/ 4
c                            J. J. Hirsch                                       /JJHSDG/ 5
c                            James J. Hirsch & Associates                       /JJHSDG/ 6
c                            Camarillo, California                              /JJHSDG/ 7
c                            Doug Scott                                         /JJHSDG/ 8
c                            Vacom Technologies                                 /JJHSDG/ 9
c                                                                               /JJHSDG/10
Copyright (c) 1997-2001 by James J. Hirsch.  All Rights Reserved.               /JJHSDG/11
c Unpublished rights reserved under the Copyright Laws of the United States.    /JJHSDG/12
c U.S. GOVERNMENT RESTRICTED RIGHTS:  In accordance with FAR 12.212 or          /JJHSDG/13
c DFARS 227.7202, as applicable, use, duplication, or disclosure of the         /JJHSDG/14
c SOFTWARE by the Government is subject to restrictions. Manufacturer is        /JJHSDG/15
c James J. Hirsch DBA James J. Hirsch & Associates, 12185 Presilla Road,        /JJHSDG/16
c Camarillo, CA, 93012-9243.                                                    /JJHSDG/17
c                                                                               /JJHSDG/18
      COMMON //        AA(75 000 000)                                           /BLANK/  2
      INTEGER          IA(75 000 000)                                           /BLANK/  3
      EQUIVALENCE      (AA(1),IA(1))                                            /BLANK/  4
      COMMON  /FILES / ISTNDF,ICTRL,IWEATH,ITDV,IDSNFL,ILDSO,ISYSO,             /FILES/  2
     1                 IREPFL,IHDFIL,IHRHDF,IOUTPT,IOVRL,                       /FILES/  3
     2                 IPLTO, IPPFIL, ICECHR, ICECDT, ICECPR,                   /FILES/  4
     3                 IHRREP(3), IHRPAS(2)                                     /FILES/  5
      COMMON  /MISCD / TEMPS(4,4096),CONS(5),TEMPSL(4096),                      /MISCD/  2
     1                 BLDGQH,BLDGQC,BLDGQL,BLDGP,BPMULT,                       /MISCD/  3
     2                 DBTMIN,DBTMAX,WMIN,WMAX,NSPZ(4096),                      /MISCD/  4
     3                 DQ, DTP, DTR, DTS, FPI, PLRCC , POM, TC2, TDM,           /MISCD/  5
     4                 TRA,WCOL,WCOLM,WMM,YPI,KWBTU,BtuKW,UNFILD,Unusedm        /MISCD/  6
      REAL             KWBTU                                                    /MISCD/  7
      COMMON  /PtrJsp/ Jsp                                                      /PtrJsp/ 2
      COMMON  /PTRSYS/ nvect ,                                                  /PTRSYS/ 2
     $                 nsched, its   ,                                          /PTRSYS/ 3
     $                 ncurve, icurve,                                          /PTRSYS/ 4
     $                 nzone , iz    , nczd  , zp2 ,         mtw  ,             /PTRSYS/ 5
     $                 nsys  , is    , nss   , nsp ,  ns   , icode,             /PTRSYS/ 6
     $                 nsz   , isz   , nzd   , zp1 ,  nz   ,                    /PTRSYS/ 7
     $                 nspace, lpr   , Lcv   ,                                  /PTRSYS/ 8
     $                 nattch, iatt  ,                                          /PTRSYS/11
     $                 P2, IDAYHR, IDBWBT,                                      /PTRSYS/12
     $                 IRPPLT, IRPSUM, IRPSYS, IRPZON, MR1, MR2                 /PTRSYS/13
      INTEGER          ZP1, ZP2, P2                                             /PTRSYS/14
      COMMON  /REPORT/ IREPRT(4,37),IPRG,IUNIQV(100),IUNIQS(100),IUNIQL         /REPORT/ 2
      COMMON  /TIME  / IDOY, IDOW, IDSTF, ISCHR, ISCDAY, iDSdates(6),           /TIME/   2
     &                 IMO, IDAY, IYR, IHR, CLOCK(10), IDSFLG,                  /TIME/   3
     &                 MONDSC(12), MONLEN(12), MONSDA(12), IEODMR               /TIME/   4
c                                                                               CoilsO  15
c                                                                               CoilsO  16
      INTEGER  Xri, Xro                                                         CoilsO  17
      LOGICAL  IterNode, IterReqdNode, IterReqdHsty                             CoilsO  18
c                                                                               CoilsO  19
c                                                                               CoilsO  20
      SELECT CASE (Mode)                                                        CoilsO  21
c                                                                               CoilsO  22
c                                                                               CoilsO  23
c ============ HOURLY INITIALIZATION ========================================== CoilsO  24
      CASE (10)                                                                 CoilsO  25
c                                                                               CoilsO  26
c              Initialization for hourly load variables for all system          CoilsO  27
c              coils except heat reclaim node variables is done in PLANT        CoilsO  28
c                                                                               CoilsO  29
c                                                                               CoilsO  30
c ============ HOURLY SIMULATION - PRIOR TO HVAC CALLS ======================== CoilsO  31
      CASE (30)                                                                 CoilsO  32
c                                                                               CoilsO  33
c              Since airside not simulated yet, just clear the iteration        CoilsO  34
c              flags                                                            CoilsO  35
      DO  NS=1,NSYS                                                             CoilsO  36
        NSP = IS + (NS-1)*NSS                                                   CoilsO  37
c              skip if this system is not attached to any refg circuits         CoilsO  38
        IF (<sy;RefgCktFlag> .GT. 0)  THEN                                      CoilsO  39
          IF (<sy;RfgDXHsty> .GT. 0)  THEN                                      CoilsO  40
            CALL IterSetNode(0, <sy;RfgNodes>)                                  CoilsO  41
            CALL HstyClearFlag(<sy;RfgDXHsty>)                                  CoilsO  42
          ENDIF                                                                 CoilsO  43
        ENDIF                                                                   CoilsO  44
        IF (<sy;RefgHtRecNode> .GT. 0)                                          CoilsO  45
     &    CALL IterSetNode(0, <sy;RefgHtRecNode>)                               CoilsO  46
      ENDDO    ! NS                                                             CoilsO  47
c                                                                               CoilsO  48
c                                                                               CoilsO  49
c ============ HOURLY SIMULATION ============================================== CoilsO  50
      CASE (31)                                                                 CoilsO  51
c                                                                               CoilsO  52
c              loop through all systems and zones and calculate                 CoilsO  53
c              the coil flows for any coils on this loop                        CoilsO  54
      DO  NS=1,NSYS                                                             CoilsO  55
        NSP = IS + (NS-1)*NSS                                                   CoilsO  56
c              skip if this system is not attached to any refg circuits         CoilsO  57
        IF (<sy;RefgCktFlag> .EQ. 0)  CYCLE                                     CoilsO  58
c                                                                               CoilsO  59
c              Central system DX coil                                           CoilsO  60
        IF (<REFG-LIQ-CKT> .GT. 0)  THEN                                        CoilsO  61
        IterNode = IterReqdNode(1, <sy;RfgNodes>)                               CoilsO  62
        IF (IterNode  .OR.  IterReqdHsty(<sy;RfgDXHsty>))  THEN                 CoilsO  63
          Kri = <sy;RfgLiquidNode>      ! Inlet node                            CoilsO  64
          Kro = <sy;RfgSuctionNod>      ! Outlet node                           CoilsO  65
c              Fraction of hour demander runs                                   CoilsO  66
          <ri.RunFrac> = <CL_COIL_CYCLE>                                        CoilsO  67
          <ro.RunFrac> = <CL_COIL_CYCLE>                                        CoilsO  68
c                                                                               CoilsO  69
          IF (<CL_COIL_Q> .GT. 0.)  THEN                                        CoilsO  70
            Xri = <ri;Xnode>             ! Xfaced Inlet                         CoilsO  71
            Xro = <ro;Xnode>             ! Xfaced Outlet                        CoilsO  72
            Jrc = <REFG-LIQ-CKT>                                                CoilsO  73
            Jre = <rc;Refrigerant>       ! Refrigerant                          CoilsO  74
c                                                                               CoilsO  75
c              Leaving refrigerant enthalpy and flow                            CoilsO  76
            SST          = RefgT_fP(Jre, <Xro.Poutlet>)                         CoilsO  77
            <ro.Houtlet> = RefgH_Vapor_fTS(Jre, SST, 10.)                       CoilsO  78
            <ro.Moutlet> = <CL_COIL_Q> / (<ro.Houtlet>-<Xri.Hinlet>)            CoilsO  79
c                                                                               CoilsO  80
c              Refrigerant conditions at inlet                                  CoilsO  81
            <ri.Minlet>  = <ro.Moutlet>                                         CoilsO  82
            <ri.Qinlet>  = <ri.Minlet>                                          CoilsO  83
     &                   * (<Xri.Hinlet>-AA(<rc;RefgHrefPtr>))                  CoilsO  84
            <ro.Qoutlet> = <ri.Qinlet> + <CL_COIL_Q>                            CoilsO  85
c              crude approximation for required suction temperature             CoilsO  86
            dTreqd  = <SST-SUPPLY-TD> *<CL_COIL_Q>/<COOLING-CAPACITY>           CoilsO  87
            SSTreqd = <CL_COIL_LWB> - dTreqd                                    CoilsO  88
            <ro.Preqd> = RefgP_fT(Jre, SSTreqd)                                 CoilsO  89
            <ri.Preqd> = <ro.Preqd> + 10.                                       CoilsO  90
c              Liquid should be delivered no warmer than saturation             CoilsO  91
            <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                            CoilsO  92
          ELSE                                                                  CoilsO  93
            <ri.Minlet>  = 0.                                                   CoilsO  94
            <ro.Moutlet> = 0.                                                   CoilsO  95
          ENDIF  ! CL_COIL_Q                                                    CoilsO  96
          <ri.Mreqd> = <ro.Moutlet>                                             CoilsO  97
          <ro.Mreqd> = <ro.Moutlet>                                             CoilsO  98
c                                                                               CoilsO  99
c              Check for convergence on outlet conditions                       CoilsO 100
          CALL CnvgCheck(1, <sy;RfgDXHsty>)                                     CoilsO 101
        ENDIF                                                                   CoilsO 102
        ENDIF  ! REFG-LIQ-CKT                                                   CoilsO 103
c              clear heat reclaim flag                                          CoilsO 104
        IF (<sy;RefgHtRecNode> .GT. 0)                                          CoilsO 105
     &    CALL IterSetNode(0, <sy;RefgHtRecNode>)                               CoilsO 106
      ENDDO  ! NS                                                               CoilsO 107
c                                                                               CoilsO 108
c                                                                               CoilsO 109
c ============ REPORT CREATION ================================================ CoilsO 110
      CASE (50)                                                                 CoilsO 111
c                                                                               CoilsO 112
c                                                                               CoilsO 113
c ============ REPORTS - VERIFICATION DATA ==================================== CoilsO 114
      CASE (54)                                                                 CoilsO 115
c                                                                               CoilsO 116
c                                                                               CoilsO 117
c ============ HOURLY REPORTS - HOURLY DATA =================================== CoilsO 118
      CASE (62)                                                                 CoilsO 119
c                                                                               CoilsO 120
c                                                                               CoilsO 121
c ============ DESIGN CALCULATIONS ============================================ CoilsO 122
      CASE (111)                                                                CoilsO 123
c                                                                               CoilsO 124
c              loop thru all systems and calculate the flows                    CoilsO 125
      DO  NS=1,NSYS                                                             CoilsO 126
        NSP = IS + (NS-1)*NSS                                                   CoilsO 127
c             central cooling coil (refg-system DX)                             CoilsO 128
        IF (<COOLING-CAPACITY> .GT. 1.  .AND.                                   CoilsO 129
     &                                   <REFG-LIQ-CKT> .GT. 0)  THEN           CoilsO 130
          Kri = <sy;RfgLiquidNode>     ! Inlet node                             CoilsO 131
          Xri = <ri;Xnode>             ! Xfaced Inlet                           CoilsO 132
          Kro = <sy;RfgSuctionNod>     ! Outlet node                            CoilsO 133
          Xro = <ro;Xnode>             ! Xfaced Outlet                          CoilsO 134
          Jrc = <REFG-LIQ-CKT>                                                  CoilsO 135
          Jre = <rc;Refrigerant>       ! Refrigerant                            CoilsO 136
c                                                                               CoilsO 137
c              Refrigerant conditions at outlet to suction                      CoilsO 138
          SSTreqd      = <MIN-SUPPLY-T> - <SST-SUPPLY-TD>                       CoilsO 139
          <ro.Preqd>   = RefgP_fT(Jre, SSTreqd)                                 CoilsO 140
          <ro.Houtlet> = RefgH_Vapor_fSP(Jre, 10., <ro.Preqd>)                  CoilsO 141
          <ro.Moutlet> = <COOLING-CAPACITY>/(<ro.Houtlet>-<Xri.Hinlet>)         CoilsO 142
c                                                                               CoilsO 143
c              Check for convergence on outlet conditions                       CoilsO 144
          CALL CnvgCheck(1, <sy;RfgDXHsty>)                                     CoilsO 145
c                                                                               CoilsO 146
          <ri.Qinlet> = <ro.Moutlet>*(<Xri.Hinlet>-AA(<rc;RefgHrefPtr>))        CoilsO 147
          <ro.Qoutlet> = <ri.Qinlet> + <COOLING-CAPACITY>                       CoilsO 148
c              Refrigerant conditions at inlet from liquid                      CoilsO 149
          <ri.Minlet> = <ro.Moutlet>                                            CoilsO 150
          <ri.Mreqd>  = <ro.Moutlet>                                            CoilsO 151
          <ro.Mreqd>  = <ro.Moutlet>                                            CoilsO 152
          <ri.Preqd>  = <ro.Preqd> + 10.                                        CoilsO 153
c              Liquid should be delivered no warmer than saturation             CoilsO 154
          <ri.Treqd> = RefgT_fP(Jre, <Xri.Pinlet>)                              CoilsO 155
        ENDIF                                                                   CoilsO 156
      ENDDO  ! systems loop                                                     CoilsO 157
c                                                                               CoilsO 158
c                                                                               CoilsO 159
c ============ DESIGN CALCULATIONS - RECONCILIATION =========================== CoilsO 160
      CASE (119)                                                                CoilsO 161
c                                                                               CoilsO 162
      DO  NS=1,NSYS                                                             CoilsO 163
        NSP = IS + (NS-1)*NSS                                                   CoilsO 164
c                                                                               CoilsO 165
c              Heat recovery from refrigeration system                          CoilsO 166
        IF (<REFG-HTREC-CKT> .GT. 0)  THEN                                      CoilsO 167
          IF (<REFG-HTREC-CAP> .EQ. 0.)                                         CoilsO 168
     &        <REFG-HTREC-CAP> = <HEATING-CAPACITY>                             CoilsO 169
          <REFG-HTREC-CAP> = -Abs(<REFG-HTREC-CAP>)                             CoilsO 170
c              maximum refrigerant flow; assume 50% greater than design         CoilsO 171
          Jrc   = <REFG-HTREC-CKT>               ! High-side circuit            CoilsO 172
          Kri   = <rc;InletNode>                 ! Discharge ckt inlet          CoilsO 173
          Jre   = <rc;Refrigerant>               ! Refrigerant                  CoilsO 174
          dTsub = Min(10., <REFG-HTREC-DT>*0.66) ! liquid subcooling            CoilsO 175
          Hliq  = RefgH_Liquid_fSP(Jre, dTsub, <ri.Pinlet>)                     CoilsO 176
          <sy;MaxMrefgHtRec> = <REFG-HTREC-CAP> / (Hliq - <ri.Hinlet>)          CoilsO 177
          <sy;MaxMrefgHtRec> = <sy;MaxMrefgHtRec> * 1.5                         CoilsO 178
        ENDIF                                                                   CoilsO 179
      ENDDO  ! systems loop                                                     CoilsO 180
c                                                                               CoilsO 181
c                                                                               CoilsO 182
c ============ ATTACHMENTS ==================================================== CoilsO 183
c                                                                               CoilsO 184
c              Initial attachments                                              CoilsO 185
      CASE (201)                                                                CoilsO 186
c              set up refrigeration interface in all systems                    CoilsO 187
c              and zones                                                        CoilsO 188
        DO  NS=1,NSYS                                                           CoilsO 189
          NSP = IS + (NS-1)*NSS                                                 CoilsO 190
          Icode = <SYSTEM-TYPE>                                                 CoilsO 191
          <REFG-LIQ-CKT>   = Jcomponent(22, <REFG-LIQ-CKT>)                     CoilsO 192
          <REFG-SUC-CKT>   = Jcomponent(22, <REFG-SUC-CKT>)                     CoilsO 193
          <REFG-HTREC-CKT> = Jcomponent(22, <REFG-HTREC-CKT>)                   CoilsO 194
        ENDDO  ! systems loop                                                   CoilsO 195
c                                                                               CoilsO 196
c              Create nodes                                                     CoilsO 197
      CASE (203)                                                                CoilsO 198
c              set up all system and zone coil nodes                            CoilsO 199
        DO  NS=1,NSYS                                                           CoilsO 200
          NSP = IS + (NS-1)*NSS                                                 CoilsO 201
c              DX cooling from refrigeration system                             CoilsO 202
          IF (<REFG-LIQ-CKT> .GT. 0)  THEN                                      CoilsO 203
c              flag to indicate this system attached to a refg circuit          CoilsO 204
            <sy;RefgCktFlag> = 1                                                CoilsO 205
c              Check if cross-connected between two different systems           CoilsO 206
            CALL RefgX(NSP, <REFG-LIQ-CKT>,                                     CoilsO 207
     &                                 <REFG-SUC-CKT>,0)                        CoilsO 208
c              liquid and suction attachments                                   CoilsO 209
            <sy;RfgLiquidNode> = NewNode(1, NSP,0,NSP,<REFG-LIQ-CKT>,           CoilsO 210
     &                                   61,1,<sy:COOL-END-USE>, 1.)            CoilsO 211
            <sy;RfgSuctionNod> = NewNode(1, NSP,0,NSP,<REFG-SUC-CKT>,           CoilsO 212
     &                                   62,2,<sy:COOL-END-USE>, 1.)            CoilsO 213
          ENDIF                                                                 CoilsO 214
c              Heat recovery from refrigeration system                          CoilsO 215
          IF (<REFG-HTREC-CKT> .GT. 0)  THEN                                    CoilsO 216
c              flag to indicate this system attached to a refg circuit          CoilsO 217
            <sy;RefgCktFlag>   = 1                                              CoilsO 218
            <sy;RefgHtRecNode> = NewNode(1, NSP,0,NSP,<REFG-HTREC-CKT>,         CoilsO 219
     &                                                       68,2,0, 1.)        CoilsO 220
          ENDIF                                                                 CoilsO 221
c              end of systems loop                                              CoilsO 222
        ENDDO                                                                   CoilsO 223
c                                                                               CoilsO 224
c              Histories, Dependencies                                          CoilsO 225
      CASE (208)                                                                CoilsO 226
        DO  NS=1,NSYS                                                           CoilsO 227
          NSP   = IS + (NS-1)*NSS                                               CoilsO 228
          IF (<REFG-SUC-CKT> .GT. 0)  THEN                                      CoilsO 229
            CALL ListAdd(<sy;RfgNodes>, <sy;RfgLiquidNode>)                     CoilsO 230
            CALL ListAdd(<sy;RfgNodes>, <sy;RfgSuctionNod>)                     CoilsO 231
            KliX = 0                                                            CoilsO 232
            CALL ListXNodes(<sy;RfgNodes>, KliX)                                CoilsO 233
            Kro = <sy;RfgSuctionNod>                                            CoilsO 234
            <sy;RfgDXHsty> = NewHistory(NSP,0,NSP, KliX, Kro,                   CoilsO 235
     &                         5, 1, 1.5,                                       CoilsO 236
     &                         <#ro.Qoutlet>, <sp:ERROR-LOAD>, 2,               CoilsO 237
     &                         <#ro.Moutlet>, <sp:ERROR-FLOW>, 2,               CoilsO 238
     &                         <#ro.Mreqd>  , <sp:ERROR-FLOW>, 2,               CoilsO 239
     &                         0,0.,0, 0,0.,0, 0,0.,0)                          CoilsO 240
                                                                                CoilsO 241
          ENDIF                                                                 CoilsO 242
        ENDDO    ! systems loop                                                 CoilsO 243
c                                                                               CoilsO 244
c              Dump pointers                                                    CoilsO 245
      CASE (210)                                                                CoilsO 246
        iFlag = 0                                                               CoilsO 247
        DO  NS=1,NSYS                                                           CoilsO 248
          NSP = IS + (NS-1)*NSS                                                 CoilsO 249
          IF (<REFG-SUC-CKT> .GT. 0)  THEN                                      CoilsO 250
            IF (iFlag .eq. 0)  THEN                                             CoilsO 251
              iFlag = 1                                                         CoilsO 252
              WRITE (IOUTPT, 9201)                                              CoilsO 253
            ENDIF                                                               CoilsO 254
            WRITE (IOUTPT, 9202)  (<SYSTEM-NAME>,II=1,8),                       CoilsO 255
     &        NSP, <sy;RfgLiquidNode>, <sy;RfgSuctionNod>,                      CoilsO 256
     &        <sy;RefgHtRecNode>                                                CoilsO 257
          ENDIF                                                                 CoilsO 258
        ENDDO    ! systems loop                                                 CoilsO 259
c                                                                               CoilsO 260
c                                                                               CoilsO 261
      END SELECT  ! Mode                                                        CoilsO 262
c                                                                               CoilsO 263
      RETURN                                                                    CoilsO 264
c                                                                               CoilsO 265
c              Message formats                                                  CoilsO 266
 9201 FORMAT(/' Air Handlers                           NSP       Liq',          CoilsO 267
     &'       Suc     HtRec'                                 /                  CoilsO 268
     &1x,32('-'),4('  --------'))                                               CoilsO 269
 9202 FORMAT(1x,8A4,5I10)                                                       CoilsO 270
c                                                                               CoilsO 271
      END                                                                       CoilsO 272
C ##############################################################################Psych    2
C ##############################################################################Psych    3
C ##############################################################################Psych    4
C ##############################################################################Psych    5
C ##########                                                          ##########Psych    6
C ##########                  PSYCHROMETRIC ROUTINES                  ##########Psych    7
C ##########                                                          ##########Psych    8
C ##############################################################################Psych    9
C ##############################################################################Psych   10
C ##############################################################################Psych   11
C ##############################################################################Psych   12
c                                                                               Psych   13
c                                                                               Psych   14
c              Routines that calculate the properties of moist air              Psych   15
c                                                                               Psych   16
c              Hsat                                                             Psych   17
c              Inline functions called as a comdeck                             Psych   18
c                                                                               Psych   19
c              Tdb                Drybulb T            f(H,W)                   Psych   20
c              H                  Enthalpy             f(Tdb,W)                 Psych   21
c                                                                               Psych   22
